{"version":3,"file":"dist/sidh.debug.js","sources":["libsodium/src/libsodium/sodium/utils.c","libsodium/src/libsodium/randombytes/randombytes.c","SIDH/SIDH_setup.c","SIDH/ec_isogeny.c","SIDH/fpx.c","SIDH/SIDH_internal.h","SIDH/generic/fp_generic.c","SIDH/generic/../SIDH_internal.h","SIDH/kex.c","sidh.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8JA;AADA;AAGA;AADA;AAGA;AACA;AAMA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AClGA;AAAA;;;;;AAeA;AA4BA;;;;;;;;;;AAkCA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;AC5IA;AAAA;;AACA;AA8BA;AAAA;;AA3BA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;;AAkEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;AAHA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;AAnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAGA;AAAA;;AADA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAqFA;AACA;AAAA;AAEA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;AAPA;AAmBA;AAAA;;;AAfA;AAAA;AAeA;AAAA;;;AAVA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;;;;AAzCA;AAyCA;AAAA;;;;;;;;;;AAkDA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;ACnPA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AA6CA;AAAA;;;AAzCA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAsCA;AAAA;;;AAnCA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AADA;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAeA;AACA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AAOA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;AASA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAOA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AC3iBA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;AAOA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;;AAoBA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAwIA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAtIA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AAyCA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;AAKA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AD4DA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAOA;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAOA;;;;;;;;;;;AAOA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAOA;AAAA;AAAA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;;AAcA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAFA;AAAA;AAAA;;AAIA;AAAA;AACA;;;;;;;;;AAOA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AAsGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAYA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAwBA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;AAQA;;;;;;;;;;;;;;;;;;;AASA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAcA;;;;;;;;;;;;;;;;AAQA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;AEnnBA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;AC8CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AD7BA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;AAMA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;AAOA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;AACA;;;;;;;;;;;AAKA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;AAOA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAOA;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AAAA;AAAA;;AAYA;;;;;;;;;;;;;;;;;;;;;;AA2CA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AALA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAfA;AAAA;AAAA;;AAkBA;;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AALA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAlBA;AAAA;AAAA;;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEpOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAiFA;AAAA;;AA9EA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAwEA;AAAA;;AArEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAtBA;AAAA;AAAA;;AAyBA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;AAxFA;AAwFA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AA2EA;AAAA;;AAxEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAkEA;AAAA;;AA/DA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAtBA;AAAA;AAAA;;AAyBA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;AAlFA;AAkFA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAwCA;AAAA;;AAtCA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAnBA;AAAA;AAAA;;AAsBA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;AArDA;AAqDA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAsCA;AAAA;;AAnCA;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAnBA;AAAA;AAAA;;AAsBA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;AAnDA;AAmDA;AAAA;;;;;;;;;;ACtVA;AAAA;AAAA;AACA;;;;;AAIA;AAEA;AAAA;AAGA;AADA;AAAA;;;;;AAQA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAIA;;;;;;;;;;;;AASA;AAAA;;;;;AACA;AAAA;AAKA;AAAA;;AAFA;AAAA;AAEA;AAAA;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAoBA;AAAA;;AAhBA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAMA;AAAA;;AACA;AAAA;AAUA;AAAA;;AANA;AAAA;AAAA;AACA;AACA;AAHA;AAMA;AACA;AAAA;;;;;;;;;;;;;;;;AASA;AAAA;;;;;;AACA;AAAA;AAKA;AAAA;;AAFA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;AAQA;AACA;AAAA;AAAA;AACA;AAHA;AAAA;AAMA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;AAGA;AASA;AAAA;;;AALA;AACA;AACA;AACA;AAJA;AAAA;AAMA;AAAA","sourcesContent":["#ifndef __STDC_WANT_LIB_EXT1__\n# define __STDC_WANT_LIB_EXT1__ 1\n#endif\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_SYS_MMAN_H\n# include <sys/mman.h>\n#endif\n\n#ifdef _WIN32\n# include <windows.h>\n# include <wincrypt.h>\n#else\n# include <unistd.h>\n#endif\n\n#include \"randombytes.h\"\n#include \"utils.h\"\n\n#ifndef ENOSYS\n# define ENOSYS ENXIO\n#endif\n\n#if defined(_WIN32) && \\\n    (!defined(WINAPI_FAMILY) || WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)\n# define WINAPI_DESKTOP\n#endif\n\n#define CANARY_SIZE 16U\n#define GARBAGE_VALUE 0xdb\n\n#ifndef MAP_NOCORE\n# define MAP_NOCORE 0\n#endif\n#if !defined(MAP_ANON) && defined(MAP_ANONYMOUS)\n# define MAP_ANON MAP_ANONYMOUS\n#endif\n#if defined(WINAPI_DESKTOP) || (defined(MAP_ANON) && defined(HAVE_MMAP)) || \\\n    defined(HAVE_POSIX_MEMALIGN)\n# define HAVE_ALIGNED_MALLOC\n#endif\n#if defined(HAVE_MPROTECT) && \\\n    !(defined(PROT_NONE) && defined(PROT_READ) && defined(PROT_WRITE))\n# undef HAVE_MPROTECT\n#endif\n#if defined(HAVE_ALIGNED_MALLOC) && \\\n    (defined(WINAPI_DESKTOP) || defined(HAVE_MPROTECT))\n# define HAVE_PAGE_PROTECTION\n#endif\n#if !defined(MADV_DODUMP) && defined(MADV_CORE)\n# define MADV_DODUMP   MADV_CORE\n# define MADV_DONTDUMP MADV_NOCORE\n#endif\n\nstatic size_t        page_size;\nstatic unsigned char canary[CANARY_SIZE];\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__((weak)) void\n_sodium_memzero_as_a_weak_symbol_to_prevent_lto(void *const  pnt,\n                                                const size_t len)\n{\n    unsigned char *pnt_ = (unsigned char *) pnt;\n    size_t         i    = (size_t) 0U;\n\n    while (i < len) {\n        pnt_[i++] = 0U;\n    }\n}\n#endif\n\nvoid\nsodium_memzero(void *const pnt, const size_t len)\n{\n#ifdef _WIN32\n    SecureZeroMemory(pnt, len);\n#elif defined(HAVE_MEMSET_S)\n    if (len > 0U && memset_s(pnt, (rsize_t) len, 0, (rsize_t) len) != 0) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n#elif defined(HAVE_EXPLICIT_BZERO)\n    explicit_bzero(pnt, len);\n#elif HAVE_WEAK_SYMBOLS\n    _sodium_memzero_as_a_weak_symbol_to_prevent_lto(pnt, len);\n#else\n    volatile unsigned char *volatile pnt_ =\n        (volatile unsigned char *volatile) pnt;\n    size_t i = (size_t) 0U;\n\n    while (i < len) {\n        pnt_[i++] = 0U;\n    }\n#endif\n}\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__((weak)) void\n_sodium_dummy_symbol_to_prevent_memcmp_lto(const unsigned char *b1,\n                                           const unsigned char *b2,\n                                           const size_t         len)\n{\n    (void) b1;\n    (void) b2;\n    (void) len;\n}\n#endif\n\nint\nsodium_memcmp(const void *const b1_, const void *const b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = (const unsigned char *) b1_;\n    const unsigned char *b2 = (const unsigned char *) b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char *volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char *volatile) b2_;\n#endif\n    size_t        i;\n    unsigned char d = (unsigned char) 0U;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_memcmp_lto(b1, b2, len);\n#endif\n    for (i = 0U; i < len; i++) {\n        d |= b1[i] ^ b2[i];\n    }\n    return (1 & ((d - 1) >> 8)) - 1;\n}\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__((weak)) void\n_sodium_dummy_symbol_to_prevent_compare_lto(const unsigned char *b1,\n                                            const unsigned char *b2,\n                                            const size_t         len)\n{\n    (void) b1;\n    (void) b2;\n    (void) len;\n}\n#endif\n\nint\nsodium_compare(const unsigned char *b1_, const unsigned char *b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = b1_;\n    const unsigned char *b2 = b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char *volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char *volatile) b2_;\n#endif\n    unsigned char gt = 0U;\n    unsigned char eq = 1U;\n    size_t        i;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_compare_lto(b1, b2, len);\n#endif\n    i = len;\n    while (i != 0U) {\n        i--;\n        gt |= ((b2[i] - b1[i]) >> 8) & eq;\n        eq &= ((b2[i] ^ b1[i]) - 1) >> 8;\n    }\n    return (int) (gt + gt + eq) - 1;\n}\n\nint\nsodium_is_zero(const unsigned char *n, const size_t nlen)\n{\n    size_t        i;\n    unsigned char d = 0U;\n\n    for (i = 0U; i < nlen; i++) {\n        d |= n[i];\n    }\n    return 1 & ((d - 1) >> 8);\n}\n\nvoid\nsodium_increment(unsigned char *n, const size_t nlen)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 1U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64, t64_2;\n    uint32_t t32;\n\n    if (nlen == 12U) {\n        __asm__ __volatile__(\n            \"xorq %[t64], %[t64] \\n\"\n            \"xorl %[t32], %[t32] \\n\"\n            \"stc \\n\"\n            \"adcq %[t64], (%[out]) \\n\"\n            \"adcl %[t32], 8(%[out]) \\n\"\n            : [t64] \"=&r\"(t64), [t32] \"=&r\"(t32)\n            : [out] \"D\"(n)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 24U) {\n        __asm__ __volatile__(\n            \"movq $1, %[t64] \\n\"\n            \"xorq %[t64_2], %[t64_2] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcq %[t64_2], 8(%[out]) \\n\"\n            \"adcq %[t64_2], 16(%[out]) \\n\"\n            : [t64] \"=&r\"(t64), [t64_2] \"=&r\"(t64_2)\n            : [out] \"D\"(n)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 8U) {\n        __asm__ __volatile__(\"incq (%[out]) \\n\"\n                             :\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i < nlen; i++) {\n        c += (uint_fast16_t) n[i];\n        n[i] = (unsigned char) c;\n        c >>= 8;\n    }\n}\n\nvoid\nsodium_add(unsigned char *a, const unsigned char *b, const size_t len)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 0U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64, t64_2, t64_3;\n    uint32_t t32;\n\n    if (len == 12U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"movl 8(%[in]), %[t32] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcl %[t32], 8(%[out]) \\n\"\n            : [t64] \"=&r\"(t64), [t32] \"=&r\"(t32)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 24U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"movq 8(%[in]), %[t64_2] \\n\"\n            \"movq 16(%[in]), %[t64_3] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcq %[t64_2], 8(%[out]) \\n\"\n            \"adcq %[t64_3], 16(%[out]) \\n\"\n            : [t64] \"=&r\"(t64), [t64_2] \"=&r\"(t64_2), [t64_3] \"=&r\"(t64_3)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 8U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            : [t64] \"=&r\"(t64)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i < len; i++) {\n        c += (uint_fast16_t) a[i] + (uint_fast16_t) b[i];\n        a[i] = (unsigned char) c;\n        c >>= 8;\n    }\n}\n\n/* Derived from original code by CodesInChaos */\nchar *\nsodium_bin2hex(char *const hex, const size_t hex_maxlen,\n               const unsigned char *const bin, const size_t bin_len)\n{\n    size_t       i = (size_t) 0U;\n    unsigned int x;\n    int          b;\n    int          c;\n\n    if (bin_len >= SIZE_MAX / 2 || hex_maxlen <= bin_len * 2U) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    while (i < bin_len) {\n        c = bin[i] & 0xf;\n        b = bin[i] >> 4;\n        x = (unsigned char) (87U + c + (((c - 10U) >> 8) & ~38U)) << 8 |\n            (unsigned char) (87U + b + (((b - 10U) >> 8) & ~38U));\n        hex[i * 2U] = (char) x;\n        x >>= 8;\n        hex[i * 2U + 1U] = (char) x;\n        i++;\n    }\n    hex[i * 2U] = 0U;\n\n    return hex;\n}\n\nint\nsodium_hex2bin(unsigned char *const bin, const size_t bin_maxlen,\n               const char *const hex, const size_t hex_len,\n               const char *const ignore, size_t *const bin_len,\n               const char **const hex_end)\n{\n    size_t        bin_pos = (size_t) 0U;\n    size_t        hex_pos = (size_t) 0U;\n    int           ret     = 0;\n    unsigned char c;\n    unsigned char c_acc = 0U;\n    unsigned char c_alpha0, c_alpha;\n    unsigned char c_num0, c_num;\n    unsigned char c_val;\n    unsigned char state = 0U;\n\n    while (hex_pos < hex_len) {\n        c        = (unsigned char) hex[hex_pos];\n        c_num    = c ^ 48U;\n        c_num0   = (c_num - 10U) >> 8;\n        c_alpha  = (c & ~32U) - 55U;\n        c_alpha0 = ((c_alpha - 10U) ^ (c_alpha - 16U)) >> 8;\n        if ((c_num0 | c_alpha0) == 0U) {\n            if (ignore != NULL && state == 0U && strchr(ignore, c) != NULL) {\n                hex_pos++;\n                continue;\n            }\n            break;\n        }\n        c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);\n        if (bin_pos >= bin_maxlen) {\n            ret   = -1;\n            errno = ERANGE;\n            break;\n        }\n        if (state == 0U) {\n            c_acc = c_val * 16U;\n        } else {\n            bin[bin_pos++] = c_acc | c_val;\n        }\n        state = ~state;\n        hex_pos++;\n    }\n    if (state != 0U) {\n        hex_pos--;\n    }\n    if (hex_end != NULL) {\n        *hex_end = &hex[hex_pos];\n    }\n    if (bin_len != NULL) {\n        *bin_len = bin_pos;\n    }\n    return ret;\n}\n\nint\n_sodium_alloc_init(void)\n{\n#ifdef HAVE_ALIGNED_MALLOC\n# if defined(_SC_PAGESIZE)\n    long page_size_ = sysconf(_SC_PAGESIZE);\n    if (page_size_ > 0L) {\n        page_size = (size_t) page_size_;\n    }\n# elif defined(WINAPI_DESKTOP)\n    SYSTEM_INFO si;\n    GetSystemInfo(&si);\n    page_size = (size_t) si.dwPageSize;\n# endif\n    if (page_size < CANARY_SIZE || page_size < sizeof(size_t)) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n#endif\n    randombytes_buf(canary, sizeof canary);\n\n    return 0;\n}\n\nint\nsodium_mlock(void *const addr, const size_t len)\n{\n#if defined(MADV_DONTDUMP) && defined(HAVE_MADVISE)\n    (void) madvise(addr, len, MADV_DONTDUMP);\n#endif\n#ifdef HAVE_MLOCK\n    return mlock(addr, len);\n#elif defined(WINAPI_DESKTOP)\n    return -(VirtualLock(addr, len) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nint\nsodium_munlock(void *const addr, const size_t len)\n{\n    sodium_memzero(addr, len);\n#if defined(MADV_DODUMP) && defined(HAVE_MADVISE)\n    (void) madvise(addr, len, MADV_DODUMP);\n#endif\n#ifdef HAVE_MLOCK\n    return munlock(addr, len);\n#elif defined(WINAPI_DESKTOP)\n    return -(VirtualUnlock(addr, len) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_noaccess(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_NONE);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_NOACCESS, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_readonly(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_READ);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_READONLY, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_readwrite(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_READ | PROT_WRITE);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_READWRITE, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\n#ifdef HAVE_ALIGNED_MALLOC\n\n__attribute__((noreturn)) static void\n_out_of_bounds(void)\n{\n# ifdef SIGSEGV\n    raise(SIGSEGV);\n# elif defined(SIGKILL)\n    raise(SIGKILL);\n# endif\n    abort();\n} /* LCOV_EXCL_LINE */\n\nstatic inline size_t\n_page_round(const size_t size)\n{\n    const size_t page_mask = page_size - 1U;\n\n    return (size + page_mask) & ~page_mask;\n}\n\nstatic __attribute__((malloc)) unsigned char *\n_alloc_aligned(const size_t size)\n{\n    void *ptr;\n\n# if defined(MAP_ANON) && defined(HAVE_MMAP)\n    if ((ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,\n                    MAP_ANON | MAP_PRIVATE | MAP_NOCORE, -1, 0)) ==\n        MAP_FAILED) {\n        ptr = NULL; /* LCOV_EXCL_LINE */\n    }               /* LCOV_EXCL_LINE */\n# elif defined(HAVE_POSIX_MEMALIGN)\n    if (posix_memalign(&ptr, page_size, size) != 0) {\n        ptr = NULL; /* LCOV_EXCL_LINE */\n    }               /* LCOV_EXCL_LINE */\n# elif defined(WINAPI_DESKTOP)\n    ptr = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n# else\n#  error Bug\n# endif\n    return (unsigned char *) ptr;\n}\n\nstatic void\n_free_aligned(unsigned char *const ptr, const size_t size)\n{\n# if defined(MAP_ANON) && defined(HAVE_MMAP)\n    (void) munmap(ptr, size);\n# elif defined(HAVE_POSIX_MEMALIGN)\n    free(ptr);\n# elif defined(WINAPI_DESKTOP)\n    VirtualFree(ptr, 0U, MEM_RELEASE);\n# else\n#  error Bug\n#endif\n}\n\nstatic unsigned char *\n_unprotected_ptr_from_user_ptr(void *const ptr)\n{\n    uintptr_t      unprotected_ptr_u;\n    unsigned char *canary_ptr;\n    size_t         page_mask;\n\n    canary_ptr = ((unsigned char *) ptr) - sizeof canary;\n    page_mask = page_size - 1U;\n    unprotected_ptr_u = ((uintptr_t) canary_ptr & (uintptr_t) ~page_mask);\n    if (unprotected_ptr_u <= page_size * 2U) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    return (unsigned char *) unprotected_ptr_u;\n}\n\n#endif /* HAVE_ALIGNED_MALLOC */\n\n#ifndef HAVE_ALIGNED_MALLOC\nstatic __attribute__((malloc)) void *\n_sodium_malloc(const size_t size)\n{\n    return malloc(size > (size_t) 0U ? size : (size_t) 1U);\n}\n#else\nstatic __attribute__((malloc)) void *\n_sodium_malloc(const size_t size)\n{\n    void          *user_ptr;\n    unsigned char *base_ptr;\n    unsigned char *canary_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         size_with_canary;\n    size_t         total_size;\n    size_t         unprotected_size;\n\n    if (size >= (size_t) SIZE_MAX - page_size * 4U) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    if (page_size <= sizeof canary || page_size < sizeof unprotected_size) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    size_with_canary = (sizeof canary) + size;\n    unprotected_size = _page_round(size_with_canary);\n    total_size       = page_size + page_size + unprotected_size + page_size;\n    if ((base_ptr = _alloc_aligned(total_size)) == NULL) {\n        return NULL; /* LCOV_EXCL_LINE */\n    }\n    unprotected_ptr = base_ptr + page_size * 2U;\n    _mprotect_noaccess(base_ptr + page_size, page_size);\n# ifndef HAVE_PAGE_PROTECTION\n    memcpy(unprotected_ptr + unprotected_size, canary, sizeof canary);\n# endif\n    _mprotect_noaccess(unprotected_ptr + unprotected_size, page_size);\n    sodium_mlock(unprotected_ptr, unprotected_size);\n    canary_ptr =\n        unprotected_ptr + _page_round(size_with_canary) - size_with_canary;\n    user_ptr = canary_ptr + sizeof canary;\n    memcpy(canary_ptr, canary, sizeof canary);\n    memcpy(base_ptr, &unprotected_size, sizeof unprotected_size);\n    _mprotect_readonly(base_ptr, page_size);\n    assert(_unprotected_ptr_from_user_ptr(user_ptr) == unprotected_ptr);\n\n    return user_ptr;\n}\n#endif /* !HAVE_ALIGNED_MALLOC */\n\n__attribute__((malloc)) void *\nsodium_malloc(const size_t size)\n{\n    void *ptr;\n\n    if ((ptr = _sodium_malloc(size)) == NULL) {\n        return NULL;\n    }\n    memset(ptr, (int) GARBAGE_VALUE, size);\n\n    return ptr;\n}\n\n__attribute__((malloc)) void *\nsodium_allocarray(size_t count, size_t size)\n{\n    size_t total_size;\n\n    if (count > (size_t) 0U && size >= (size_t) SIZE_MAX / count) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    total_size = count * size;\n\n    return sodium_malloc(total_size);\n}\n\n#ifndef HAVE_ALIGNED_MALLOC\nvoid\nsodium_free(void *ptr)\n{\n    free(ptr);\n}\n#else\nvoid\nsodium_free(void *ptr)\n{\n    unsigned char *base_ptr;\n    unsigned char *canary_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         total_size;\n    size_t         unprotected_size;\n\n    if (ptr == NULL) {\n        return;\n    }\n    canary_ptr      = ((unsigned char *) ptr) - sizeof canary;\n    unprotected_ptr = _unprotected_ptr_from_user_ptr(ptr);\n    base_ptr        = unprotected_ptr - page_size * 2U;\n    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);\n    total_size = page_size + page_size + unprotected_size + page_size;\n    _mprotect_readwrite(base_ptr, total_size);\n    if (sodium_memcmp(canary_ptr, canary, sizeof canary) != 0) {\n        _out_of_bounds();\n    }\n# ifndef HAVE_PAGE_PROTECTION\n    if (sodium_memcmp(unprotected_ptr + unprotected_size, canary,\n                      sizeof canary) != 0) {\n        _out_of_bounds();\n    }\n# endif\n    sodium_munlock(unprotected_ptr, unprotected_size);\n    _free_aligned(base_ptr, total_size);\n}\n#endif /* HAVE_ALIGNED_MALLOC */\n\n#ifndef HAVE_PAGE_PROTECTION\nstatic int\n_sodium_mprotect(void *ptr, int (*cb)(void *ptr, size_t size))\n{\n    (void) ptr;\n    (void) cb;\n    errno = ENOSYS;\n    return -1;\n}\n#else\nstatic int\n_sodium_mprotect(void *ptr, int (*cb)(void *ptr, size_t size))\n{\n    unsigned char *base_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         unprotected_size;\n\n    unprotected_ptr = _unprotected_ptr_from_user_ptr(ptr);\n    base_ptr        = unprotected_ptr - page_size * 2U;\n    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);\n\n    return cb(unprotected_ptr, unprotected_size);\n}\n#endif\n\nint\nsodium_mprotect_noaccess(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_noaccess);\n}\n\nint\nsodium_mprotect_readonly(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_readonly);\n}\n\nint\nsodium_mprotect_readwrite(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_readwrite);\n}\n","\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <sys/types.h>\n\n#ifdef __EMSCRIPTEN__\n# include <emscripten.h>\n#endif\n\n#include \"crypto_stream_chacha20.h\"\n#include \"randombytes.h\"\n#ifdef RANDOMBYTES_DEFAULT_IMPLEMENTATION\n# include \"randombytes_default.h\"\n#else\n# ifdef __native_client__\n#  include \"randombytes_nativeclient.h\"\n# else\n#  include \"randombytes_sysrandom.h\"\n# endif\n#endif\n#include \"private/common.h\"\n\n/* C++Builder defines a \"random\" macro */\n#undef random\n\nstatic const randombytes_implementation *implementation;\n\n#ifndef RANDOMBYTES_DEFAULT_IMPLEMENTATION\n# ifdef __EMSCRIPTEN__\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION NULL\n# else\n#  ifdef __native_client__\n#   define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_nativeclient_implementation;\n#  else\n#   define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_sysrandom_implementation;\n#  endif\n# endif\n#endif\n\nstatic void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}\n\nint\nrandombytes_set_implementation(randombytes_implementation *impl)\n{\n    implementation = impl;\n\n    return 0;\n}\n\nconst char *\nrandombytes_implementation_name(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->implementation_name();\n#else\n    return \"js\";\n#endif\n}\n\nuint32_t\nrandombytes_random(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->random();\n#else\n    return EM_ASM_INT_V({\n        return Module.getRandomValue();\n    });\n#endif\n}\n\nvoid\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->stir != NULL) {\n        implementation->stir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = \"object\" === typeof window ? window : self,\n                    crypto_ = typeof window_.crypto !== \"undefined\" ? window_.crypto : window_.msCrypto,\n                    randomValuesStandard = function() {\n                        var buf = new Uint32Array(1);\n                        crypto_.getRandomValues(buf);\n                        return buf[0] >>> 0;\n                    };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto'),\n                        randomValueNodeJS = function() {\n                            var buf = crypto.randomBytes(4);\n                            return (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) >>> 0;\n                        };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }\n    });\n#endif\n}\n\nuint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->uniform != NULL) {\n        return implementation->uniform(upper_bound);\n    }\n#endif\n    if (upper_bound < 2) {\n        return 0;\n    }\n    min = (1U + ~upper_bound) % upper_bound;\n    do {\n        r = randombytes_random();\n    } while (r < min);\n\n    return r % upper_bound;\n}\n\nvoid\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size > (size_t) 0U) {\n        implementation->buf(buf, size);\n    }\n#else\n    unsigned char *p = (unsigned char *) buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i < size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}\n\nvoid\nrandombytes_buf_deterministic(void * const buf, const size_t size,\n                              const unsigned char seed[randombytes_SEEDBYTES])\n{\n    static const unsigned char nonce[crypto_stream_chacha20_ietf_NONCEBYTES] = {\n        'L', 'i', 'b', 's', 'o', 'd', 'i', 'u', 'm', 'D', 'R', 'G'\n    };\n\n    COMPILER_ASSERT(randombytes_SEEDBYTES == crypto_stream_chacha20_ietf_KEYBYTES);\n#if SIZE_MAX > 0x4000000000ULL\n    if (size > 0x4000000000ULL) {\n        abort();\n    }\n#endif\n    crypto_stream_chacha20_ietf((unsigned char *) buf, (unsigned long long) size,\n                                nonce, seed);\n}\n\nsize_t\nrandombytes_seedbytes(void)\n{\n    return randombytes_SEEDBYTES;\n}\n\nint\nrandombytes_close(void)\n{\n    if (implementation != NULL && implementation->close != NULL) {\n        return implementation->close();\n    }\n    return 0;\n}\n\nvoid\nrandombytes(unsigned char * const buf, const unsigned long long buf_len)\n{\n    assert(buf_len <= SIZE_MAX);\n    randombytes_buf(buf, (size_t) buf_len);\n}\n","#include <stdlib.h>\n/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for ephemeral \r\n*       Diffie-Hellman key exchange.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: functions for initialization and getting randomness\r\n*\r\n*********************************************************************************************/ \r\n\r\n#include \"SIDH_internal.h\"\r\n#include <malloc.h>\r\n\r\n\r\nCRYPTO_STATUS SIDH_curve_initialize(PCurveIsogenyStruct pCurveIsogeny, RandomBytes RandomBytesFunction, PCurveIsogenyStaticData pCurveIsogenyData)\r\n{ // Initialize curve isogeny structure pCurveIsogeny with static data extracted from pCurveIsogenyData.\r\n  // This needs to be called after allocating memory for \"pCurveIsogeny\" using SIDH_curve_allocate().\r\n    unsigned int i, pwords, owords;\r\n\r\n    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    for (i = 0; i < 8; i++) {    // Copy 8-character identifier\r\n        pCurveIsogeny->CurveIsogeny[i] = pCurveIsogenyData->CurveIsogeny[i];\r\n    }\r\n    pCurveIsogeny->pwordbits = pCurveIsogenyData->pwordbits;\r\n    pCurveIsogeny->owordbits = pCurveIsogenyData->owordbits;\r\n    pCurveIsogeny->pbits = pCurveIsogenyData->pbits;\r\n    pCurveIsogeny->oAbits = pCurveIsogenyData->oAbits;\r\n    pCurveIsogeny->oBbits = pCurveIsogenyData->oBbits;\r\n    pCurveIsogeny->eB = pCurveIsogenyData->eB;\r\n    pCurveIsogeny->BigMont_A24 = pCurveIsogenyData->BigMont_A24;\r\n    pCurveIsogeny->RandomBytesFunction = RandomBytesFunction;\r\n\r\n    pwords = (pCurveIsogeny->pwordbits + RADIX - 1)/RADIX;\r\n    owords = (pCurveIsogeny->owordbits + RADIX - 1)/RADIX;\r\n    copy_words((digit_t*)pCurveIsogenyData->prime, pCurveIsogeny->prime, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->A, pCurveIsogeny->A, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->C, pCurveIsogeny->C, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Aorder, pCurveIsogeny->Aorder, owords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Border, pCurveIsogeny->Border, owords);\r\n    copy_words((digit_t*)pCurveIsogenyData->PA, pCurveIsogeny->PA, 2*pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->PB, pCurveIsogeny->PB, 2*pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->BigMont_order, pCurveIsogeny->BigMont_order, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Montgomery_R2, pCurveIsogeny->Montgomery_R2, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Montgomery_pp, pCurveIsogeny->Montgomery_pp, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Montgomery_one, pCurveIsogeny->Montgomery_one, pwords);\r\n    \r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nPCurveIsogenyStruct SIDH_curve_allocate(PCurveIsogenyStaticData CurveData)\r\n{ // Dynamic allocation of memory for curve isogeny structure.\r\n  // Returns NULL on error.\r\n    digit_t pbytes = (CurveData->pwordbits + 7)/8;\r\n    digit_t obytes = (CurveData->owordbits + 7)/8;\r\n    PCurveIsogenyStruct pCurveIsogeny = NULL;\r\n\r\n    pCurveIsogeny = (PCurveIsogenyStruct)calloc(1, sizeof(CurveIsogenyStruct));\r\n    pCurveIsogeny->prime = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->A = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->C = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Aorder = (digit_t*)calloc(1, obytes);\r\n    pCurveIsogeny->Border = (digit_t*)calloc(1, obytes);\r\n    pCurveIsogeny->PA = (digit_t*)calloc(1, 2*pbytes);\r\n    pCurveIsogeny->PB = (digit_t*)calloc(1, 2*pbytes);\r\n    pCurveIsogeny->BigMont_order = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Montgomery_R2 = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Montgomery_pp = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Montgomery_one = (digit_t*)calloc(1, pbytes);\r\n\r\n    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {\r\n        return NULL;\r\n    }\r\n    return pCurveIsogeny;\r\n}\r\n\r\n\r\nvoid SIDH_curve_free(PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Free memory for curve isogeny structure\r\n\r\n    if (pCurveIsogeny != NULL)\r\n    {\r\n        if (pCurveIsogeny->prime != NULL) \r\n            free(pCurveIsogeny->prime);\r\n        if (pCurveIsogeny->A != NULL) \r\n            free(pCurveIsogeny->A);\r\n        if (pCurveIsogeny->C != NULL) \r\n            free(pCurveIsogeny->C);\r\n        if (pCurveIsogeny->Aorder != NULL) \r\n            free(pCurveIsogeny->Aorder);\r\n        if (pCurveIsogeny->Border != NULL) \r\n            free(pCurveIsogeny->Border);\r\n        if (pCurveIsogeny->PA != NULL) \r\n            free(pCurveIsogeny->PA);\r\n        if (pCurveIsogeny->PB != NULL) \r\n            free(pCurveIsogeny->PB);\r\n        if (pCurveIsogeny->BigMont_order != NULL) \r\n            free(pCurveIsogeny->BigMont_order);\r\n        if (pCurveIsogeny->Montgomery_R2 != NULL) \r\n             free(pCurveIsogeny->Montgomery_R2);\r\n        if (pCurveIsogeny->Montgomery_pp != NULL) \r\n             free(pCurveIsogeny->Montgomery_pp);\r\n        if (pCurveIsogeny->Montgomery_one != NULL) \r\n             free(pCurveIsogeny->Montgomery_one);\r\n\r\n        free(pCurveIsogeny);\r\n    }\r\n}\r\n\r\n\r\nbool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Check if curve isogeny structure is NULL\r\n\r\n    if (pCurveIsogeny == NULL || pCurveIsogeny->prime == NULL || pCurveIsogeny->A == NULL || pCurveIsogeny->C == NULL || pCurveIsogeny->Aorder == NULL || pCurveIsogeny->Border == NULL || \r\n        pCurveIsogeny->PA == NULL || pCurveIsogeny->PB == NULL || pCurveIsogeny->BigMont_order == NULL || pCurveIsogeny->Montgomery_R2 == NULL || pCurveIsogeny->Montgomery_pp == NULL || \r\n        pCurveIsogeny->Montgomery_one == NULL)\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nconst char* SIDH_get_error_message(CRYPTO_STATUS Status)\r\n{ // Output error/success message for a given CRYPTO_STATUS\r\n    struct error_mapping {\r\n        unsigned int index;\r\n        char*        string;\r\n    } mapping[CRYPTO_STATUS_TYPE_SIZE] = {\r\n        {CRYPTO_SUCCESS, CRYPTO_MSG_SUCCESS},\r\n        {CRYPTO_ERROR, CRYPTO_MSG_ERROR},\r\n        {CRYPTO_ERROR_DURING_TEST, CRYPTO_MSG_ERROR_DURING_TEST},\r\n        {CRYPTO_ERROR_UNKNOWN, CRYPTO_MSG_ERROR_UNKNOWN},\r\n        {CRYPTO_ERROR_NOT_IMPLEMENTED, CRYPTO_MSG_ERROR_NOT_IMPLEMENTED},\r\n        {CRYPTO_ERROR_NO_MEMORY, CRYPTO_MSG_ERROR_NO_MEMORY},\r\n        {CRYPTO_ERROR_INVALID_PARAMETER, CRYPTO_MSG_ERROR_INVALID_PARAMETER},\r\n        {CRYPTO_ERROR_SHARED_KEY, CRYPTO_MSG_ERROR_SHARED_KEY},\r\n        {CRYPTO_ERROR_PUBLIC_KEY_VALIDATION, CRYPTO_MSG_ERROR_PUBLIC_KEY_VALIDATION},\r\n        {CRYPTO_ERROR_TOO_MANY_ITERATIONS, CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS}\r\n    };\r\n\r\n    if (Status >= CRYPTO_STATUS_TYPE_SIZE || mapping[Status].string == NULL) {\r\n        return \"Unrecognized CRYPTO_STATUS\";\r\n    } else {\r\n        return mapping[Status].string;\r\n    }\r\n};\r\n\r\n\r\nconst uint64_t Border_div3[NWORDS_ORDER] = { 0xEDCD718A828384F9, 0x733B35BFD4427A14, 0xF88229CF94D7CF38, 0x63C56C990C7C2AD6, 0xB858A87E8F4222C7, 0x254C9C6B525EAF5 }; \r\n\r\n\r\nCRYPTO_STATUS random_mod_order(digit_t* random_digits, unsigned int AliceOrBob, PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Output random values in the range [1, order-1] in little endian format that can be used as private keys.\r\n  // It makes requests of random values with length \"oAbits\" (when AliceOrBob = 0) or \"oBbits\" (when AliceOrBob = 1) to the \"random_bytes\" function. \r\n  // The process repeats until random value is in [0, Aorder-2]  ([0, Border-2], resp.). \r\n  // If successful, the output is given in \"random_digits\" in the range [1, Aorder-1] ([1, Border-1], resp.).\r\n  // The \"random_bytes\" function, which is passed through the curve isogeny structure PCurveIsogeny, should be set up in advance using SIDH_curve_initialize().\r\n  // The caller is responsible of providing the \"random_bytes\" function passing random values as octets.\r\n    unsigned int ntry = 0, nbytes, nwords;    \r\n    digit_t t1[MAXWORDS_ORDER] = {0}, order2[MAXWORDS_ORDER] = {0};\r\n    unsigned char mask;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny) || AliceOrBob > 1) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    clear_words((void*)random_digits, MAXWORDS_ORDER);     \r\n    t1[0] = 2;\r\n    if (AliceOrBob == ALICE) {\r\n        nbytes = (pCurveIsogeny->oAbits+7)/8;                  // Number of random bytes to be requested \r\n        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oAbits);\r\n        mask = 0x07;                                           // Value for masking last random byte\r\n        copy_words(pCurveIsogeny->Aorder, order2, nwords);\r\n        mp_shiftr1(order2, nwords);                            // order/2\r\n        mp_sub(order2, t1, order2, nwords);                    // order2 = order/2-2\r\n    } else {\r\n        nbytes = (pCurveIsogeny->oBbits+7)/8;                    \r\n        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oBbits);\r\n        mask = 0x03;                                           // Value for masking last random byte\r\n        mp_sub((digit_t*)Border_div3, t1, order2, nwords);     // order2 = order/3-2\r\n    }\r\n\r\n    do {\r\n        ntry++;\r\n        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] \r\n            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;\r\n        }\r\n        Status = (pCurveIsogeny->RandomBytesFunction)(nbytes, (unsigned char*)random_digits);\r\n        if (Status != CRYPTO_SUCCESS) {\r\n            return Status;\r\n        }\r\n        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte \r\n    } while (mp_sub(order2, random_digits, t1, nwords) == 1);\r\n    \r\n    clear_words((void*)t1, MAXWORDS_ORDER);  \r\n    t1[0] = 1;\r\n    mp_add(random_digits, t1, random_digits, nwords);          \r\n    copy_words(random_digits, t1, nwords);\r\n    mp_shiftl1(random_digits, nwords);                         // Alice's output in the range [2, order-2]\r\n    if (AliceOrBob == BOB) {\r\n        mp_add(random_digits, t1, random_digits, nwords);      // Bob's output in the range [3, order-3]\r\n    }\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS random_BigMont_mod_order(digit_t* random_digits, PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Output random values in the range [1, BigMont_order-1] in little endian format that can be used as private keys to compute scalar multiplications \r\n  // using the elliptic curve BigMont.\r\n  // It makes requests of random values with length \"BIGMONT_NBITS_ORDER\" to the \"random_bytes\" function. \r\n  // The process repeats until random value is in [0, BigMont_order-2] \r\n  // If successful, the output is given in \"random_digits\" in the range [1, BigMont_order-1].\r\n  // The \"random_bytes\" function, which is passed through the curve isogeny structure PCurveIsogeny, should be set up in advance using SIDH_curve_initialize().\r\n  // The caller is responsible of providing the \"random_bytes\" function passing random values as octets.\r\n    unsigned int ntry = 0, nbytes = (BIGMONT_NBITS_ORDER+7)/8, nwords = NBITS_TO_NWORDS(BIGMONT_NBITS_ORDER);    \r\n    digit_t t1[BIGMONT_MAXWORDS_ORDER] = {0}, order2[BIGMONT_MAXWORDS_ORDER] = {0};\r\n    unsigned char mask;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    clear_words((void*)random_digits, BIGMONT_MAXWORDS_ORDER);     \r\n    t1[0] = 2;\r\n    mask = (unsigned char)(8*nbytes - BIGMONT_NBITS_ORDER);\r\n    mp_sub(pCurveIsogeny->BigMont_order, t1, order2, nwords);  // order2 = order-2\r\n    mask = ((unsigned char)-1 >> mask);                        // Value for masking last random byte\r\n\r\n    do {\r\n        ntry++;\r\n        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] \r\n            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;\r\n        }\r\n        Status = (pCurveIsogeny->RandomBytesFunction)(nbytes, (unsigned char*)random_digits);\r\n        if (Status != CRYPTO_SUCCESS) {\r\n            return Status;\r\n        }\r\n        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte \r\n    } while (mp_sub(order2, random_digits, t1, nwords) == 1);\r\n    \r\n    clear_words((void*)t1, BIGMONT_MAXWORDS_ORDER);  \r\n    t1[0] = 1;\r\n    mp_add(random_digits, t1, random_digits, nwords);          // Output in the range [1, order-1]\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nvoid clear_words(void* mem, digit_t nwords)\r\n{ // Clear digits from memory. \"nwords\" indicates the number of digits to be zeroed.\r\n  // This function uses the volatile type qualifier to inform the compiler not to optimize out the memory clearing.\r\n    unsigned int i;\r\n    volatile digit_t *v = mem; \r\n\r\n    for (i = 0; i < nwords; i++) {\r\n        v[i] = 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman \r\n*       key exchange.\n*\n*    Copyright (c) Microsoft Corporation. All rights reserved.\n*\n*\n* Abstract: elliptic curve and isogeny functions\n*\n*********************************************************************************************/ \n\n#include \"SIDH_internal.h\"\n#include <math.h>\n\nextern const uint64_t LIST[22][NWORDS64_FIELD];\n\n\nvoid j_inv(const f2elm_t A, const f2elm_t C, f2elm_t jinv)\n{ // Computes the j-invariant of a Montgomery curve with projective constant.\n  // Input: A,C in GF(p^2).\n  // Output: j=256*(A^2-3*C^2)^3/(C^4*(A^2-4*C^2)), which is the j-invariant of the Montgomery curve B*y^2=x^3+(A/C)*x^2+x or (equivalently) j-invariant of B'*y^2=C*x^3+A*x^2+C*x.\n    f2elm_t t0, t1;\n    \n    fp2sqr751_mont(A, jinv);                           // jinv = A^2        \n    fp2sqr751_mont(C, t1);                             // t1 = C^2\n    fp2add751(t1, t1, t0);                             // t0 = t1+t1\n    fp2sub751(jinv, t0, t0);                           // t0 = jinv-t0\n    fp2sub751(t0, t1, t0);                             // t0 = t0-t1\n    fp2sub751(t0, t1, jinv);                           // jinv = t0-t1\n    fp2sqr751_mont(t1, t1);                            // t1 = t1^2\n    fp2mul751_mont(jinv, t1, jinv);                    // jinv = jinv*t1\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\n    fp2sqr751_mont(t0, t1);                            // t1 = t0^2\n    fp2mul751_mont(t0, t1, t0);                        // t0 = t0*t1\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\n    fp2inv751_mont(jinv);                              // jinv = 1/jinv \n    fp2mul751_mont(jinv, t0, jinv);                    // jinv = t0*jinv\n}\n\n\nvoid xDBLADD(point_proj_t P, point_proj_t Q, const f2elm_t xPQ, const f2elm_t A24)\n{ // Simultaneous doubling and differential addition.\n  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.\n  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. \n    f2elm_t t0, t1, t2;\n\n    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP\n    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP\n    fp2sqr751_mont(t0, P->X);                          // XP = (XP+ZP)^2\n    fp2sub751(Q->X, Q->Z, t2);                         // t2 = XQ-ZQ\n    fp2add751(Q->X, Q->Z, Q->X);                       // XQ = XQ+ZQ\n    fp2mul751_mont(t0, t2, t0);                        // t0 = (XP+ZP)*(XQ-ZQ)\n    fp2sqr751_mont(t1, P->Z);                          // ZP = (XP-ZP)^2\n    fp2mul751_mont(t1, Q->X, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)\n    fp2sub751(P->X, P->Z, t2);                         // t2 = (XP+ZP)^2-(XP-ZP)^2\n    fp2mul751_mont(P->X, P->Z, P->X);                  // XP = (XP+ZP)^2*(XP-ZP)^2\n    fp2mul751_mont(t2, A24, Q->X);                     // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]\n    fp2sub751(t0, t1, Q->Z);                           // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)\n    fp2add751(Q->X, P->Z, P->Z);                       // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2\n    fp2add751(t0, t1, Q->X);                           // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)\n    fp2mul751_mont(P->Z, t2, P->Z);                    // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]\n    fp2sqr751_mont(Q->Z, Q->Z);                        // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\n    fp2sqr751_mont(Q->X, Q->X);                        // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2\n    fp2mul751_mont(Q->Z, xPQ, Q->Z);                   // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\n}\n\n\nvoid xDBL(const point_proj_t P, point_proj_t Q, const f2elm_t A24, const f2elm_t C24)\n{ // Doubling of a Montgomery point in projective coordinates (X:Z).\n  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.\n  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).\n    f2elm_t t0, t1;\n    \n    fp2sub751(P->X, P->Z, t0);                         // t0 = X1-Z1\n    fp2add751(P->X, P->Z, t1);                         // t1 = X1+Z1\n    fp2sqr751_mont(t0, t0);                            // t0 = (X1-Z1)^2 \n    fp2sqr751_mont(t1, t1);                            // t1 = (X1+Z1)^2 \n    fp2mul751_mont(C24, t0, Q->Z);                     // Z2 = C24*(X1-Z1)^2   \n    fp2mul751_mont(t1, Q->Z, Q->X);                    // X2 = C24*(X1-Z1)^2*(X1+Z1)^2\n    fp2sub751(t1, t0, t1);                             // t1 = (X1+Z1)^2-(X1-Z1)^2 \n    fp2mul751_mont(A24, t1, t0);                       // t0 = A24*[(X1+Z1)^2-(X1-Z1)^2]\n    fp2add751(Q->Z, t0, Q->Z);                         // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2\n    fp2mul751_mont(Q->Z, t1, Q->Z);                    // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]\n}\n\n\nvoid xDBLe(const point_proj_t P, point_proj_t Q, const f2elm_t A, const f2elm_t C, const int e)\n{ // Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.\n  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.\n  // Output: projective Montgomery x-coordinates Q <- (2^e)*P.\n    f2elm_t A24num, A24den;\n    int i;\n    \n    fp2add751(C, C, A24num);                           \n    fp2add751(A24num, A24num, A24den);                    \n    fp2add751(A24num, A, A24num); \n    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);\n\n    for (i = 0; i < e; i++) {\n        xDBL(Q, Q, A24num, A24den);\n    }\n}\n\n\nvoid xADD(point_proj_t P, const point_proj_t Q, const f2elm_t xPQ)\n{ // Differential addition.\n  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, and affine difference xPQ=x(P-Q).\n  // Output: projective Montgomery point P <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. \n    f2elm_t t0, t1;\n    \n    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP\n    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP\n    fp2sub751(Q->X, Q->Z, P->X);                       // XP = XQ-ZQ\n    fp2add751(Q->X, Q->Z, P->Z);                       // ZP = XQ+ZQ\n    fp2mul751_mont(t0, P->X, t0);                      // t0 = (XP+ZP)*(XQ-ZQ)                           \n    fp2mul751_mont(t1, P->Z, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)\n    fp2sub751(t0, t1, P->Z);                           // ZP = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)\n    fp2add751(t0, t1, P->X);                           // XP = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)\n    fp2sqr751_mont(P->Z, P->Z);                        // ZP = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\n    fp2sqr751_mont(P->X, P->X);                        // XP = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2\n    fp2mul751_mont(P->Z, xPQ, P->Z);                   // ZP = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\n}\n\n\nvoid xDBL_basefield(const point_basefield_proj_t P, point_basefield_proj_t Q)\n{ // Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.\n  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.\n  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).\n    felm_t t0, t1;\n\n    // NOTE: this function is fixed for A24=1, C24=2\n    \n    fpsub751(P->X, P->Z, t0);                          // t0 = X1-Z1\n    fpadd751(P->X, P->Z, t1);                          // t1 = X1+Z1\n    fpsqr751_mont(t0, t0);                             // t0 = (X1-Z1)^2 \n    fpsqr751_mont(t1, t1);                             // t1 = (X1+Z1)^2   \n    fpadd751(t0, t0, Q->Z);                            // Z2 = C24*(X1-Z1)^2 \n    fpmul751_mont(t1, Q->Z, Q->X);                     // X2 = C24*(X1-Z1)^2*(X1+Z1)^2\n    fpsub751(t1, t0, t1);                              // t1 = (X1+Z1)^2-(X1-Z1)^2 \n    fpadd751(Q->Z, t1, Q->Z);                          // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2\n    fpmul751_mont(Q->Z, t1, Q->Z);                     // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]\n}\n\n\nvoid xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, const felm_t xPQ, const felm_t A24)\n{ // Simultaneous doubling and differential addition over the base field.\n  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.\n  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. \n    felm_t t0, t1, t2;\n\n    // NOTE: this function is fixed for C24=2\n\n    fpadd751(P->X, P->Z, t0);                          // t0 = XP+ZP\n    fpsub751(P->X, P->Z, t1);                          // t1 = XP-ZP\n    fpsqr751_mont(t0, P->X);                           // XP = (XP+ZP)^2\n    fpsub751(Q->X, Q->Z, t2);                          // t2 = XQ-ZQ\n    fpadd751(Q->X, Q->Z, Q->X);                        // XQ = XQ+ZQ\n    fpmul751_mont(t0, t2, t0);                         // t0 = (XP+ZP)*(XQ-ZQ)\n    fpsqr751_mont(t1, P->Z);                           // ZP = (XP-ZP)^2\n    fpmul751_mont(t1, Q->X, t1);                       // t1 = (XP-ZP)*(XQ+ZQ)\n    fpsub751(P->X, P->Z, t2);                          // t2 = (XP+ZP)^2-(XP-ZP)^2\n\n    if (A24[0] == 1) {\n        fpadd751(P->Z, P->Z, P->Z);                    // ZP = C24*(XP-ZP)^2\n        fpmul751_mont(P->X, P->Z, P->X);               // XP = C24*(XP+ZP)^2*(XP-ZP)^2\n        fpadd751(t2, P->Z, P->Z);                      // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2\n    } else {\n        fpmul751_mont(P->X, P->Z, P->X);               // XP = (XP+ZP)^2*(XP-ZP)^2\n        fpmul751_mont(A24, t2, Q->X);                  // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]\n        fpadd751(P->Z, Q->X, P->Z);                    // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2\n    }\n    \n    fpsub751(t0, t1, Q->Z);                            // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)\n    fpadd751(t0, t1, Q->X);                            // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)\n    fpmul751_mont(P->Z, t2, P->Z);                     // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]\n    fpsqr751_mont(Q->Z, Q->Z);                         // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\n    fpsqr751_mont(Q->X, Q->X);                         // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2\n    fpmul751_mont(Q->Z, xPQ, Q->Z);                    // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\n}\n\n\nvoid ladder(const felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, const felm_t A24, const unsigned int order_bits, const unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny)\n{ // The Montgomery ladder\n  // Inputs: the affine x-coordinate of a point P on E: B*y^2=x^3+A*x^2+x, \n  //         scalar m\n  //         curve constant A24 = (A+2)/4\n  //         order_bits = subgroup order bitlength\n  //         order_fullbits = smallest multiple of 32 larger than the order bitlength\n  // Output: Q = m*(x:1)\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\n    unsigned int bit = 0, owords = NBITS_TO_NWORDS(order_fullbits);\n    digit_t mask;\n    int i;\n\n    // Initializing with the points (1:0) and (x:1)\n    fpcopy751(CurveIsogeny->Montgomery_one, (digit_t*)P->X);\n    fpzero751(P->Z);\n    fpcopy751(x, Q->X);\n    fpcopy751(CurveIsogeny->Montgomery_one, (digit_t*)Q->Z);\n\n    for (i = order_fullbits-order_bits; i > 0; i--) {\n        mp_shiftl1(m, owords);\n    }\n    \n    for (i = order_bits; i > 0; i--) {\n        bit = (unsigned int)(m[owords-1] >> (RADIX-1));\n        mp_shiftl1(m, owords);\n        mask = 0-(digit_t)bit;\n\n        swap_points_basefield(P, Q, mask);\n        xDBLADD_basefield(P, Q, x, A24);           // If bit=0 then P <- 2*P and Q <- P+Q, \n        swap_points_basefield(P, Q, mask);         // else if bit=1 then Q <- 2*Q and P <- P+Q\n    }\n}\n\n\nCRYPTO_STATUS BigMont_ladder(unsigned char* x, digit_t* m, unsigned char* xout, PCurveIsogenyStruct CurveIsogeny)\n{ // BigMont's scalar multiplication using the Montgomery ladder\n  // Inputs: x, the affine x-coordinate of a point P on BigMont: y^2=x^3+A*x^2+x, \n  //         scalar m.\n  // Output: xout, the affine x-coordinate of m*(x:1)\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\n    point_basefield_proj_t P1, P2;\n    digit_t scalar[BIGMONT_NWORDS_ORDER];\n    felm_t X, A24 = {0};\n\n    A24[0] = (digit_t)CurveIsogeny->BigMont_A24; \n    to_mont(A24, A24);                               // Conversion to Montgomery representation\n    to_mont((digit_t*)x, X);\n    \n    copy_words(m, scalar, BIGMONT_NWORDS_ORDER);\n    ladder(X, scalar, P1, P2, A24, BIGMONT_NBITS_ORDER, BIGMONT_MAXBITS_ORDER, CurveIsogeny);\n\n    fpinv751_mont(P1->Z);\n    fpmul751_mont(P1->X, P1->Z, (digit_t*)xout);\n    from_mont((digit_t*)xout, (digit_t*)xout);       // Conversion to standard representation\n\n    return CRYPTO_SUCCESS;\n}\n\n\nCRYPTO_STATUS secret_pt(const point_basefield_t P, const digit_t* m, const unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny)\n{ // Computes key generation entirely in the base field by exploiting a 1-dimensional Montgomery ladder in the trace zero subgroup and \n  // recovering the y-coordinate for the addition. All operations in the base field GF(p).\n  // Input:  The scalar m, point P = (x,y) on E in the base field subgroup and Q = (x1,y1*i) on E in the trace-zero subgroup. \n  //         x,y,x1,y1 are all in the base field.          \n  // Output: R = (RX0+RX1*i)/RZ0 (the x-coordinate of P+[m]Q).\n    unsigned int nbits;\n    point_basefield_t Q;\n    point_basefield_proj_t S, T;\n    digit_t *X0 = (digit_t*)S->X, *Z0 = (digit_t*)S->Z, *X1 = (digit_t*)T->X, *Z1 = (digit_t*)T->Z;\n    digit_t *x  = (digit_t*)P->x, *y  = (digit_t*)P->y, *x1 = (digit_t*)Q->x, *y1 = (digit_t*)Q->y;\n    digit_t scalar[NWORDS_ORDER];\n    felm_t t0, t1, t2, A24 = {0};\n    digit_t *RX0 = (digit_t*)R->X[0], *RX1 = (digit_t*)R->X[1], *RZ0 = (digit_t*)R->Z[0], *RZ1 = (digit_t*)R->Z[1];\n\n    fpcopy751(P->x, Q->x);                         // Q = (-XP,YP)\n    fpcopy751(P->y, Q->y);\n    fpneg751(Q->x);\n\n    if (AliceOrBob == ALICE) {\n        nbits = CurveIsogeny->oAbits;\n    } else if (AliceOrBob == BOB) {\n        nbits = CurveIsogeny->oBbits;\n    } else {\n        return CRYPTO_ERROR_INVALID_PARAMETER;\n    }\n        \n    // Setting curve constant to one (in standard representation), used in xDBLADD_basefield() in the ladder computation\n    A24[0] = 1;\n    copy_words(m, scalar, NWORDS_ORDER);\n    ladder(Q->x, scalar, S, T, A24, nbits, CurveIsogeny->owordbits, CurveIsogeny);\n    \n    //RX0 = (2*y*y1*Z0^2*Z1 + Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2)*(2*y*y1*Z0^2*Z1 - Z1*(X0*x1+Z0)*(X0+x1*Z0) + X1*(X0-x1*Z0)^2) - 4*y1^2*Z0*Z1^2*(X0+x*Z0)*(X0-x*Z0)^2;\n    //RX1 = 4*y*y1*Z0^2*Z1*(Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2);\n    //RZ0 = 4*y1^2*Z0^2*Z1^2*(X0-x*Z0)^2;\n\n    fpmul751_mont(x1, Z0, RX1);\n    fpmul751_mont(X0, x1, RX0);\n    fpsub751(X0, RX1, t0);\n    fpadd751(X0, RX1, RX1);\n    fpsqr751_mont(t0, t0);\n    fpadd751(RX0, Z0, RX0);\n    fpmul751_mont(t0, X1, t0);\n    fpmul751_mont(RX0, RX1, RX0);\n    fpmul751_mont(y1, Z1, t2);\n    fpmul751_mont(y, Z0, t1);\n    fpadd751(t2, t2, t2);\n    fpmul751_mont(t2, Z0, RX1);\n    fpmul751_mont(RX0, Z1, RX0);\n    fpsub751(RX0, t0, RX0);\n    fpmul751_mont(t1, RX1, t1);\n    fpsqr751_mont(RX1, t0);\n    fpmul751_mont(t2, RX1, t2);\n    fpmul751_mont(t1, RX0, RX1);\n    fpadd751(t1, RX0, RZ0);\n    fpadd751(RX1, RX1, RX1);\n    fpsub751(t1, RX0, t1);\n    fpmul751_mont(x, Z0, RX0);\n    fpmul751_mont(t1, RZ0, t1);\n    fpsub751(X0, RX0, RZ0);\n    fpadd751(X0, RX0, RX0);\n    fpsqr751_mont(RZ0, RZ0);\n    fpmul751_mont(t2, RX0, t2);\n    fpmul751_mont(t2, RZ0, t2);\n    fpmul751_mont(RZ0, t0, RZ0);\n    fpsub751(t1, t2, RX0);\n    fpzero751(RZ1);\n\n    return CRYPTO_SUCCESS;\n}\n\n\nCRYPTO_STATUS ladder_3_pt(const f2elm_t xP, const f2elm_t xQ, const f2elm_t xPQ, const digit_t* m, const unsigned int AliceOrBob, point_proj_t W, const f2elm_t A, PCurveIsogenyStruct CurveIsogeny)\n{ // Computes P+[m]Q via x-only arithmetic. Algorithm by De Feo, Jao and Plut.\n  // Input:  three affine points xP,xQ,xPQ and Montgomery constant A.\n  // Output: projective Montgomery x-coordinates of x(P+[m]Q)=WX/WZ\n    point_proj_t U = {0}, V = {0};\n    f2elm_t A24, A24num, constant1 = {0}, constant2;\n    felm_t temp_scalar;\n    unsigned int bit = 0, nbits, fullbits = CurveIsogeny->owordbits;\n    digit_t mask;\n    int i;\n\n    if (AliceOrBob == ALICE) {\n        nbits = CurveIsogeny->oAbits;\n    } else if (AliceOrBob == BOB) {\n        nbits = CurveIsogeny->oBbits;\n    } else {\n        return CRYPTO_ERROR_INVALID_PARAMETER;\n    }\n   \n    fpcopy751(CurveIsogeny->Montgomery_one, constant1[0]);\n    fp2add751(constant1, constant1, constant1);                  // constant = 2\n    fp2add751(A, constant1, A24num);\n    fp2div2_751(A24num, A24);  \n    fp2div2_751(A24, A24);\n    \n    // Initializing with the points (1:0), (xQ:1) and (xP:1)\n    fpcopy751(CurveIsogeny->Montgomery_one, (digit_t*)U->X);\n    fp2copy751(xQ, V->X);\n    fpcopy751(CurveIsogeny->Montgomery_one, (digit_t*)V->Z);\n    fp2copy751(xP, W->X);\n    fpcopy751(CurveIsogeny->Montgomery_one, (digit_t*)W->Z);\n    fpzero751(W->Z[1]);\n    copy_words(m, temp_scalar, NWORDS_ORDER);\n    \n    for (i = fullbits-nbits; i > 0; i--) {\n        mp_shiftl1(temp_scalar, NWORDS_ORDER);\n    }\n    \n    for (i = nbits; i > 0; i--) {\n        bit = (unsigned int)(temp_scalar[NWORDS_ORDER-1] >> (RADIX-1));\n        mp_shiftl1(temp_scalar, NWORDS_ORDER);\n        mask = 0 - (digit_t)bit;\n\n        swap_points(W, U, mask);\n        swap_points(U, V, mask);\n        select_f2elm(xP, xQ, constant1, mask);\n        select_f2elm(xQ, xPQ, constant2, mask);\n        xADD(W, U, constant1);                     // If bit=0 then W <- W+U, U <- 2*U and V <- U+V, \n        xDBLADD(U, V, constant2, A24);             // else if bit=1 then U <- U+V, V <- 2*V and W <- V+W\n        swap_points(U, V, mask);\n        swap_points(W, U, mask);\n    }\n\n    return CRYPTO_SUCCESS;\n}\n\n\nvoid get_4_isog(const point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff)\n{ // Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.\n  // Input:  projective point of order four P = (X4:Z4).\n  // Output: the 4-isogenous Montgomery curve with projective coefficient A/C and the 5 coefficients \n  //         that are used to evaluate the isogeny at a point in eval_4_isog().\n    \n    fp2add751(P->X, P->Z, coeff[0]);                   // coeff[0] = X4+Z4\n    fp2sqr751_mont(P->X, coeff[3]);                    // coeff[3] = X4^2\n    fp2sqr751_mont(P->Z, coeff[4]);                    // coeff[4] = Z4^2\n    fp2sqr751_mont(coeff[0], coeff[0]);                // coeff[0] = (X4+Z4)^2\n    fp2add751(coeff[3], coeff[4], coeff[1]);           // coeff[1] = X4^2+Z4^2\n    fp2sub751(coeff[3], coeff[4], coeff[2]);           // coeff[2] = X4^2-Z4^2\n    fp2sqr751_mont(coeff[3], coeff[3]);                // coeff[3] = X4^4\n    fp2sqr751_mont(coeff[4], coeff[4]);                // coeff[4] = Z4^4\n    fp2add751(coeff[3], coeff[3], A);                  // A = 2*X4^4\n    fp2sub751(coeff[0], coeff[1], coeff[0]);           // coeff[0] = 2*X4*Z4 = (X4+Z4)^2 - (X4^2+Z4^2)\n    fp2sub751(A, coeff[4], A);                         // A = 2*X4^4-Z4^4\n    fp2copy751(coeff[4], C);                           // C = Z4^4\n    fp2add751(A, A, A);                                // A = 2(2*X4^4-Z4^4)\n}\n\n\nvoid eval_4_isog(point_proj_t P, f2elm_t* coeff)\n{ // Evaluates the isogeny at the point (X:Z) in the domain of the isogeny, given a 4-isogeny phi defined \n  // by the 5 coefficients in coeff (computed in the function four_isogeny_from_projective_kernel()).\n  // Inputs: the coefficients defining the isogeny, and the projective point P = (X:Z).\n  // Output: the projective point P = phi(P) = (X:Z) in the codomain. \n    f2elm_t t0, t1;\n\n    fp2mul751_mont(P->X, coeff[0], P->X);              // X = coeff[0]*X\n    fp2mul751_mont(P->Z, coeff[1], t0);                // t0 = coeff[1]*Z\n    fp2sub751(P->X, t0, P->X);                         // X = X-t0\n    fp2mul751_mont(P->Z, coeff[2], P->Z);              // Z = coeff[2]*Z\n    fp2sub751(P->X, P->Z, t0);                         // t0 = X-Z\n    fp2mul751_mont(P->Z, P->X, P->Z);                  // Z = X*Z\n    fp2sqr751_mont(t0, t0);                            // t0 = t0^2\n    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z\n    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z\n    fp2add751(P->Z, t0, P->X);                         // X = t0+Z\n    fp2mul751_mont(P->Z, t0, P->Z);                    // Z = t0*Z\n    fp2mul751_mont(P->Z, coeff[4], P->Z);              // Z = coeff[4]*Z\n    fp2mul751_mont(t0, coeff[4], t0);                  // t0 = t0*coeff[4]\n    fp2mul751_mont(P->X, coeff[3], t1);                // t1 = X*coeff[3]\n    fp2sub751(t0, t1, t0);                             // t0 = t0-t1\n    fp2mul751_mont(P->X, t0, P->X);                    // X = X*t0\n}\n\n\nvoid first_4_isog(point_proj_t P, const f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny)\n{ // Computes first 4-isogeny computed by Alice.\n  // Inputs: projective point P = (X4:Z4) and curve constant A.\n  // Output: the projective point P = (X4:Z4) in the codomain and isogenous curve constant Aout/Cout.  \n    f2elm_t t0 = {0}, t1, t2;\n    \n    fpcopy751(CurveIsogeny->Montgomery_one, t0[0]); \n    fpadd751(t0[0], t0[0], t0[0]);                     // t0 = 2 (in Montgomery domain)\n    fp2sub751(A, t0, Cout);                            // Cout = A-2\n    fpadd751(t0[0], t0[0], t1[0]);                     \n    fpadd751(t0[0], t1[0], t0[0]);                     // t0 = 6 (in Montgomery domain)\n    fp2add751(P->X, P->Z, t1);                         // t1 = X+Z\n    fp2sub751(P->X, P->Z, t2);                         // t2 = X-Z\n    fp2sqr751_mont(t1, t1);                            // t1 = (X+Z)^2\n    fp2add751(A, t0, Aout);                            // A = A+6\n    fp2mul751_mont(P->X, P->Z, P->Z);                  // Z = X*Z\n    fp2neg751(P->Z);                                   // Z = -X*Z\n    fp2sqr751_mont(t2, t2);                            // t2 = (X-Z)^2\n    fp2mul751_mont(P->Z, Cout, P->Z);                  // Z = -C*X*Z\n    fp2add751(Aout, Aout, Aout);                       // Aout = 2*A+12\n    fp2sub751(t1, P->Z, P->X);                         // X = (X+Z)^2+C*X*Z\n    fp2mul751_mont(P->Z, t2, P->Z);                    // Z = -C*X*Z*(X-Z)^2\n    fp2mul751_mont(P->X, t1, P->X);                    // X = (X+Z)^2*[(X+Z)^2+C*X*Z]\n}\n\n\nvoid xTPL(const point_proj_t P, point_proj_t Q, const f2elm_t A24, const f2elm_t C24)\n{ // Tripling of a Montgomery point in projective coordinates (X:Z).\n  // Input: projective Montgomery x-coordinates P = (X:Z), where x=X/Z and Montgomery curve constant A/C.\n  // Output: projective Montgomery x-coordinates Q = 3*P = (X3:Z3).\n    f2elm_t t0, t1, t2, t3, t4, t5;\n\n    fp2sub751(P->X, P->Z, t2);                         // t2 = X-Z           \n    fp2add751(P->X, P->Z, t3);                         // t3 = X+Z \n    fp2sqr751_mont(t2, t0);                            // t0 = t2^2 \n    fp2sqr751_mont(t3, t1);                            // t1 = t3^2 \n    fp2mul751_mont(t0, C24, t4);                       // t4 = C24*t0 \n    fp2mul751_mont(t1, t4, t5);                        // t5 = t4*t1\n    fp2sub751(t1, t0, t1);                             // t1 = t1-t0 \n    fp2mul751_mont(A24, t1, t0);                       // t0 = A24*t1\n    fp2add751(t4, t0, t4);                             // t4 = t4+t0\n    fp2mul751_mont(t1, t4, t4);                        // t4 = t4*t1\n    fp2add751(t5, t4, t0);                             // t0 = t5+t4\n    fp2sub751(t5, t4, t1);                             // t1 = t5-t4\n    fp2mul751_mont(t0, t2, t0);                        // t0 = t2*t0\n    fp2mul751_mont(t1, t3, t1);                        // t1 = t3*t1\n    fp2sub751(t0, t1, t4);                             // t4 = t0-t1\n    fp2add751(t0, t1, t5);                             // t5 = t0+t1\n    fp2sqr751_mont(t4, t4);                            // t4 = t4^2\n    fp2sqr751_mont(t5, t5);                            // t5 = t5^2\n    fp2mul751_mont(P->X, t4, t4);                      // t4 = X*t4\n    fp2mul751_mont(P->Z, t5, Q->X);                    // X3 = Z*t5\n    fp2copy751(t4, Q->Z);                              // Z3 = t4\n}\n\n\nvoid xTPLe(const point_proj_t P, point_proj_t Q, const f2elm_t A, const f2elm_t C, const int e)\n{ // Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.\n  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.\n  // Output: projective Montgomery x-coordinates Q <- (3^e)*P.\n    f2elm_t A24, C24;\n    int i;\n    \n    fp2add751(C, C, A24);                           \n    fp2add751(A24, A24, C24);                    \n    fp2add751(A24, A, A24);       \n    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);\n\n    for (i = 0; i < e; i++) {\n        xTPL(Q, Q, A24, C24);\n    }\n}\n\n\nvoid get_3_isog(const point_proj_t P, f2elm_t A, f2elm_t C)\n{ // Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.\n  // Input:  projective point of order three P = (X3:Z3).\n  // Output: the 3-isogenous Montgomery curve with projective coefficient A/C. \n    f2elm_t t0, t1;\n\n    fp2sqr751_mont(P->X, t0);                          // t0 = X^2\n    fp2add751(t0, t0, t1);                             // t1 = 2*t0\n    fp2add751(t0, t1, t0);                             // t0 = t0+t1\n    fp2sqr751_mont(P->Z, t1);                          // t1 = Z^2\n    fp2sqr751_mont(t1, A);                             // A = t1^2\n    fp2add751(t1, t1, t1);                             // t1 = 2*t1\n    fp2add751(t1, t1, C);                              // C = 2*t1\n    fp2sub751(t0, t1, t1);                             // t1 = t0-t1\n    fp2mul751_mont(t0, t1, t1);                        // t1 = t0*t1\n    fp2sub751(A, t1, A);                               // A = A-t1 \n    fp2sub751(A, t1, A);                               // A = A-t1 \n    fp2sub751(A, t1, A);                               // A = A-t1     \n    fp2mul751_mont(P->X, P->Z, t1);                    // t1 = X*Z    // ms trade-off possible (1 mul for 1sqr + 1add + 2sub)\n    fp2mul751_mont(C, t1, C);                          // C = C*t1\n}\n\n\nvoid eval_3_isog(const point_proj_t P, point_proj_t Q)\n{ // Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).\n  // Inputs: projective points P = (X3:Z3) and Q = (X:Z).\n  // Output: the projective point Q <- phi(Q) = (XX:ZZ). \n    f2elm_t t0, t1, t2;\n\n    fp2mul751_mont(P->X, Q->X, t0);                  // t0 = X3*X\n    fp2mul751_mont(P->Z, Q->X, t1);                  // t1 = Z3*X\n    fp2mul751_mont(P->Z, Q->Z, t2);                  // t2 = Z3*Z\n    fp2sub751(t0, t2, t0);                           // t0 = X3*X-Z3*Z          \n    fp2mul751_mont(P->X, Q->Z, t2);                  // t2 = X3*Z\n    fp2sub751(t1, t2, t1);                           // t1 = Z3*X-X3*Z\n    fp2sqr751_mont(t0, t0);                          // t0 = (X3*X-Z3*Z)^2\n    fp2sqr751_mont(t1, t1);                          // t1 = (Z3*X-X3*Z)^2\n    fp2mul751_mont(Q->X, t0, Q->X);                  // X = X*(X3*X-Z3*Z)^2        \n    fp2mul751_mont(Q->Z, t1, Q->Z);                  // Z = Z*(Z3*X-X3*Z)^2\n}\n\n\nvoid inv_3_way(f2elm_t z1, f2elm_t z2, f2elm_t z3)\n{ // 3-way simultaneous inversion\n  // Input:  z1,z2,z3\n  // Output: 1/z1,1/z2,1/z3 (override inputs).\n    f2elm_t t0, t1, t2, t3;\n\n    fp2mul751_mont(z1, z2, t0);                      // t0 = z1*z2\n    fp2mul751_mont(z3, t0, t1);                      // t1 = z1*z2*z3\n    fp2inv751_mont(t1);                              // t1 = 1/(z1*z2*z3)\n    fp2mul751_mont(z3, t1, t2);                      // t2 = 1/(z1*z2) \n    fp2mul751_mont(t2, z2, t3);                      // t3 = 1/z1\n    fp2mul751_mont(t2, z1, z2);                      // z2 = 1/z2\n    fp2mul751_mont(t0, t1, z3);                      // z3 = 1/z3\n    fp2copy751(t3, z1);                              // z1 = 1/z1\n}\n\n\nvoid distort_and_diff(const felm_t xP, point_proj_t D, PCurveIsogenyStruct CurveIsogeny)\n{ // Computing the point (x(Q-P),z(Q-P))\n  // Input:  coordinate xP of point P=(xP,yP)\n  // Output: the point D = (x(Q-P),z(Q-P)), where Q=tau(P).\n    felm_t one;\n\n    fpcopy751(CurveIsogeny->Montgomery_one, one);\n    fpsqr751_mont(xP, D->X[0]);\t                     // XD = xP^2\n    fpadd751(D->X[0], one, D->X[0]);                 // XD = XD+1\n    fpcopy751(D->X[0], D->X[1]);                     // XD = XD*i\n    fpzero751(D->X[0]);          \n    fpadd751(xP, xP, D->Z[0]);                       // ZD = xP+xP\n}\n\n\nvoid get_A(const f2elm_t xP, const f2elm_t xQ, const f2elm_t xR, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)\n{ // Given the x-coordinates of P, Q, and R, returns the value A corresponding to the Montgomery curve E_A: y^2=x^3+A*x^2+x such that R=Q-P on E_A.\n  // Input:  the x-coordinates xP, xQ, and xR of the points P, Q and R.\n  // Output: the coefficient A corresponding to the curve E_A: y^2=x^3+A*x^2+x.\n    f2elm_t t0, t1, one = {0};\n    \n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    fp2add751(xP, xQ, t1);                           // t1 = xP+xQ\n    fp2mul751_mont(xP, xQ, t0);                      // t0 = xP*xQ\n    fp2mul751_mont(xR, t1, A);                       // A = xR*t1\n    fp2add751(t0, A, A);                             // A = A+t0\n    fp2mul751_mont(t0, xR, t0);                      // t0 = t0*xR\n    fp2sub751(A, one, A);                            // A = A-1\n    fp2add751(t0, t0, t0);                           // t0 = t0+t0\n    fp2add751(t1, xR, t1);                           // t1 = t1+xR\n    fp2add751(t0, t0, t0);                           // t0 = t0+t0\n    fp2sqr751_mont(A, A);                            // A = A^2\n    fp2inv751_mont(t0);                              // t0 = 1/t0\n    fp2mul751_mont(A, t0, A);                        // A = A*t0\n    fp2sub751(A, t1, A);                             // Afinal = A-t1\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////              FUNCTIONS FOR COMPRESSION              ///////////////\n\nstatic void get_point_notin_2E(felm_t alpha, const f2elm_t A, const felm_t one, const felm_t four, const felm_t value47, const felm_t value52)\n{ // Inputs: alpha, a small integer (parsed in Fp),\n  //         Montgomery coefficient A = A0+A1*i.\n  // Output: alpha such that alpha*u = alpha*(i+4) is a good x-coordinate, which means it corresponds to a point P not in [2]E.\n  //         Then, [3^eB]P has full order 2^eA.\n    digit_t *A0 = (digit_t*)A[0], *A1 = (digit_t*)A[1];\n    felm_t X0, X1, x0, x1, t0, sqrt, X0_temp = {0}, X1_temp = {0}, alpha52 = {0}, alpha52_2 = {0}, alpha47 = {0}, alpha47_2 = {0};\n    unsigned int i;\n    \n    fpsub751(A0, A1, x0);                            // x0 = A0-A1\n    fpadd751(x0, A0, x0);                            // x0 = x0+A0\n    fpadd751(x0, x0, x0);   \n    fpadd751(x0, x0, x0);\n    fpadd751(x0, x0, x0);                            // x0 = 8*x0\n    fpsub751(x0, A0, X0);                            // X0 = x0-A0\n    fpadd751(A0, A1, x1);                            // x1 = A0+A1\n    fpadd751(x1, A1, x1);                            // x1 = x1+A1\n    fpadd751(x1, x1, x1);   \n    fpadd751(x1, x1, x1);\n    fpadd751(x1, x1, x1);                            // x1 = 8*x1\n    fpsub751(x1, A1, X1);                            // X1 = x1-A1\n    fpmul751_mont(alpha, value52, alpha52);          // alpha52 = 52*alpha \n    fpmul751_mont(X0, alpha, X0_temp);               // X0*alpha\n    fpmul751_mont(alpha52, alpha, alpha52_2);        // alpha52^2 = 52*alpha^2 \n    fpmul751_mont(alpha, value47, alpha47);          // alpha47 = 47*alpha \n    fpmul751_mont(X1, alpha, X1_temp);               // X0*alpha\n    fpmul751_mont(alpha47, alpha, alpha47_2);        // alpha47^2 = 47*alpha^2 \n\n    do {   \n        fpadd751(alpha, one, alpha);                 // alpha += 1        \n        fpadd751(X0_temp, X0, X0_temp);              // X0*alpha\n        fpadd751(alpha52, value52, t0);              // t0 = 52*alpha52 + 52\n        fpadd751(alpha52, t0, alpha52);              // 2*52*alpha52 + 52\n        fpadd751(alpha52_2, alpha52, alpha52_2);     // 52*alpha^2 = 52*alpha52^2 + 2*52*alpha52 + 52\n        fpcopy751(t0, alpha52);                      // 52*alpha = 52*alpha52 + 52\n        fpadd751(alpha52_2, four, x0);               // 52*alpha^2 + 4\n        fpadd751(X0_temp, x0, x0);                   // x0 = X0*alpha + 52*alpha^2 + 4               \n        fpadd751(X1_temp, X1, X1_temp);              // X1*alpha\n        fpadd751(alpha47, value47, t0);              // t0 = 47*alpha47 + 47\n        fpadd751(alpha47, t0, alpha47);              // 2*47*alpha52 + 47\n        fpadd751(alpha47_2, alpha47, alpha47_2);     // 47*alpha^2 = 47*alpha52^2 + 2*47*alpha52 + 47\n        fpcopy751(t0, alpha47);                      // 47*alpha = 47*alpha52 + 47\n        fpadd751(alpha47_2, one, x1);                // 47*alpha^2 + 1\n        fpadd751(X1_temp, x1, x1);                   // x0 = X0*alpha + 47*alpha^2 + 1\n        fpsqr751_mont(x0, x0);                       // x0 = x0^2\n        fpsqr751_mont(x1, x1);                       // x1 = x1^2\n        fpsqr751_mont(alpha, t0);                    // t0 = alpha^2\n        fpadd751(x0, x1, x0);                        // x0 = x0+x1\n        fpmul751_mont(t0, x0, t0);                   // t0 = t0*x0\n        fpcopy751(t0, sqrt);\n        for (i = 0; i < 371; i++) {                  // sqrt = t0^((p+1) div 2)\n            fpsqr751_mont(sqrt, sqrt);\n        }\n        for (i = 0; i < 239; i++) {\n            fpsqr751_mont(sqrt, x0);\n            fpmul751_mont(sqrt, x0, sqrt);\n        }\n        fpcorrection751(sqrt);\n        fpcorrection751(t0);\n    } while (fpequal751_non_constant_time(sqrt, t0) == false);\n}\n\n\nvoid generate_2_torsion_basis(const f2elm_t A, point_full_proj_t R1, point_full_proj_t R2, PCurveIsogenyStruct CurveIsogeny)\n{ // Produces points R1 and R2 such that {R1, R2} is a basis for E[2^372].                    \n  // Input:   curve constant A.\n  // Outputs: R1 = (X1:Y1:Z1) and R2 = (X2:Y2:Z2).\n    point_proj_t P, Q, P1 = {0}, P2 = {0};\n    felm_t *X1 = (felm_t*)P1->X, *Z1 = (felm_t*)P1->Z;\n    felm_t *X2 = (felm_t*)P2->X, *Z2 = (felm_t*)P2->Z;\n    felm_t *XP = (felm_t*)P->X,  *ZP = (felm_t*)P->Z;\n    felm_t *XQ = (felm_t*)Q->X,  *ZQ = (felm_t*)Q->Z;\n    felm_t *Y1 = (felm_t*)R1->Y, *Y2 = (felm_t*)R2->Y;\n    felm_t zero, alpha = {0};\n\tf2elm_t t0, t1, one = {0};\n\tfelm_t four, value47 = {0}, value52 = {0};\n\n\tfpzero751(zero);\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    \n\tvalue47[0] = 47;\n\tvalue52[0] = 52;\n    to_mont(value47, value47);\n    to_mont(value52, value52);\n    fpadd751(one[0], one[0], four);\n    fpadd751(four, four, four);\n\n    get_point_notin_2E(alpha, A, one[0], four, value47, value52);\n\tfpcopy751(alpha, X1[1]);\n    fpadd751(alpha, alpha, X1[0]);\n    fpadd751(X1[0], X1[0], X1[0]);                   // X1 = alpha*i + alpha*4\n\tfpcopy751(one[0], Z1[0]);                        // Z1 = 1 \n\n    xTPLe(P1, P1, A, one, 239);                      // xTPL assumes projective constant, but this is minor\n    xDBLe(P1, P, A, one, 371);\n\n   // This loop is necessary to ensure that the order of the WeilPairing is oA and not smaller. \n   // This ensures that we have a basis.\n    do {\n        get_point_notin_2E(alpha, A, one[0], four, value47, value52);  \n        fpcopy751(alpha, X2[1]);\n        fpadd751(alpha, alpha, X2[0]);\n        fpadd751(X2[0], X2[0], X2[0]);               // X2 = alpha*i + alpha*4\n        fpzero751(Z2[1]);                             \n        fpcopy751(one[0], Z2[0]);                    // Z2 = 1 \n        xTPLe(P2, P2, A, one, 239);                  // xTPL assumes projective constant, but this is minor\n        xDBLe(P2, Q, A, one, 371);  \n        fp2mul751_mont(XP, ZQ, t0);                  // t0 = XP*ZQ\n        fp2mul751_mont(XQ, ZP, t1);                  // t1 = XQ*ZP\n        fp2sub751(t0, t1, t0);                       // t0 = XP*ZQ-XQ*ZP\n\t\tfp2correction751(t0);\n    } while (fpequal751_non_constant_time(t0[0], zero) == true && fpequal751_non_constant_time(t0[1], zero) == true);\n    \n    fp2copy751(X1, R1->X);\n    fp2copy751(Z1, R1->Z);\n    fp2copy751(X2, R2->X);\n    fp2copy751(Z2, R2->Z);\n\n    // Recover the y-coordinates.\n    fp2sqr751_mont(Z1, t0);                          // t0 = Z1^2\n    fp2mul751_mont(A, Z1, Y1);                       // Y1 = A*Z1\n\tfp2add751(X1, Y1, Y1);                           // Y1 = X1+Y1\n    fp2mul751_mont(X1, Y1, Y1);                      // Y1 = Y1*X1\n\tfp2add751(t0, Y1, Y1);                           // Y1 = Y1+t0\n    fp2mul751_mont(X1, Y1, Y1);                      // Y1 = Y1*X1\n\tfp2mul751_mont(t0, Z1, t0);                      // t0 = t0*Z1\n    sqrt_Fp2_frac(Y1, t0, t1);                       // t1 = sqrt(Y1/t0)\n    \n\tfp2sqr751_mont(Z2, t0);                          // t0 = Z2^2\n    fp2mul751_mont(A, Z2, Y2);                       // Y2 = A*Z2\n    fp2add751(X2, Y2, Y2);                           // Y2 = X2+Y2\n    fp2mul751_mont(Y2, X2, Y2);                      // Y2 = Y2*X2\n    fp2add751(t0, Y2, Y2);                           // Y2 = Y2+t0\n    fp2mul751_mont(Y2, X2, Y2);                      // Y2 = Y2*X2\n\tfp2mul751_mont(t0, Z2, t0);                      // t0 = t0*Z2\n    fp2mul751_mont(t1, Z1, Y1);                      // Y1 = t1*Z1\n    sqrt_Fp2_frac(Y2, t0, t1);                       // t1 = sqrt(Y2/t0)    \n\tfp2mul751_mont(Z2, t1, Y2);                      // Y2 = t1*Z2\n}\n\n\nstatic uint64_t sqrt17[NWORDS64_FIELD] = { 0x89127CDB8966913D, 0xF788014C8C8401A0, 0x1A16F73884F3E3E8, 0x2E67382B560FA195, 0xDD5EE869B7F4FD81, 0x16A0849EF695EFEB,\n\t                                       0x3675244609DE1963, 0x36F02976EF2EB241, 0x92D09F939A20637F, 0x41496905F2B0112C, 0xA94C09B1F7242495, 0x0000297652D36A97 };\n\nstatic void get_X_on_curve(f2elm_t A, unsigned int* r, f2elm_t x, felm_t t1, felm_t a, felm_t b) \n{ // Elligator2 for X\n    felm_t v0, v1, r0, r1, t0, t2, t3, rsq = {0};\n    unsigned int i;\n\n    fpcopy751(((felm_t*)&LIST)[(*r << 1)-2], r1);    // r1 = list[2*r-1]\n    fpcopy751(((felm_t*)&LIST)[(*r << 1)-1], r0);    // r0 = list[2*r]\n    rsq[0] = (*r)*(*r);                              // rsp = r^2\n    to_mont(rsq, rsq);                               // Converting to Montgomery representation \n    fpmul751_mont(A[1], r1, t0);                     // t0 = A1*r1\n\tfpmul751_mont(A[0], r0, v0);                     // v0 = A0*r0\n\tfpsub751(v0, t0, v0);                            // v0 = v0-t0\n\tfpmul751_mont(A[1], r0, t0);                     // t0 = A1*r0\n    fpmul751_mont(A[0], r1, v1);                     // v1 = A0*r1\n    fpadd751(v1, t0, v1);                            // v1 = v1+t0\n\tfpadd751(v0, A[0], t0);                          // t0 = v0+A0\n    fpadd751(v1, A[1], t1);                          // t1 = v1+A1\n    fpmul751_mont(v0, v1, t2);                       // t2 = v0*v1\n    fpadd751(t2, t2, t2);                            // t2 = t2+t2\n    fpmul751_mont(t2, A[1], a);                      // a = t2*A1\n    fpsub751(v0, a, a);                              // a = v0-a\n    fpmul751_mont(t2, A[0], b);                      // b = t2*A0\n    fpadd751(b, v1, b);                              // b = b+v1\n    fpadd751(v0, v0, t2);                            // t2 = v0+v0\n    fpadd751(t0, t2, t2);                            // t2 = t2+t0\n    fpsqr751_mont(v0, t3);                           // t3 = v0^2\n    fpmul751_mont(t0, t3, t0);                       // t0 = t0*t3\n    fpadd751(a, t0, a);                              // a = a+t0\n    fpsqr751_mont(v1, t0);                           // t0 = v1^2\n    fpmul751_mont(t0, t2, t2);                       // t2 = t0*t2\n    fpsub751(a, t2, a);                              // a = a-t2\n    fpmul751_mont(t0, t1, t0);                       // t0 = t0*t1\n    fpsub751(b, t0, b);                              // b = b-t0\n    fpadd751(t1, v1, t1);                            // t1 = t1+v1\n    fpadd751(v1, t1, t1);                            // t1 = t1+v1\n    fpmul751_mont(t3, t1, t1);                       // t1 = t1*t3\n    fpadd751(b, t1, b);                              // b = t1+b\n    fpsqr751_mont(a, t0);                            // t0 = a^2\n    fpsqr751_mont(b, t1);                            // t1 = b^2\n    fpadd751(t0, t1, t0);                            // t0 = t0+t1\n\tfpcopy751(t0, t1);\t\n    for (i = 0; i < 370; i++) {                      // t1 = t0^((p+1) div 4)\n        fpsqr751_mont(t1, t1);\n    }\n    for (i = 0; i < 239; i++) {\n        fpsqr751_mont(t1, t2);\n        fpmul751_mont(t1, t2, t1);\n    }\n    fpsqr751_mont(t1, t2);                           // t2 = t1^2\n\tfpcorrection751(t0);\n    fpcorrection751(t2);\n    if (fpequal751_non_constant_time(t0, t2) == false) {\n        fpadd751(v0, v0, x[0]);                      // x0 = v0+v0\n        fpadd751(x[0], x[0], x[0]);                  // x0 = x0+x0\n        fpsub751(x[0], v1, x[0]);                    // x0 = x0-v1\n        fpmul751_mont(rsq, x[0], x[0]);              // x0 = rsq*x0\n        fpadd751(v1, v1, x[1]);                      // x1 = v1+v1\n        fpadd751(x[1], x[1], x[1]);                  // x1 = x1+x1\n        fpadd751(x[1], v0, x[1]);                    // x1 = x1+v0\n        fpmul751_mont(rsq, x[1], x[1]);              // x1 = rsq*x1\n        fpcopy751(a, t0);                            // t0 = a\n        fpadd751(a, a, a);                           // a = a+a\n        fpadd751(a, a, a);                           // a = a+a\n        fpsub751(a, b, a);                           // a = a-b\n        fpmul751_mont(rsq, a, a);                    // a = rsq*a\n        fpadd751(b, b, b);                           // b = b+b\n        fpadd751(b, b, b);                           // b = b+b\n        fpadd751(t0, b, b);                          // b = b+t0\n        fpmul751_mont(rsq, b, b);                    // b = rsq*b\n        fpmul751_mont(rsq, t1, t1);                  // t1 = t1*rsq\n        fpmul751_mont(t1, (digit_t*)sqrt17, t1);     // t1 = t1*sqrt17\n    } else {\n        fpcopy751(v0, x[0]);                         // x0 = v0\n        fpcopy751(v1, x[1]);                         // x1 = v1\n    }\n}\n\n\nstatic void get_pt_on_curve(f2elm_t A, unsigned int* r, f2elm_t x, f2elm_t y)\n{ // Elligator2\n    felm_t t0, t1, t2, t3, a, b;\n\n    get_X_on_curve(A, r, x, t1, a, b);\n    fpadd751(a, t1, t0);                             // t0 = a+t1\n    fpdiv2_751(t0, t0);                              // t0 = t0/2\n    fpcopy751(t0, t1);\n    fpinv751_chain_mont(t1);                         // t1 = t0^((p-3)/4)\n    fpmul751_mont(t0, t1, t3);                       // t3 = t0*t1\n    fpsqr751_mont(t3, t2);                           // t2 = t3^2\n    fpdiv2_751(t1, t1);                              // t1 = t1/2\n    fpmul751_mont(b, t1, t1);                        // t1 = t1*b\n\tfpcorrection751(t0);\n\tfpcorrection751(t2);\n  \n    if (fpequal751_non_constant_time(t0, t2) == true) {\n        fpcopy751(t3, y[0]);                         // y0 = t3\n        fpcopy751(t1, y[1]);                         // y1 = t1;\n    } else {\n        fpneg751(t3);          \n        fpcopy751(t1, y[0]);                         // y0 = t1;\n        fpcopy751(t3, y[1]);                         // y1 = -t3\n    }\n  }\n\n\nstatic void get_3_torsion_elt(f2elm_t A, unsigned int* r, point_proj_t P, point_proj_t P3, unsigned int* triples, PCurveIsogenyStruct CurveIsogeny)\n{\n    point_proj_t PP;\n    f2elm_t A24, C24, one = {0};\n    felm_t t0, t1, t2, zero = {0};\n    \n    *triples = 0;\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    fpadd751(one[0], one[0], C24[0]);\n\tfpzero751(C24[1]);\n    \n    get_X_on_curve(A, r, P->X, t0, t1, t2);\n    fp2copy751(one, P->Z);                           // Z = 1\n    xDBLe(P, P, A, one, 372);\n\n\tfp2copy751(P->X, PP->X);                         // XX = X\n    fp2copy751(P->Z, PP->Z);                         // ZZ = Z\n\n    fp2add751(A, C24, A24);                          // A24 = A+2\n    fpadd751(C24[0], C24[0], C24[0]);                // C24 = 4\n\n\tfp2correction751(PP->Z);\n    while (fpequal751_non_constant_time(PP->Z[0], zero) == false || fpequal751_non_constant_time(PP->Z[1], zero) == false) {\n        fp2copy751(PP->X, P3->X);                    // X3 = XX\n        fp2copy751(PP->Z, P3->Z);                    // Z3 = ZZ\n        xTPL(PP, PP, A24, C24);\n        (*triples)++;\n\t\tfp2correction751(PP->Z);\n    }\n}\n\n\nvoid generate_3_torsion_basis(f2elm_t A, point_full_proj_t R1, point_full_proj_t R2, PCurveIsogenyStruct CurveIsogeny)\n{ // Produces points R1 and R2 such that {R1, R2} is a basis for E[3^239].       \n  // Input:   curve constant A.\n  // Outputs: R1 = (X1:Y1:Z1) and R2 = (X2:Y2:Z2).\n    point_proj_t R, R3, R4;\n    felm_t *X  = (felm_t*)R->X,  *Z  = (felm_t*)R->Z;\n    felm_t *X3 = (felm_t*)R3->X, *Z3 = (felm_t*)R3->Z;\n\tfelm_t *X4 = (felm_t*)R4->X, *Z4 = (felm_t*)R4->Z;\n    felm_t *X1 = (felm_t*)R1->X, *Y1 = (felm_t*)R1->Y, *Z1 = (felm_t*)R1->Z;\n    felm_t *X2 = (felm_t*)R2->X, *Y2 = (felm_t*)R2->Y, *Z2 = (felm_t*)R2->Z;\n    f2elm_t u, v, c, f, t0, f0, fX, fY, Y, Y3, one = {0};\n\tfelm_t zero = {0};\n    unsigned int r = 1;         \n    unsigned int triples = 0, pts_found = 0;\n\n    get_3_torsion_elt(A, &r, R, R3, &triples, CurveIsogeny);        \n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]); \n\tfpzero751(zero);\n\n    if (triples == 239) {\n        pts_found = 1;\n        fp2copy751(X, X1);                           // X1 = X\n        fp2copy751(Z, Z1);                           // Z1 = Z \n        fp2mul751_mont(A, Z1, u);                    // u = A*Z1\n        fp2add751(u, X1, u);                         // u = u+X1\n        fp2mul751_mont(u, X1, u);                    // u = u*X1\n        fp2sqr751_mont(Z1, v);                       // v = Z1^2\n        fp2add751(u, v, u);                          // u = u+v\n        fp2mul751_mont(u, X1, u);                    // u = u*X1\n        fp2mul751_mont(v, Z1, v);                    // v = v*Z1\n        sqrt_Fp2_frac(u, v, Y1);                     // Y1 = sqrt(u/v)\n        fp2mul751_mont(Y1, Z1, Y1);                  // Y1 = Y1*Z1\n    }\n\n    fp2mul751_mont(A, Z3, u);                        // u = A*Z3\n    fp2add751(u, X3, u);                             // u = u+X3\n    fp2mul751_mont(u, X3, u);                        // u = u*X3\n    fp2sqr751_mont(Z3, v);                           // v = Z3^2\n    fp2add751(u, v, u);                              // u = u+v\n    fp2mul751_mont(u, X3, u);                        // u = u*X3\n    fp2mul751_mont(v, Z3, v);                        // v = v*Z3\n    sqrt_Fp2_frac(u, v, Y3);                         // Y3 = sqrt(u/v)\n    fp2mul751_mont(Y3, Z3, Y3);                      // Y3 = Y3*Z3\n    fp2sqr751_mont(X3, f0);                          // f0 = X3^2\n    fp2sqr751_mont(Z3, t0);                          // t0 = Z3^2\n    fp2mul751_mont(X3, Z3, fX);                      // fX = X3*Z3\n    fp2mul751_mont(A, fX, fX);                       // fX = A*fX\n    fp2add751(fX, fX, fX);                           // fX = fX+fX\n    fp2add751(fX, t0, fX);                           // fX = fX+t0\n    fp2add751(fX, f0, fX);                           // fX = fX+f0\n    fp2add751(fX, f0, fX);                           // fX = fX+f0\n    fp2add751(fX, f0, fX);                           // fX = fX+f0\n    fp2sub751(t0, f0, f0);                           // f0 = t0-f0\n    fp2mul751_mont(fX, Z3, fX);                      // fX = fX*Z3\n    fp2mul751_mont(Y3, Z3, fY);                      // fY = Y3*Z3\n    fp2add751(fY, fY, fY);                           // fY = fY+fY\n    fp2neg751(fY);                                   // fY = -fY\n    fp2add751(fY, fY, c);                            // c = fY+fY\n    fp2mul751_mont(fY, Z3, fY);                      // fY = fY*Z3\n    fp2mul751_mont(f0, X3, f0);                      // f0 = f0*X3\n    fp2mul751_mont(c, Y3, c);                        // c = c*Y3\n    fp2mul751_mont(fX, c, fX);                       // fX = c*fX\n    fp2mul751_mont(fY, c, fY);                       // fY = c*fY\n    fp2mul751_mont(f0, c, f0);                       // f0 = c*f0\n\n\tdo {\n\t\twhile (pts_found < 2) {\n\t\t\tr++;\n\t\t\tget_pt_on_curve(A, &r, X, Y);\n\t\t\tfp2mul751_mont(fX, X, f);                    // f = fX*X\n\t\t\tfp2mul751_mont(fY, Y, t0);                   // t0 = fY*Y\n\t\t\tfp2add751(f, t0, f);                         // f = f+t0\n\t\t\tfp2add751(f, f0, f);                         // f = f+f0\n\n\t\t\tif (is_cube_Fp2(f, CurveIsogeny) == false) {\n\t\t\t\tfp2copy751(one, Z);                      // Z = 1\n\t\t\t\txDBLe(R, R, A, one, 372);\n\t\t\t\tfp2mul751_mont(A, Z, u);                 // u = A*Z\n\t\t\t\tfp2add751(u, X, u);                      // u = u+X\n\t\t\t\tfp2mul751_mont(u, X, u);                 // u = u*X\n\t\t\t\tfp2sqr751_mont(Z, v);                    // v = Z^2\n\t\t\t\tfp2add751(u, v, u);                      // u = u+v\n\t\t\t\tfp2mul751_mont(u, X, u);                 // u = u*X\n\t\t\t\tfp2mul751_mont(v, Z, v);                 // v = v*Z\n\t\t\t\tsqrt_Fp2_frac(u, v, Y);                  // Y = sqrt(u/v)\n\t\t\t\tfp2mul751_mont(Y, Z, Y);                 // Y = Y*Z\n\n\t\t\t\tif (pts_found == 0) {\n\t\t\t\t\tfp2copy751(X, X1);                   // X1 = X\n\t\t\t\t\tfp2copy751(Y, Y1);                   // Y1 = Y\n\t\t\t\t\tfp2copy751(Z, Z1);                   // Z1 = Z\n\t\t\t\t\txTPLe(R, R3, A, one, 238);\n\t\t\t\t} else {\n\t\t\t\t\tfp2copy751(X, X2);                   // X2 = X\n\t\t\t\t\tfp2copy751(Y, Y2);                   // Y2 = Y\n\t\t\t\t\tfp2copy751(Z, Z2);                   // Z2 = Z\n\t\t\t\t\txTPLe(R, R4, A, one, 238);\n\t\t\t\t}\n\t\t\t\tpts_found++;\n\t\t\t}\n\t\t}\n\t\tfp2mul751_mont(X3, Z4, t0);\n\t\tfp2mul751_mont(X4, Z3, v);\n\t\tfp2sub751(t0, v, t0);\n\t\tfp2correction751(t0);\n\t\tpts_found--;\n\t} while (fpequal751_non_constant_time(t0[0], zero) == true && fpequal751_non_constant_time(t0[1], zero) == true);\n}\n\n\nstatic void dbl_and_line(const point_ext_proj_t P, const f2elm_t A, f2elm_t lx, f2elm_t ly, f2elm_t l0, f2elm_t v0)\n{ // Doubling step for computing the Tate pairing using Miller's algorithm.\n  // This function computes a point doubling of P and returns the corresponding line coefficients for the pairing doubling step.\n\tfelm_t *X2 = (felm_t*)P->X2, *XZ = (felm_t*)P->XZ, *YZ = (felm_t*)P->YZ, *Z2 = (felm_t*)P->Z2;\n\tf2elm_t XX2, t0;\n\n\tfp2add751(YZ, YZ, XX2);               //X2_: = YZ + YZ;\n\tfp2sqr751_mont(XX2, ly);              //ly: = X2_ ^ 2;\n\tfp2sub751(X2, Z2, l0);                //l0: = X2 - Z2;\n\tfp2sqr751_mont(l0, v0);               //v0: = l0 ^ 2;\n\tfp2mul751_mont(XX2, l0, l0);          //l0: = X2_*l0;\n\tfp2mul751_mont(XZ, l0, lx);           //lx: = XZ*l0;\n\tfp2mul751_mont(YZ, ly, XX2);          //X2_: = YZ*ly;\n\tfp2add751(XX2, lx, lx);               //lx: = X2_ + lx;\n\tfp2add751(X2, Z2, YZ);                //YZ: = X2 + Z2;\n\tfp2mul751_mont(A, YZ, YZ);            //YZ: = A*YZ;\n\tfp2add751(XZ, XZ, XX2);               //X2_: = XZ + XZ;\n\tfp2add751(XX2, YZ, YZ);               //YZ: = X2_ + YZ;\n\tfp2add751(XX2, YZ, YZ);                  //YZ_: = X2_ + YZ_;\n\tfp2mul751_mont(XX2, YZ, YZ);          //YZ_: = X2_*YZ_;\n\n\tfp2sqr751_mont(v0, XX2);              //X2_: = v0 ^ 2;\n\tfp2sqr751_mont(l0, t0);               //XZ_: = l0 ^ 2;\n\tfp2sqr751_mont(ly, Z2);               //Z2: = ly ^ 2;\n\tfp2add751(v0, YZ, YZ);                   //YZ: = v0 + YZ;\n\tfp2mul751_mont(l0, YZ, YZ);           //YZ: = l0*Y_;\n\n\tfp2mul751_mont(XZ, ly, ly);           //ly: = XZ*ly;\n\tfp2mul751_mont(X2, l0, l0);           //l0: = X2*l0;\n\tfp2mul751_mont(XZ, v0, v0);           //v0: = XZ*v0;\n\n\tfp2copy751(XX2, X2);\n\tfp2copy751(t0, XZ);\n}\n\nstatic void absorb_line(const f2elm_t lx, const f2elm_t ly, const f2elm_t l0, const f2elm_t v0, const point_t P, f2elm_t n, f2elm_t d)\n{ // Absorbing line function values during Miller's algorithm.\n  // Evaluate the line functions at the point P and multiply values into the running value n/d of the pairing value, keeping numerator n\n  // and denominator d separate.\n\tfelm_t *x = (felm_t*)P->x, *y = (felm_t*)P->y;\n\tf2elm_t l, v;\n\n\tfp2mul751_mont(lx, x, l);                        // l = lx*x\n\tfp2mul751_mont(ly, y, v);                        // v = ly*y\n\tfp2sub751(v, l, l);                              // l = v-l\n\tfp2add751(l0, l, l);                             // l = l+l0\n\tfp2mul751_mont(ly, x, v);                        // v = ly*x\n\tfp2sub751(v, v0, v);                             // v = v+v0\n\tfp2mul751_mont(n, l, n);                         // n = n*l\n\tfp2mul751_mont(d, v, d);                         // d = d*v\n}\n\n\nstatic void square_and_absorb_line(const f2elm_t lx, const f2elm_t ly, const f2elm_t l0, const f2elm_t v0, const point_t P, f2elm_t n, f2elm_t d)\n{ // Square the running pairing value in Miller's algorithm and absorb line function values of the current Miller step.\n\tfp2sqr751_mont(n, n);                            // n = n^2\n\tfp2sqr751_mont(d, d);                            // d = d^2\n\tabsorb_line(lx, ly, l0, v0, P, n, d);\n}\n\n\nstatic void final_dbl_iteration(const point_ext_proj_t P, const f2elm_t x, f2elm_t n, f2elm_t d)\n{ // Special iteration for the final doubling step in Miller's algorithm. This is necessary since the doubling \n  // at the end of the Miller loop is an exceptional case (doubling a point of order 2).\n\tfelm_t *X = (felm_t*)P->XZ, *Z = (felm_t*)P->Z2;\n\tf2elm_t l;\n\n\tfp2sqr751_mont(n, n);                            // n = n^2\n\tfp2sqr751_mont(d, d);                            // d = d^2\n\tfp2mul751_mont(Z, d, d);                         // d = d*Z\n\tfp2mul751_mont(Z, x, l);                         // l = Z*x\n\tfp2sub751(l, X, l);                              // l = l-X\n\tfp2mul751_mont(n, l, n);                         // n = n*l\n}\n\n\nstatic void final_exponentiation_2_torsion(f2elm_t n, f2elm_t d, const f2elm_t n_inv, const f2elm_t d_inv, f2elm_t nout, PCurveIsogenyStruct CurveIsogeny)\n{ // The final exponentiation for pairings in the 2-torsion group. Raising the value n/d to the power (p^2-1)/2^eA.\n    felm_t one = {0};\n    unsigned int i; \n\n    fpcopy751(CurveIsogeny->Montgomery_one, one);\n    fp2mul751_mont(n, d_inv, n);                     // n = n*d_inv\n    //n = n^p, just call conjugation function\n    inv_Fp2_cycl(n);\n    fp2mul751_mont(d, n_inv, d);                     // d = d*n_inv\n    fp2mul751_mont(n, d, n);                         // n = n*d\n\n    for (i = 0; i < 239; i++) {\n        cube_Fp2_cycl(n, one);\n    }\n    fp2copy751(n, nout);\n}\n\n\nvoid Tate_pairings_2_torsion(const point_t R1, const point_t R2, const point_t P, const point_t Q, const f2elm_t A, f2elm_t* n, PCurveIsogenyStruct CurveIsogeny)\n{ // The doubling only 2-torsion Tate pairing of order 2^eA, consisting of the doubling only Miller loop and the final exponentiation.]\n  // Computes 5 pairings at once: e(R1, R2), e(R1, P), e(R1, Q), e(R2, P), e(R2,Q).\n\tpoint_ext_proj_t P1 = { 0 }, P2 = { 0 };\n\tf2elm_t lx1, ly1, l01, v01, lx2, ly2, l02, v02;\n\tf2elm_t invs[10], nd[10] = { 0 };\n\tfelm_t one = { 0 };\n\tunsigned int i;\n\n\tfpcopy751(CurveIsogeny->Montgomery_one, one);\n\tfp2copy751(R1->x, P1->XZ);\n\tfp2sqr751_mont(P1->XZ, P1->X2);\n\tfp2copy751(R1->y, P1->YZ);\n\tfpcopy751(one, P1->Z2[0]);                       // P1 = (x1^2,x1,1,y1)    \n\tfp2copy751(R2->x, P2->XZ);\n\tfp2sqr751_mont(P2->XZ, P2->X2);\n\tfp2copy751(R2->y, P2->YZ);\n\tfpcopy751(one, P2->Z2[0]);                       // P2 = (x2^2,x2,1,y2)\n\n\tfor (i = 0; i < 10; i++) {                       // nd[i] = 1\n\t\tfpcopy751(one, nd[i][0]);\n\t}\n\n\tfor (i = 0; i < 371; i++) {\n\t\tdbl_and_line(P1, A, lx1, ly1, l01, v01); // vx = ly\n\t\tdbl_and_line(P2, A, lx2, ly2, l02, v02); // vx = ly\n\t\tsquare_and_absorb_line(lx1, ly1, l01, v01, R2, nd[0], nd[5]);\n\t\tsquare_and_absorb_line(lx1, ly1, l01, v01, P, nd[1], nd[6]);\n\t\tsquare_and_absorb_line(lx1, ly1, l01, v01, Q, nd[2], nd[7]);\n\t\tsquare_and_absorb_line(lx2, ly2, l02, v02, P, nd[3], nd[8]);\n\t\tsquare_and_absorb_line(lx2, ly2, l02, v02, Q, nd[4], nd[9]);\n\t}\n\n\tfinal_dbl_iteration(P1, R2->x, nd[0], nd[5]);\n\tfinal_dbl_iteration(P1, P->x, nd[1], nd[6]);\n\tfinal_dbl_iteration(P1, Q->x, nd[2], nd[7]);\n\tfinal_dbl_iteration(P2, P->x, nd[3], nd[8]);\n\tfinal_dbl_iteration(P2, Q->x, nd[4], nd[9]);\n\tmont_n_way_inv(nd, 10, invs);\n\tfinal_exponentiation_2_torsion(nd[0], nd[5], invs[0], invs[5], n[0], CurveIsogeny);\n\tfinal_exponentiation_2_torsion(nd[1], nd[6], invs[1], invs[6], n[1], CurveIsogeny);\n\tfinal_exponentiation_2_torsion(nd[2], nd[7], invs[2], invs[7], n[2], CurveIsogeny);\n\tfinal_exponentiation_2_torsion(nd[3], nd[8], invs[3], invs[8], n[3], CurveIsogeny);\n\tfinal_exponentiation_2_torsion(nd[4], nd[9], invs[4], invs[9], n[4], CurveIsogeny);\n}\n\n\nstatic void tpl_and_parabola(point_ext_proj_t P, const f2elm_t A, f2elm_t ly, f2elm_t lx2, f2elm_t lx1, f2elm_t lx0, f2elm_t vx, f2elm_t v0)\n{ // Tripling step for computing the Tate pairing using Miller's algorithm.\n  // This function computes a point tripling of P and returns the coefficients of the corresponding parabola.\n\tfelm_t *X2 = (felm_t*)P->X2, *XZ = (felm_t*)P->XZ, *YZ = (felm_t*)P->YZ, *Z2 = (felm_t*)P->Z2;\n    f2elm_t AXZ, t0, t1, t2, t3, t4, tlx0, tlx1, tlx2;\n\n\tfp2add751(YZ, YZ, ly);                //ly: = YZ + YZ\n\tfp2sqr751_mont(ly, tlx2);             //lx2: = ly ^ 2\n\tfp2mul751_mont(ly, tlx2, ly);         //ly: = ly*lx2\n\tfp2mul751_mont(A, XZ, AXZ);           //AXZ: = A*XZ\n\tfp2add751(AXZ, Z2, t0);               //t0: = AXZ + Z2\n\tfp2add751(t0, t0, t0);                //t0: = t0 + t0\n\tfp2add751(X2, Z2, t1);                //t1: = X2 + Z2\n\tfp2add751(X2, X2, t2);                //t2: = X2 + X2\n\tfp2sub751(X2, Z2, t3);                //t3: = X2 - Z2\n\tfp2sqr751_mont(t3, t3);               //t3: = t3 ^ 2\n\tfp2add751(t2, t0, t4);                //t4: = t2 + t0\n\tfp2mul751_mont(t2, t4, tlx2);         //lx2: = t2*t4\n\tfp2sub751(tlx2, t3, tlx2);            //lx2: = lx2 - t3\n\tfp2add751(t4, t1, tlx1);              //lx1: = t4 + t1\n\tfp2sqr751_mont(t1, t1);               //t1: = t1 ^ 2\n\tfp2mul751_mont(AXZ, tlx1, tlx1);      //lx1: = AXZ*lx1\n\tfp2add751(t1, tlx1, tlx1);            //lx1: = t1 + lx1\n\tfp2add751(tlx1, tlx1, tlx1);          //lx1: = lx1 + lx1\n\tfp2add751(t3, tlx1, tlx1);            //lx1: = t3 + lx1\n\tfp2mul751_mont(Z2, t0, tlx0);         //lx0: = Z2*t0\n\tfp2sub751(t3, tlx0, tlx0);            //lx0: = t3 - lx0\n\tfp2add751(tlx0, tlx0, tlx0);          //lx0: = lx0 + lx0\n\tfp2sub751(t1, tlx0, tlx0);            //lx0: = t1 - lx0\n\tfp2mul751_mont(Z2, tlx2, lx2);        //lx2_: = Z2*lx2\n\tfp2mul751_mont(XZ, tlx1, lx1);        //lx1_: = XZ*lx1\n\tfp2add751(lx1, lx1, lx1);             //lx1_: = lx1_ + lx1_\n\tfp2mul751_mont(X2, tlx0, lx0);        //lx0_: = X2*lx0\n\t\t\t\t\t\t\t\t\t\t  // lx2_, lx1_, lx0_ done\n\tfp2sqr751_mont(tlx2, t3);             //t3: = lx2 ^ 2\n\tfp2mul751_mont(ly, t3, t2);           //t2: = ly*t3\n\tfp2sqr751_mont(tlx0, t4);             //t4: = lx0 ^ 2\n\tfp2sqr751_mont(t4, t0);               //t0: = t4 ^ 2\n\tfp2mul751_mont(X2, t0, t0);           //t0: = X2*t0\n\tfp2mul751_mont(ly, t0, X2);           //X2_: = ly*t0\n\tfp2mul751_mont(XZ, t2, XZ);           //XZ_: = XZ*t2\n\tfp2mul751_mont(XZ, t4, XZ);           //XZ_: = XZ_*t4\n\tfp2mul751_mont(Z2, t2, Z2);           //Z2_: = Z2*t2\n\tfp2mul751_mont(Z2, t3, Z2);           //Z2_: = Z2_*t3\n\tfp2mul751_mont(tlx0, tlx1, t2);       //t2: = lx0*lx1\n\tfp2add751(t2, t2, YZ);                //YZ_: = t2 + t2\n\tfp2add751(YZ, t3, YZ);                //YZ_: = YZ_ + t3\n\tfp2mul751_mont(lx0, tlx2, t2);        //t2: = lx0_*lx2\n\tfp2mul751_mont(t2, YZ, YZ);           //YZ_: = t2*YZ_\n\tfp2add751(t0, YZ, YZ);                //YZ_: = t0 + YZ_\n\tfp2mul751_mont(lx2, YZ, YZ);          //YZ_: = lx2_*YZ_\n\tfp2neg751(YZ);                        //YZ_: = -YZ_\n\t\t\t\t\t\t\t\t\t\t  // X2_,XZ_,Z2_,YZ_ done\n\tfp2copy751(Z2, vx);                   //vx: = Z2_\n\tfp2copy751(XZ, v0);                   //v0: = -XZ_\n\tfp2neg751(v0);\n\t// vx,v0 done\n}\n\n\nstatic void absorb_parab(const f2elm_t ly, const f2elm_t lx2, const f2elm_t lx1, const f2elm_t lx0, const f2elm_t vx, const f2elm_t v0, const point_t P, f2elm_t n, f2elm_t d)\n{ // Absorbing parabola function values in Miller's algorithm.\n  // Evaluate the parabola at P and absorb the values into the running pairing value n/d, keeping numerator n and denominator d separate.\n\tfelm_t *x = (felm_t*)P->x, *y = (felm_t*)P->y;\n\tf2elm_t ln, ld;\n\n\tfp2mul751_mont(lx0, x, ln);           // ln = lx0*x\n\tfp2mul751_mont(v0, x, ld);            // ld = v0*x\n\tfp2add751(vx, ld, ld);                // ld = vx + ld\n\tfp2mul751_mont(ld, ln, ld);           // ld = ld*ln\n\tfp2mul751_mont(d, ld, d);\t\t\t  // d = d*ld\n\n\tfp2add751(lx1, ln, ln);               // ln = lx1 + ln\n\tfp2mul751_mont(x, ln, ln);            // ln = x*ln\n\tfp2mul751_mont(ly, y, ld);            // t = ly*y\n\tfp2add751(lx2, ln, ln);               // ln = lx2 + ln\n\tfp2add751(ld, ln, ln);                // ln = t + ln\n\tfp2mul751_mont(ln, v0, ln);           // ln = ln*v0\n\tfp2mul751_mont(n, ln, n);             // n = n*ln\n}\n\nstatic void cube_and_absorb_parab(const f2elm_t ly, const f2elm_t lx2, const f2elm_t lx1, const f2elm_t lx0, const f2elm_t vx, const f2elm_t v0, const point_t P, f2elm_t n, f2elm_t d)\n{ // Cube the running pairing value in Miller's algorithm and absorb parabola function values of the current Miller step.\n\tf2elm_t ln, ld;\n\n\tfp2sqr751_mont(n, ln);             // ln = n ^ 2\n\tfp2mul751_mont(n, ln, n);          // n = n*ln\n\tfp2sqr751_mont(d, ld);             // ld = d ^ 2\n\tfp2mul751_mont(d, ld, d);          // d = d*ld\n\tabsorb_parab(ly, lx2, lx1, lx0, vx, v0, P, n, d);\n}\n\nstatic void final_tpl(point_ext_proj_t P, const f2elm_t A, f2elm_t lam, f2elm_t mu, f2elm_t D)\n{ // Special iteration for the final tripling step in Miller's algorithm. This is necessary since the tripling \n  // at the end of the Miller loop is an exceptional case (tripling a point of order 3). Uses lines instead of \n  // parabolas.\n\tfelm_t *X2 = (felm_t*)P->X2, *XZ = (felm_t*)P->XZ, *YZ = (felm_t*)P->YZ, *Z2 = (felm_t*)P->Z2;\n\tf2elm_t X, Y, Z, Y2, tX2, AX2, tXZ, tAXZ;\n\n\tfp2copy751(XZ, X);\n\tfp2copy751(YZ, Y);\n\tfp2copy751(Z2, Z);\n\n\tfp2sqr751_mont(X, X2);             // X2 = X ^ 2\n\tfp2add751(X2, X2, tX2);            // tX2 = X2 + X2\n\tfp2mul751_mont(A, X2, AX2);        // AX2 = A*X2\n\tfp2mul751_mont(X, Z, XZ);          // XZ = X*Z\n\tfp2sqr751_mont(Y, Y2);             // Y2 = Y ^ 2\n\tfp2add751(XZ, XZ, tXZ);            // tXZ = XZ + XZ\n\tfp2mul751_mont(A, tXZ, tAXZ);      // tAXZ = A*tXZ\n\tfp2sqr751_mont(Z, Z2);             // Z2 = Z ^ 2\n\tfp2mul751_mont(Y, Z, YZ);          // YZ = Y*Z\n\n\tfp2add751(X2, Z2, lam);            // lambda = X2 + Z2\n\tfp2add751(lam, tX2, lam);          // lambda = lambda + tX2\n\tfp2add751(lam, tAXZ, lam);         // lambda = lambda + tAXZ\n\tfp2sub751(tXZ, Y2, mu);            // mu = tXZ - Y2\n\tfp2add751(mu, AX2, mu);            // mu = mu + AX2\n\tfp2add751(YZ, YZ, D);              // D = YZ + YZ\n}\n\nstatic void final_tpl_iteration(const f2elm_t x, const f2elm_t y, const f2elm_t lam, const f2elm_t mu, const f2elm_t D, f2elm_t n, f2elm_t d)\n{ // Special iteration for the final tripling step in Miller's algorithm. This is necessary since the tripling \n  // at the end of the Miller loop is an exceptional case (tripling a point of order 3). \n  // Cubes the running pairing value n/d and absorbs the line function values. \n\tf2elm_t ln, ld, t;\n\n\tfp2sqr751_mont(n, ln);             // ln = n ^ 2\n\tfp2mul751_mont(n, ln, n);          // n = n*ln\n\tfp2sqr751_mont(d, ld);             // ld = d ^ 2\n\tfp2mul751_mont(d, ld, d);          // d = d*ld\n\tfp2sqr751_mont(x, ld);             // ld = x ^ 2\n\tfp2mul751_mont(mu, ld, ld);        // ld = mu*ld\n\tfp2mul751_mont(lam, x, t);         // t = lambda*x\n\tfp2add751(t, ld, ln);              // ln = t + ld\n\tfp2mul751_mont(D, y, t);           // t = D*y\n\tfp2add751(t, ln, ln);              // ln = t + ln\n\tfp2mul751_mont(n, ln, n);          // n = n*ln\n\tfp2mul751_mont(d, ld, d);          // d = d*ld\n}\n\n\nstatic void final_exponentiation_3_torsion(f2elm_t n, f2elm_t d, const f2elm_t n_inv, const f2elm_t d_inv, f2elm_t nout, PCurveIsogenyStruct CurveIsogeny)\n{ // The final exponentiation for pairings in the 3-torsion group. Raising the value n/d to the power (p^2-1)/3^eB.\n\tfelm_t one = {0};\n\tunsigned int i;\n\n\tfpcopy751(CurveIsogeny->Montgomery_one, one);\n\tfp2mul751_mont(n, d_inv, n);                     // n = n*d_inv\n\t\t\t\t\t\t\t\t\t\t\t\t\t // n = n^p. Just call conjugation function\n\tinv_Fp2_cycl(n);\n\tfp2mul751_mont(d, n_inv, d);                     // d = d*n_inv\n\tfp2mul751_mont(n, d, n);                         // n = n*d\n\n\tfor (i = 0; i < 372; i++) {\n\t\tsqr_Fp2_cycl(n, one);\n\t}\n\tfp2copy751(n, nout);\n}\n\n\nvoid Tate_pairings_3_torsion(const point_t R1, const point_t R2, const point_t P, const point_t Q, const f2elm_t A, f2elm_t* n, PCurveIsogenyStruct CurveIsogeny)\n{ // The tripling only 3-torsion Tate pairing of order 3^eB, consisting of the tripling only Miller loop and the final exponentiation. \n  // Computes 5 pairings at once: e(R1, R2), e(R1, P), e(R1, Q), e(R2, P), e(R2,Q).\n\tpoint_ext_proj_t P1 = {0}, P2 = {0};\n\tf2elm_t ly, lx2, lx1, lx0, vx, v0, lam, mu, d;\n\tf2elm_t invs[10], nd[10] = {0};\n\tfelm_t one = {0};\n\tunsigned int i;\n\n\tfpcopy751(CurveIsogeny->Montgomery_one, one);\n\tfp2copy751(R1->x, P1->XZ);\n\tfp2sqr751_mont(P1->XZ, P1->X2);\n\tfp2copy751(R1->y, P1->YZ);\n\tfpcopy751(one, P1->Z2[0]);                       // P1 = (x1^2,x1,1,y1)    \n\tfp2copy751(R2->x, P2->XZ);\n\tfp2sqr751_mont(P2->XZ, P2->X2);\n\tfp2copy751(R2->y, P2->YZ);\n\tfpcopy751(one, P2->Z2[0]);                       // P2 = (x2^2,x2,1,y2)\n\n\tfor (i = 0; i < 10; i++) {                       // nd[i] = 1\n\t\tfpcopy751(one, nd[i][0]);\n\t}\n\n\tfor (i = 239; i >= 2; i--) {\n\t\ttpl_and_parabola(P1, A, ly, lx2, lx1, lx0, vx, v0);\n\t\tcube_and_absorb_parab(ly, lx2, lx1, lx0, vx, v0, R2, nd[0], nd[5]);\n\t\tcube_and_absorb_parab(ly, lx2, lx1, lx0, vx, v0, P, nd[1], nd[6]);\n\t\tcube_and_absorb_parab(ly, lx2, lx1, lx0, vx, v0, Q, nd[2], nd[7]);\n\t\ttpl_and_parabola(P2, A, ly, lx2, lx1, lx0, vx, v0);\n\t\tcube_and_absorb_parab(ly, lx2, lx1, lx0, vx, v0, P, nd[3], nd[8]);\n\t\tcube_and_absorb_parab(ly, lx2, lx1, lx0, vx, v0, Q, nd[4], nd[9]);\n\t}\n\n\tfinal_tpl(P1, A, lam, mu, d);\n\tfinal_tpl_iteration(R2->x, R2->y, lam, mu, d, nd[0], nd[5]);\n\tfinal_tpl_iteration(P->x, P->y, lam, mu, d, nd[1], nd[6]);\n\tfinal_tpl_iteration(Q->x, Q->y, lam, mu, d, nd[2], nd[7]);\n\tfinal_tpl(P2, A, lam, mu, d);\n\tfinal_tpl_iteration(P->x, P->y, lam, mu, d, nd[3], nd[8]);\n\tfinal_tpl_iteration(Q->x, Q->y, lam, mu, d, nd[4], nd[9]);\n\n\tmont_n_way_inv(nd, 10, invs);\n\tfinal_exponentiation_3_torsion(nd[0], nd[5], invs[0], invs[5], n[0], CurveIsogeny);\n\tfinal_exponentiation_3_torsion(nd[1], nd[6], invs[1], invs[6], n[1], CurveIsogeny);\n\tfinal_exponentiation_3_torsion(nd[2], nd[7], invs[2], invs[7], n[2], CurveIsogeny);\n\tfinal_exponentiation_3_torsion(nd[3], nd[8], invs[3], invs[8], n[3], CurveIsogeny);\n\tfinal_exponentiation_3_torsion(nd[4], nd[9], invs[4], invs[9], n[4], CurveIsogeny);\n}\n\n\nvoid phn1(const f2elm_t q, const f2elm_t* LUT, const uint64_t a, const felm_t one, uint64_t* alpha_i)\n{ // Pohlig-Hellman for groups of 2-power order up to 2^6\n  // This function solves the DLP in a subgroup of Fp2* of order 2^a, where a <= 6.\n  // The DL is returned in alpha which only needs a bits to store the result.\n    f2elm_t u, v, tmp;\n    felm_t zero = {0};\n    uint64_t l, h;\n\n    fp2copy751(q, u);                     // u = q\n    *alpha_i = 0;\n    for (l = 0; l < a-1; l++) {  \n        fp2copy751(u, v);                 // v = u\n        for (h = 1; h < (a-l); h++) { \n            sqr_Fp2_cycl(v, one); \n        }\n\t\tfp2correction751(v);\n        if (fpequal751_non_constant_time(v[0], one) == false || fpequal751_non_constant_time(v[1], zero) == false) {\n            *alpha_i += ((uint64_t)1 << l);\n            fp2copy751(LUT[6-a+l], tmp);  // tmp = LUT[6-a+l];\n            fp2mul751_mont(u, tmp, u); \n        }\n    }\n\tfp2correction751(u);\n\tif (fpequal751_non_constant_time(u[0], one) == false || fpequal751_non_constant_time(u[1], zero) == false) {\n\t\t*alpha_i += ((uint64_t)1 << (a-1));\n\t}\n}\n\n\nvoid phn5(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k)\n{ // Pohlig-Hellman for groups of 2-power order 2^21\n    f2elm_t u, v, tmp;\n    felm_t zero = {0};\n    uint64_t alpha_i;\n    uint64_t i, j;\n\n    *alpha_k = 0;\n\tfp2copy751(q, u); \n\tfor (i = 0; i < 4; i++) {\n\t\tfp2copy751(u, v);\n\t\tsqr_Fp2_cycl(v, one);\n\t\tfor (j = 0; j < (5 * (3 - i)); j++) { \n\t\t\tsqr_Fp2_cycl(v, one);\n\t\t}\n\t\tphn1(v, LUT, 5, one, &alpha_i);      // u order 2^5\n\t\t*alpha_k += (alpha_i << (5 * i));\n\t\texp6_Fp2_cycl(LUT_1[i], alpha_i, one, tmp);       \n\t\tfp2mul751_mont(u, tmp, u);\n\t}\n\tfp2correction751(u);\n    // Do the last part\n\tif (fpequal751_non_constant_time(u[0], one) == false || fpequal751_non_constant_time(u[1], zero) == false) { // q order 2\n\t\t*alpha_k += ((uint64_t)1 << 20);\n\t} \n}\n\n\nvoid phn21(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k)\n{ // Pohlig-Hellman for groups of 2-power order 2^84 \n    f2elm_t u, v, tmp;\n    uint64_t alpha_i;\n    uint64_t i, j;\n\n\n    alpha_k[0] = 0;\n\talpha_k[1] = 0;\n\tfp2copy751(q, u);\n    for (i = 0; i < 3; i++) {\n        fp2copy751(u, v);\n        for (j = 0; j < 21*(3-i); j++) {          \n            sqr_Fp2_cycl(v, one); \n        }\n        phn5(v, LUT, LUT_1, one, &alpha_i);      // u order 2^21\n        alpha_k[0] += (alpha_i << (21*i));\n        exp21_Fp2_cycl(LUT_0[i], alpha_i, one, tmp); \n        fp2mul751_mont(u, tmp, u);\n    }\n\tphn5(u, LUT, LUT_1, one, &alpha_i);      // u order 2^21\n\talpha_k[0] += (alpha_i << 63);\n\talpha_k[1] = (alpha_i >> 1);\n}\n\n\nvoid phn84(f2elm_t r, const f2elm_t* t_ori, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const f2elm_t* LUT_3, const felm_t one, uint64_t* alpha)\n{ // Pohlig-Hellman for groups of 2-power order 2^372                                                                                                                                                                                 \n    f2elm_t u, q, t, tmp;\n    uint64_t alpha_k[2], alpha_i, mask;\n    uint64_t i, j, k;\n\n\tfor (i = 0; i < NWORDS64_ORDER; i++) alpha[i] = 0;\n    fp2copy751(r, t);\n    for (k = 0; k < 4; k++) {\n\t\tfp2copy751(t, q);\n        for (j = 0; j < 36; j++) {\n            sqr_Fp2_cycl(q, one); \n        }\n        for (j = 0; j < 84*(3-k); j++) { \n            sqr_Fp2_cycl(q, one);\n        }\n        phn21(q, LUT, LUT_0, LUT_1, one, alpha_k);  // q order 2^84 \n        alpha[k] += (alpha_k[0] << (k*20));\n\t    mask = ((uint64_t)1 << (k * 20))-1;\n\t\talpha[k + 1] += ((alpha_k[0] >> (64 - k * 20)) & mask);\n\t\talpha[k + 1] += (alpha_k[1] << (k * 20));\n        exp84_Fp2_cycl(t_ori[k], alpha_k, one, tmp); \n        fp2mul751_mont(t, tmp, t); \n    }\n\talpha[5] = (alpha_k[1] >> 4);\n    // Do the last part\n    for (i = 0; i < 6; i++) {\n        fp2copy751(t, u);\n        for (j = 0; j < 6*(5-i); j++) {                 \n            sqr_Fp2_cycl(u, one); \n        }\n        phn1(u, LUT, 6, one, &alpha_i);      // u order 2^6\n        alpha[5] += (alpha_i << (16 + 6*i));\n        exp6_Fp2_cycl(LUT_3[i], alpha_i, one, tmp);      \n        fp2mul751_mont(t, tmp, t);\n    }\n}\n\n\nvoid build_LUTs(const f2elm_t g, f2elm_t* t_ori, f2elm_t* LUT, f2elm_t* LUT_0, f2elm_t* LUT_1, f2elm_t* LUT_3, const felm_t one)\n{ // Lookup table generation for 2-torsion PH in a group of order 2^372\n\tf2elm_t tmp;\n\tunsigned int i, j; \n\n\tfp2copy751(g, tmp);                                    // tmp = g\n\tinv_Fp2_cycl(tmp);\n\tfp2copy751(tmp, t_ori[0]);                             // t_ori[0] = g^(-1), order 2^372\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = 0; j < 84; j++) sqr_Fp2_cycl(tmp, one);\n\t\tfp2copy751(tmp, t_ori[i+1]);                       // order 2^288 & 2^204 & 2^120 \n\t}\n\tfor (i = 0; i < 36; i++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, t_ori[4]);                             // t_ori[4], order 2^84\n\t                                                       // t_ori done.\n\tfp2copy751(tmp, LUT_0[0]);                             // LUT_0[0] = t_ori[4], order 2^84\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 21; j++) sqr_Fp2_cycl(tmp, one);\n\t\tfp2copy751(tmp, LUT_0[i+1]);                       // order 2^63 & 2^42 \n\t}\n\tfor (j = 0; j < 6; j++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_3[0]);                             // LUT_3[0] = tmp, order 2^36\n\tfor (j = 0; j < 6; j++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_3[1]);                             // LUT_3[1] = tmp, order 2^30\n\tfor (j = 0; j < 6; j++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_3[2]);                             // LUT_3[2] = tmp, order 2^24\n\tfor (j = 0; j < 3; j++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_0[3]);                             // LUT_0[3] = tmp, order 2^21 \n\t                                                       // LUT_0 done.\n\tfp2copy751(tmp, LUT_1[0]);                             // LUT_1[0] = LUT_0[3], order 2^21\n\tfor (i = 0; i < 3; i++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_3[3]);                             // LUT_3[3] = tmp, order 2^18\n\tfor (i = 0; i < 2; i++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_1[1]);                             // LUT_1[1] = tmp, order 2^16\n\tfor (i = 0; i < 4; i++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_3[4]);                             // LUT_3[4] = tmp, order 2^12\n\tsqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_1[2]);                             // LUT_1[2] = tmp, order 2^11\n\tfor (i = 0; i < 5; i++) sqr_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_1[3]);                             // LUT_1[3] = tmp, order 2^16 & 2^11 & 2^6    \n\tfp2copy751(tmp, LUT_3[5]);                             // LUT_3[5] = tmp\n\t                                                       // LUT_1, LUT_3 done\n\tfp2copy751(tmp, LUT[0]);                               // LUT = LUT_3[5]\n\tfor (i = 0; i < 4; i++) {\n\t\tfp2copy751(LUT[i], LUT[i+1]);\n\t\tsqr_Fp2_cycl(LUT[i+1], one);                       // order 2^5 -- 2^1\n\t}\n}\n\n\nvoid ph2(const point_t phiP, const point_t phiQ, const point_t PS, const point_t QS, const f2elm_t A, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, PCurveIsogenyStruct CurveIsogeny)\n{ // Pohlig-Hellman function. \n  // This function computes the five pairings e(QS, PS), e(QS, phiP), e(QS, phiQ), e(PS, phiP), e(PS,phiQ),\n  // computes the lookup tables for the Pohlig-Hellman functions,\n  // and then computes the discrete logarithms of the last four pairing values to the base of the first pairing value.                                                                    \n    f2elm_t t_ori[5], n[5], LUT[5], LUT_0[4], LUT_1[4], LUT_3[6];\n    felm_t one = {0};\n    \n    fpcopy751(CurveIsogeny->Montgomery_one, one);\n\t\n\t// Compute the pairings.\n    Tate_pairings_2_torsion(QS, PS, phiP, phiQ, A, n, CurveIsogeny);\n\n\t// Build the lookup tables from element n[0] of order 2^372.\n\tbuild_LUTs(n[0], t_ori, LUT, LUT_0, LUT_1, LUT_3, one);\n\n    // Finish computation\n    phn84(n[1], t_ori, LUT, LUT_0, LUT_1, LUT_3, one, a0);\n    phn84(n[3], t_ori, LUT, LUT_0, LUT_1, LUT_3, one, b0);\n\tmp_sub(CurveIsogeny->Aorder, (digit_t*)b0, (digit_t*)b0, NWORDS_ORDER);\n    phn84(n[2], t_ori, LUT, LUT_0, LUT_1, LUT_3, one, a1);\n    phn84(n[4], t_ori, LUT, LUT_0, LUT_1, LUT_3, one, b1);\n\tmp_sub(CurveIsogeny->Aorder, (digit_t*)b1, (digit_t*)b1, NWORDS_ORDER);\n}\n\n\nstatic void recover_os(const f2elm_t X1, const f2elm_t Z1, const f2elm_t X2, const f2elm_t Z2, const f2elm_t x, const f2elm_t y, const f2elm_t A, f2elm_t X3, f2elm_t Y3, f2elm_t Z3)\n{\n    f2elm_t t0, t1, t2, t3;\n    \n    //X3 := 2*y*Z1*Z2*X1;\n    //Y3 := Z2*((X1+x*Z1+2*A*Z1)*(X1*x+Z1)-2*A*Z1^2)-(X1-x*Z1)^2*X2;\n    //Z3 := 2*y*Z1*Z2*Z1;\n    \n    fp2add751(y, y, t0);             \n    fp2mul751_mont(t0, Z1, t0);    \n    fp2mul751_mont(t0, Z2, t0);       // t0 = 2*y*Z1*Z2\n    fp2mul751_mont(t0, Z1, Z3);       // Z3 = 2*y*Z1*Z2*Z1       \n    fp2mul751_mont(t0, X1, X3);       // X3 = 2*y*Z1*Z2*X1\n    fp2add751(A, A, t0);                    \n    fp2mul751_mont(t0, Z1, t0);       // t0 = 2*A*Z1  \n    fp2mul751_mont(x, Z1, t1);        // t1 = x*Z1  \n    fp2add751(X1, t1, t2);            // t2 = X1+x*Z1\n    fp2sub751(X1, t1, t1);            // t1 = X1-x*Z1\n    fp2add751(t0, t2, t3);            // t3 = X1+x*Z1+2*A*Z1\n    fp2mul751_mont(t0, Z1, t0);       // t0 = 2*A*Z1^2 \n    fp2sqr751_mont(t1, t1);           // t1 = (X1-x*Z1)^2\n    fp2mul751_mont(x, X1, t2);        // t2 = x*X1\n    fp2add751(t2, Z1, t2);            // t2 = X1*x+Z1\n    fp2mul751_mont(t2, t3, t2);       // t2 = (X1+x*Z1+2*A*Z1)*(X1*x+Z1)\n    fp2sub751(t2, t0, t0);            // t0 = (X1+x*Z1+2*A*Z1)*(X1*x+Z1)-2*A*Z1^2\n    fp2mul751_mont(t1, X2, t1);       // t1 = (X1-x*Z1)^2*X2\n    fp2mul751_mont(t0, Z2, t0);       // t0 = Z2*[(X1+x*Z1+2*A*Z1)*(X1*x+Z1)-2*A*Z1^2]\n    fp2sub751(t0, t1, Y3);            // Y3 = Z2*[(X1+x*Z1+2*A*Z1)*(X1*x+Z1)-2*A*Z1^2] - (X1-x*Z1)^2*X2\n}\n\n\nvoid recover_y(const publickey_t PK, point_full_proj_t phiP, point_full_proj_t phiQ, point_full_proj_t phiX, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)\n{ // Recover the y-coordinates of the public key\n  // The three resulting points are (simultaneously) correct up to sign\n    f2elm_t tmp, phiXY, one = {0};\n\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    get_A(PK[0], PK[1], PK[2], A, CurveIsogeny);  // NOTE: don't have to compress this, can output in keygen\n\n    fp2add751(PK[2], A, tmp);\n    fp2mul751_mont(PK[2], tmp, tmp);\n    fp2add751(tmp, one, tmp);                 \n    fp2mul751_mont(PK[2], tmp, tmp);              // tmp = PK[2]^3+A*PK[2]^2+PK[2];\n    sqrt_Fp2(tmp, phiXY);\n    fp2copy751(PK[2], phiX->X);\n    fp2copy751(phiXY, phiX->Y);\n    fp2copy751(one, phiX->Z);                     // phiX = [PK[2],phiXY,1];\n    \n    recover_os(PK[1], one, PK[0], one, PK[2], phiXY, A, phiQ->X, phiQ->Y, phiQ->Z);      \n    fp2neg751(phiXY);\n    recover_os(PK[0], one, PK[1], one, PK[2], phiXY, A, phiP->X, phiP->Y, phiP->Z);\n}\n\n\nvoid compress_2_torsion(const unsigned char* PublicKeyA, unsigned char* CompressedPKA, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, point_t R1, point_t R2, PCurveIsogenyStruct CurveIsogeny)\n{ // 2-torsion compression                                                                          \n    point_full_proj_t P, Q, phP, phQ, phX;\n    point_t phiP, phiQ;\n    publickey_t PK;\n    digit_t* comp = (digit_t*)CompressedPKA;\n\tdigit_t inv[NWORDS_ORDER];\n    f2elm_t A, vec[4], Zinv[4];\n    digit_t tmp[2*NWORDS_ORDER];\n\n    to_fp2mont(((f2elm_t*)PublicKeyA)[0], ((f2elm_t*)&PK)[0]);    // Converting to Montgomery representation\n    to_fp2mont(((f2elm_t*)PublicKeyA)[1], ((f2elm_t*)&PK)[1]); \n    to_fp2mont(((f2elm_t*)PublicKeyA)[2], ((f2elm_t*)&PK)[2]); \n\n    recover_y(PK, phP, phQ, phX, A, CurveIsogeny);\n    generate_2_torsion_basis(A, P, Q, CurveIsogeny);\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    fp2copy751(phP->Z, vec[2]);\n    fp2copy751(phQ->Z, vec[3]);\n    mont_n_way_inv(vec, 4, Zinv);\n\n    fp2mul751_mont(P->X, Zinv[0], R1->x);\n    fp2mul751_mont(P->Y, Zinv[0], R1->y);\n    fp2mul751_mont(Q->X, Zinv[1], R2->x);\n    fp2mul751_mont(Q->Y, Zinv[1], R2->y);\n    fp2mul751_mont(phP->X, Zinv[2], phiP->x);\n    fp2mul751_mont(phP->Y, Zinv[2], phiP->y);\n    fp2mul751_mont(phQ->X, Zinv[3], phiQ->x);\n    fp2mul751_mont(phQ->Y, Zinv[3], phiQ->y);\n\n    ph2(phiP, phiQ, R1, R2, A, a0, b0, a1, b1, CurveIsogeny);\n\n    if ((a0[0] & 1) == 1) {  // Storing [b1*a0inv, a1*a0inv, b0*a0inv] and setting bit384 to 0\n        inv_mod_orderA((digit_t*)a0, inv);        \n\t\tmultiply((digit_t*)b0, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[0], NWORDS_ORDER);\n\t\tcomp[NWORDS_ORDER-1] &= (digit_t)(-1) >> 12;       // Hardcoded value\n\t\tmultiply((digit_t*)a1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[2*NWORDS_ORDER-1] &= (digit_t)(-1) >> 12;\n\t\tmultiply((digit_t*)b1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[2 * NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 12;\n    } else {  // Storing [b1*b0inv, a1*b0inv, a0*b0inv] and setting bit384 to 1\n\t\tinv_mod_orderA((digit_t*)b0, inv);\n\t\tmultiply((digit_t*)a0, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[0], NWORDS_ORDER);\n\t\tcomp[NWORDS_ORDER - 1] &= (digit_t)(-1) >> 12;     // Hardcoded value\n\t\tmultiply((digit_t*)a1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[2*NWORDS_ORDER-1] &= (digit_t)(-1) >> 12;\n\t\tmultiply((digit_t*)b1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[2 * NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 12;\n\t\tcomp[3*NWORDS_ORDER-1] |= (digit_t)1 << (sizeof(digit_t)*8 - 1);\n    }\n    \n    from_fp2mont(A, (felm_t*)&comp[3*NWORDS_ORDER]);  // Converting back from Montgomery representation\n}\n\n\nvoid phn1_3(const f2elm_t q, const f2elm_t* LUT, const uint64_t a, const felm_t one, uint64_t* alpha_i)\n{\n    f2elm_t u, v, tmp;\n    felm_t zero = {0};\n    uint64_t l, h;\n\t// Hardcoded powers of 3, 3^0 = 1, 3^1 = 3, 3^2 = 9\n\tuint64_t pow3[3] = {0x0000000000000001, 0x0000000000000003, 0x0000000000000009}; \n\n    fp2copy751(q, u);                     // u = q\n    *alpha_i = 0;\n    for (l = 0; l < a-1; l++) {  \n        fp2copy751(u, v);                 // v = u\n        for (h = 1; h < (a-l); h++) { \n            cube_Fp2_cycl(v, one); \n        }\n\t\tfp2correction751(v);\n        if (fpequal751_non_constant_time(v[0], LUT[3][0]) == true && fpequal751_non_constant_time(v[1], LUT[3][1]) == true) {\n            *alpha_i += pow3[l];\n            fp2copy751(LUT[3-a+l], tmp);  // tmp = LUT[3-a+l];\n            fp2mul751_mont(u, tmp, u); \n        } else if (fpequal751_non_constant_time(v[0], one) == false || fpequal751_non_constant_time(v[1], zero) == false) {\n\t\t\t*alpha_i += pow3[l] << 1;\n            fp2copy751(LUT[3-a+l], tmp);  // tmp = LUT[3-a+l];\n\t\t\tsqr_Fp2_cycl(tmp, one);\n            fp2mul751_mont(u, tmp, u); \n        }\n    }\n\tfp2correction751(u);\n\tif (fpequal751_non_constant_time(u[0], LUT[3][0]) == true && fpequal751_non_constant_time(u[1], LUT[3][1]) == true) {\n\t\t*alpha_i += pow3[a-1];\n\t} else if (fpequal751_non_constant_time(u[0], one) == false || fpequal751_non_constant_time(u[1], zero) == false) {\n\t\t*alpha_i += pow3[a-1] << 1;\n\t}\n}\n\n\nvoid phn3(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k)\n{\n    f2elm_t u, v, tmp;\n    uint64_t alpha_i;\n    uint64_t i, j;\n\t// Powers of 3: 3^0 = 1, 3^3 = 27, 3^6 = 729, 3^9, 3^12\n\tuint64_t pow3[5] = {0x0000000000000001, 0x000000000000001B,\n\t                    0x00000000000002D9, 0x0000000000004CE3,\n\t                    0x0000000000081BF1 };\n\n    *alpha_k = 0;\n\tfp2copy751(q, u);\n    for (i = 0; i < 4; i++) {\n        fp2copy751(u, v);\n        for (j = 0; j < 3*(4-i); j++) {       \n\t\t\tcube_Fp2_cycl(v, one);\n        }\n        phn1_3(v, LUT, 3, one, &alpha_i);      // u order 3^3\n        *alpha_k += alpha_i * pow3[i];\n        exp6_Fp2_cycl(LUT_1[i], alpha_i, one, tmp);   \n        fp2mul751_mont(u, tmp, u); \n    }\n\tphn1_3(u, LUT, 3, one, &alpha_i);      // u order 3^3\n\t*alpha_k += alpha_i * pow3[4];\n}\n\n\nvoid phn15_1(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k)\n{\n    f2elm_t u, v, tmp;\n\tuint64_t alpha_i, alpha_n[2], alpha_tmp[4];   // alpha_tmp[4] is overkill, only taking 4 since it is the result of a mp_mul with 2-word inputs.\n    uint64_t i, j;\n\t// Powers of 3: 3^0 = 1, 3^15, 3^30\n\tuint64_t pow3_15[3] = { 0x0000000000000001, 0x0000000000DAF26B, 0x0000BB41C3CA78B9 };\n\t// Powers of 3: 3^0 = 1, 3^3 = 27, 3^6\n\tuint64_t pow3_3[4] = { 0x0000000000000001, 0x000000000000001B, 0x00000000000002D9, 0x0000000000004CE3 };\n\t// Powers of 3: 3^45 split up into two words.\n\tuint64_t pow3_45[2] = { 0x275329FD09495753,  0x00000000000000A0 };\n\n    alpha_k[0] = 0;\n\talpha_k[1] = 0;\n\tfor (i = 0; i < 4; i++) alpha_tmp[i] = 0;\n\tfp2copy751(q, u);\n\tfor (i = 0; i < 3; i++) {\n        fp2copy751(u, v);\n        for (j = 0; j < 11; j++) {           \n            cube_Fp2_cycl(v, one); \n        }\n        for (j = 0; j < 15*(2-i); j++) {  \n            cube_Fp2_cycl(v, one); \n        }\n        phn3(v, LUT, LUT_1, one, &alpha_i);      // v order 3^15\n\t\tmultiply((digit_t*)&alpha_i, (digit_t*)&pow3_15[i], (digit_t*)alpha_tmp, 64/RADIX);\n\t\tmp_add((digit_t*)alpha_k, (digit_t*)alpha_tmp, (digit_t*)alpha_k, 2*64/RADIX);\n\n        fp2copy751(LUT_0[i], v);\n        for (j = 0; j < 5; j++) {           \n            cube_Fp2_cycl(v, one); \n        }\n\t\t\n        exp_Fp2_cycl(v, &alpha_i, one, tmp, 24);   \n        fp2mul751_mont(u, tmp, u);\n    }\n\n    // Do the last part\n    alpha_n[0] = 0;\n\talpha_n[1] = 0;\n\tfor (i = 0; i < 3; i++) {\n        fp2copy751(u, v);\n        for (j = 0; j < 2; j++) {           \n            cube_Fp2_cycl(v, one); \n        }\n        for (j = 0; j < 3*(2-i); j++) {       \n            cube_Fp2_cycl(v, one); \n        }\n        phn1_3(v, LUT, 3, one, &alpha_i);      // v order 3^15\n\t\talpha_n[0] += alpha_i * pow3_3[i];\n\n        fp2copy751(LUT_1[i], v);\n        for (j = 0; j < 4; j++) {           \n            cube_Fp2_cycl(v, one); \n        }\n        exp_Fp2_cycl(v, &alpha_i, one, tmp, 5);   \n        fp2mul751_mont(u, tmp, u);\n    }\n        \n    phn1_3(u, LUT, 2, one, &alpha_i);\n\talpha_n[0] += alpha_i * pow3_3[3];\n\tmultiply((digit_t*)alpha_n, (digit_t*)pow3_45, (digit_t*)alpha_tmp, 2*64/RADIX);  // Can be optimized because alpha_n is only single precision and pow3_45 is only slightly larger than 64 bits.\n\tmp_add((digit_t*)alpha_k, (digit_t*)alpha_tmp, (digit_t*)alpha_k, 2*64/RADIX);\n}\n\n\nvoid phn15(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k)\n{\n\tfelm_t zero = {0};\n\tf2elm_t u, v, tmp;\n\tuint64_t alpha_i, alpha_n[2], alpha_tmp[4];\n\tuint64_t i, j;\n\t// Powers of 3: 3^0 = 1, 3^15, 3^30\n\tuint64_t pow3_15[3] = { 0x0000000000000001, 0x0000000000DAF26B, 0x0000BB41C3CA78B9 };\n\t// Powers of 3: 3^45 split up into two words.\n\tuint64_t pow3_45[2] = { 0x275329FD09495753,  0x00000000000000A0 };\n\t// Powers of 3: 3^60 split up into two words.\n\tuint64_t pow3_60[2] = { 0xCEEDA7FE92E1F5B1,  0x0000000088F924EE };\n\tuint64_t pow3_60_2[2] = { 0x9DDB4FFD25C3EB62,  0x0000000111F249DD };\n\n\talpha_k[0] = 0;\n\talpha_k[1] = 0;\n\talpha_n[0] = 0;\n\talpha_n[1] = 0;\n\tfor (i = 0; i < 4; i++) alpha_tmp[i] = 0;\n\tfp2copy751(q, u);\n\tfor (i = 0; i < 3; i++) {\n\t\tfp2copy751(u, v);\n\t\tcube_Fp2_cycl(v, one);\n\t\tfor (j = 0; j < 15*(3-i); j++) {\n\t\t\tcube_Fp2_cycl(v, one);\n\t\t}\n\t\tphn3(v, LUT, LUT_1, one, &alpha_i);      // u order 3^15\n\n\t\tmultiply((digit_t*)&alpha_i, (digit_t*)&pow3_15[i], (digit_t*)alpha_tmp, 64/RADIX);    \n\t\tmp_add((digit_t*)alpha_k, (digit_t*)alpha_tmp, (digit_t*)alpha_k, 2*64/RADIX);\n\n\t\texp_Fp2_cycl(LUT_0[i], &alpha_i, one, tmp, 24);\n\t\tfp2mul751_mont(u, tmp, u);\n\t}\n\n\tfp2copy751(u, v);\n\tcube_Fp2_cycl(v, one);\n\tphn3(v, LUT, LUT_1, one, &alpha_n[0]);      // u order 3^15\n\n\tmultiply((digit_t*)alpha_n, (digit_t*)pow3_45, (digit_t*)alpha_tmp, 2*64/RADIX);    \n\tmp_add((digit_t*)alpha_k, (digit_t*)alpha_tmp, (digit_t*)alpha_k, 2*64/RADIX);\n\n\texp_Fp2_cycl(LUT_0[3], &alpha_n[0], one, tmp, 24);\n\tfp2mul751_mont(u, tmp, u);\n\tfp2correction751(u);\n\tif (fpequal751_non_constant_time(u[0], LUT[3][0]) == true && fpequal751_non_constant_time(u[1], LUT[3][1]) == true) {\n\t\tmp_add((digit_t*)alpha_k, (digit_t*)pow3_60, (digit_t*)alpha_k, 2*64/RADIX);\n\t} else if (fpequal751_non_constant_time(u[0], one) == false || fpequal751_non_constant_time(u[1], zero) == false) {\n\t\tmp_add((digit_t*)alpha_k, (digit_t*)pow3_60_2, (digit_t*)alpha_k, 2*64/RADIX);\n\t}\n}\n\n\nvoid phn61(f2elm_t r, f2elm_t* t_ori, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha)\n{                                                                                                                                                                                 \n    f2elm_t u, v, tmp;\n    uint64_t alpha_k[5] = {0}, alpha_tmp[10] = {0};\n    uint64_t i, k;\n\n\tuint64_t pow3_61[13] = { 0x0000000000000001, 0x0000000000000000,     // 3^0 = 1\n\t\t                     0x6CC8F7FBB8A5E113, 0x000000019AEB6ECC,     // 3^61\n\t\t                     0x6878E44938606769, 0xD73A1059B8013933,     // 3^(2*61)\n\t                         0x9396F76B67B7C403, 0x0000000000000002,\n\t\t                     0x25A79F6508B7F5CB, 0x05515FED4D025D6F,     // 3^(3*61)\n\t\t                     0x37E2AD6FF9936EA9, 0xB69B5308880B15B6, \n\t\t                     0x0000000422BE6150 };\n\n\tfor (i = 0; i < NWORDS64_ORDER; i++) alpha[i] = 0;\n\n    fp2copy751(r, u);\n    for (k = 0; k < 2; k++) {\n        fp2copy751(u, v);\n        for (i = 0; i < 56; i++) {\n            cube_Fp2_cycl(v, one); \n        }\n        for (i = 0; i < 61*(2-k); i++) {          \n            cube_Fp2_cycl(v, one);\n        }\n        phn15(v, LUT, LUT_0, LUT_1, one, alpha_k);  // q order 3^61\n\t\tmultiply((digit_t*)alpha_k, (digit_t*)&pow3_61[2*k], (digit_t*)alpha_tmp, 2*64/RADIX);    \n\t\tmp_add((digit_t*)alpha, (digit_t*)alpha_tmp, (digit_t*)alpha, 4*64/RADIX);\n\n        exp_Fp2_cycl(t_ori[k], alpha_k, one, tmp, 97);                            \n        fp2mul751_mont(u, tmp, u); \n    }\n\tfp2copy751(u, v);\n\tfor (i = 0; i < 56; i++) {\n\t\tcube_Fp2_cycl(v, one);\n\t}\n\tphn15(v, LUT, LUT_0, LUT_1, one, alpha_k);  // q order 3^61\n\tmultiply((digit_t*)alpha_k, (digit_t*)&pow3_61[4], (digit_t*)alpha_tmp, 4*64/RADIX);    \n\tmp_add((digit_t*)alpha, (digit_t*)alpha_tmp, (digit_t*)alpha, NWORDS_ORDER);\n\n\texp_Fp2_cycl(t_ori[2], alpha_k, one, tmp, 97);\n\tfp2mul751_mont(u, tmp, u);\n    phn15_1(u, LUT, LUT_0, LUT_1, one, alpha_k);  // q order 3^56\n\tmultiply((digit_t*)alpha_k, (digit_t*)&pow3_61[8], (digit_t*)alpha_tmp, 5*64/RADIX);    \n\tmp_add((digit_t*)alpha, (digit_t*)alpha_tmp, (digit_t*)alpha, NWORDS_ORDER);    \n}\n\n\nvoid build_LUTs_3(f2elm_t g, f2elm_t* t_ori, f2elm_t* LUT, f2elm_t* LUT_0, f2elm_t* LUT_1, const felm_t one)\n{ // Lookup table generation for 3-torsion PH\n\tf2elm_t tmp;\n\tunsigned int i, j;\n\n\t// Build (small) tables\n\tfp2copy751(g, tmp);\n\tinv_Fp2_cycl(tmp);\n\tfp2copy751(tmp, t_ori[0]);                              // t_ori[0] = g^(-1)\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 61; j++) cube_Fp2_cycl(tmp, one);\n\t\tfp2copy751(tmp, t_ori[i + 1]);\n\t}\n\tfor (i = 0; i < 56; i++) cube_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, t_ori[3]);                                            \n\tfp2copy751(tmp, LUT_0[0]);\n\tfor (i = 0; i < 5; i++) cube_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, t_ori[4]);                              // t_ori done.\n\n\tfor (i = 0; i < 10; i++) cube_Fp2_cycl(tmp, one);\n    fp2copy751(tmp, LUT_0[1]);\n\tfor (i = 1; i < 3; i++) {\n\t\tfor (j = 0; j < 15; j++) cube_Fp2_cycl(tmp, one);\n        fp2copy751(tmp, LUT_0[i+1]);\n\t}\n\tcube_Fp2_cycl(tmp, one);\n\tfp2copy751(tmp, LUT_1[0]);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < 3; j++) cube_Fp2_cycl(tmp, one);\n\t\tfp2copy751(tmp, LUT_1[i+1]);\n\t}\n\tfp2copy751(tmp, LUT[0]);\n\tfor (i = 0; i < 2; i++) {\n\t\tfp2copy751(LUT[i], LUT[i+1]);\n\t\tcube_Fp2_cycl(LUT[i+1], one);\n\t}\n\tfp2copy751(LUT[2], LUT[3]);\n\tinv_Fp2_cycl(LUT[3]);\n\tfp2correction751(LUT[3]);\n}\n\n\nvoid ph3(point_t phiP, point_t phiQ, point_t PS, point_t QS, f2elm_t A, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, PCurveIsogenyStruct CurveIsogeny)\n{ // 3-torsion Pohlig-Hellman function\n  // This function computes the five pairings e(QS, PS), e(QS, phiP), e(QS, phiQ), e(PS, phiP), e(PS,phiQ),\n  // computes the lookup tables for the Pohlig-Hellman functions,\n  // and then computes the discrete logarithms of the last four pairing values to the base of the first pairing value.                                                                 \n    f2elm_t t_ori[5], n[5], LUT[4], LUT_0[4], LUT_1[5];\n    felm_t one = {0};\n\n    fpcopy751(CurveIsogeny->Montgomery_one, one);\n\n\t// Compute the pairings\n    Tate_pairings_3_torsion(QS, PS, phiP, phiQ, A, n, CurveIsogeny);\n\n\t// Build the look-up tables\n\tbuild_LUTs_3(n[0], t_ori, LUT, LUT_0, LUT_1, one);\n\n    // Finish computation\n    phn61(n[1], t_ori, LUT, LUT_0, LUT_1, one, a0);\n    phn61(n[3], t_ori, LUT, LUT_0, LUT_1, one, b0);\n\tmp_sub(CurveIsogeny->Border, (digit_t*)b0, (digit_t*)b0, NWORDS_ORDER);\n    phn61(n[2], t_ori, LUT, LUT_0, LUT_1, one, a1);\n    phn61(n[4], t_ori, LUT, LUT_0, LUT_1, one, b1);\n\tmp_sub(CurveIsogeny->Border, (digit_t*)b1, (digit_t*)b1, NWORDS_ORDER);\n}\n\n\nunsigned int mod3(digit_t* a) \n{ // Computes the input modulo 3\n  // The input is assumed to be NWORDS_ORDER long \n    digit_t temp;\n    hdigit_t *val = (hdigit_t*)a, r = 0;\n    int i;\n\n    for (i = (2*NWORDS_ORDER-1); i >= 0; i--) {\n        temp = ((digit_t)r << (sizeof(hdigit_t)*8)) | (digit_t)val[i];\n        r = temp % 3;\n    }\n\n    return r;\n}\n\n\nvoid compress_3_torsion(const unsigned char* pPublicKeyB, unsigned char* CompressedPKB, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, point_t R1, point_t R2, PCurveIsogenyStruct CurveIsogeny)\n{ // 3-torsion compression function                                                                          \n    point_full_proj_t P, Q, phP, phQ, phX;\n    point_t phiP, phiQ;\n    publickey_t PK;\n    digit_t* comp = (digit_t*)CompressedPKB;\n\tdigit_t inv[NWORDS_ORDER];\n    f2elm_t A, vec[4], Zinv[4];\n    uint64_t Montgomery_Rprime[NWORDS64_ORDER] = {0x1A55482318541298, 0x070A6370DFA12A03, 0xCB1658E0E3823A40, 0xB3B7384EB5DEF3F9, 0xCBCA952F7006EA33, 0x00569EF8EC94864C}; // Value (2^384)^2 mod 3^239\n    uint64_t Montgomery_rprime[NWORDS64_ORDER] = {0x48062A91D3AB563D, 0x6CE572751303C2F5, 0x5D1319F3F160EC9D, 0xE35554E8C2D5623A, 0xCA29300232BC79A5, 0x8AAD843D646D78C5}; // Value -(3^239)^-1 mod 2^384\n    unsigned int bit;\n\n    to_fp2mont(((f2elm_t*)pPublicKeyB)[0], ((f2elm_t*)&PK)[0]);    // Converting to Montgomery representation\n    to_fp2mont(((f2elm_t*)pPublicKeyB)[1], ((f2elm_t*)&PK)[1]); \n    to_fp2mont(((f2elm_t*)pPublicKeyB)[2], ((f2elm_t*)&PK)[2]); \n\n    recover_y(PK, phP, phQ, phX, A, CurveIsogeny);\n    generate_3_torsion_basis(A, P, Q, CurveIsogeny);\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    fp2copy751(phP->Z, vec[2]);\n    fp2copy751(phQ->Z, vec[3]);\n    mont_n_way_inv(vec, 4, Zinv);\n\n    fp2mul751_mont(P->X, Zinv[0], R1->x);\n    fp2mul751_mont(P->Y, Zinv[0], R1->y);\n    fp2mul751_mont(Q->X, Zinv[1], R2->x);\n    fp2mul751_mont(Q->Y, Zinv[1], R2->y);\n    fp2mul751_mont(phP->X, Zinv[2], phiP->x);\n    fp2mul751_mont(phP->Y, Zinv[2], phiP->y);\n    fp2mul751_mont(phQ->X, Zinv[3], phiQ->x);\n    fp2mul751_mont(phQ->Y, Zinv[3], phiQ->y);\n\n    ph3(phiP, phiQ, R1, R2, A, a0, b0, a1, b1, CurveIsogeny);\n    \n    bit = mod3((digit_t*)a0);\n    to_Montgomery_mod_order((digit_t*)a0, (digit_t*)a0, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);    // Converting to Montgomery representation\n    to_Montgomery_mod_order((digit_t*)a1, (digit_t*)a1, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n    to_Montgomery_mod_order((digit_t*)b0, (digit_t*)b0, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);  \n    to_Montgomery_mod_order((digit_t*)b1, (digit_t*)b1, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n    \n    if (bit != 0) {  // Storing [b1*a0inv, a1*a0inv, b0*a0inv] and setting bit384 to 0               \n        Montgomery_inversion_mod_order_bingcd((digit_t*)a0, inv, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);\n        Montgomery_multiply_mod_order((digit_t*)b0, inv, &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order((digit_t*)a1, inv, &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order((digit_t*)b1, inv, &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[0], &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);                           // Converting back from Montgomery representation\n        from_Montgomery_mod_order(&comp[NWORDS_ORDER], &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[2*NWORDS_ORDER], &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);\n        comp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 1;\n    } else {  // Storing [b1*b0inv, a1*b0inv, a0*b0inv] and setting bit384 to 1\n        Montgomery_inversion_mod_order_bingcd((digit_t*)b0, inv, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);         \n        Montgomery_multiply_mod_order((digit_t*)a0, inv, &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order((digit_t*)a1, inv, &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order((digit_t*)b1, inv, &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[0], &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);                           // Converting back from Montgomery representation \n        from_Montgomery_mod_order(&comp[NWORDS_ORDER], &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[2*NWORDS_ORDER], &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);\n        comp[3*NWORDS_ORDER-1] |= (digit_t)1 << (sizeof(digit_t)*8 - 1);\n    }\n    \n    from_fp2mont(A, (felm_t*)&comp[3*NWORDS_ORDER]);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////             FUNCTIONS FOR DECOMPRESSION             ///////////////\n\nvoid ADD(const point_full_proj_t P, const f2elm_t QX, const f2elm_t QY, const f2elm_t QZ, const f2elm_t A, point_full_proj_t R)\n{ // General addition.\n  // Input: projective Montgomery points P=(XP:YP:ZP) and Q=(XQ:YQ:ZQ).\n  // Output: projective Montgomery point R <- P+Q = (XQP:YQP:ZQP). \n    f2elm_t t0, t1, t2, t3, t4, t5, t6, t7;\n\n\tfp2mul751_mont(QX, P->Z, t0);            // t0 = x2*Z1    \n\tfp2mul751_mont(P->X, QZ, t1);            // t1 = X1*z2    \n\tfp2add751(t0, t1, t2);                   // t2 = t0 + t1\n\tfp2sub751(t1, t0, t3);                   // t3 = t1 - t0\n\tfp2mul751_mont(QX, P->X, t0);            // t0 = x2*X1    \n\tfp2mul751_mont(P->Z, QZ, t1);            // t1 = Z1*z2\n\tfp2add751(t0, t1, t4);                   // t4 = t0 + t1\n\tfp2mul751_mont(t0, A, t0);               // t0 = t0*A\n\tfp2mul751_mont(QY, P->Y, t5);            // t5 = y2*Y1\n\tfp2sub751(t0, t5, t0);                   // t0 = t0 - t5\n\tfp2mul751_mont(t0, t1, t0);              // t0 = t0*t1\n\tfp2add751(t0, t0, t0);                   // t0 = t0 + t0\n\tfp2mul751_mont(t2, t4, t5);              // t5 = t2*t4\n\tfp2add751(t5, t0, t5);                   // t5 = t5 + t0\n\tfp2sqr751_mont(P->X, t0);                // t0 = X1 ^ 2\n\tfp2sqr751_mont(P->Z, t6);                // t6 = Z1 ^ 2\n\tfp2add751(t0, t6, t0);                   // t0 = t0 + t6\n\tfp2add751(t1, t1, t1);                   // t1 = t1 + t1\n\tfp2mul751_mont(QY, P->X, t7);            // t7 = y2*X1\n\tfp2mul751_mont(QX, P->Y, t6);            // t6 = x2*Y1\n\tfp2sub751(t7, t6, t7);                   // t7 = t7 - t6\n\tfp2mul751_mont(t1, t7, t1);              // t1 = t1*t7\n\tfp2mul751_mont(A, t2, t7);               // t7 = A*t2\n\tfp2add751(t7, t4, t4);                   // t4 = t4 + t7\n\tfp2mul751_mont(t1, t4, t4);              // t4 = t1*t4\n\tfp2mul751_mont(QY, QZ, t1);              // t1 = y2*z2\n\tfp2mul751_mont(t0, t1, t0);              // t0 = t0*t1\n\tfp2sqr751_mont(QZ, t1);                  // t1 = z2 ^ 2\n\tfp2sqr751_mont(QX, t6);                  // t6 = x2 ^ 2\n\tfp2add751(t1, t6, t1);                   // t1 = t1 + t6\n\tfp2mul751_mont(P->Z, P->Y, t6);          // t6 = Z1*Y1\n\tfp2mul751_mont(t1, t6, t1);              // t1 = t1*t6\n\tfp2sub751(t0, t1, t0);                   // t0 = t0 - t1\n\tfp2mul751_mont(t2, t0, t0);              // t0 = t2*t0\n\tfp2mul751_mont(t5, t3, R->X);            // X3 = t5*t3\n\tfp2add751(t4, t0, R->Y);                 // Y3 = t4 + t0\n\tfp2sqr751_mont(t3, t0);                  // t0 = t3 ^ 2\n\tfp2mul751_mont(t3, t0, R->Z);            // Z3 = t3*t0\n\n}\n\n\nvoid Mont_ladder(const f2elm_t x, const digit_t* m, point_proj_t P, point_proj_t Q, const f2elm_t A24, const unsigned int order_bits, const unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny)\n{ // The Montgomery ladder, running in non constant-time\n  // Inputs: the affine x-coordinate of a point P on E: B*y^2=x^3+A*x^2+x, \n  //         scalar m\n  //         curve constant A24 = (A+2)/4\n  //         order_bits = subgroup order bitlength\n  //         order_fullbits = smallest multiple of 32 larger than the order bitlength\n  // Output: P = m*(x:1)\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\n    unsigned int bit = 0, owords = NBITS_TO_NWORDS(order_fullbits);\n    digit_t scalar[NWORDS_ORDER];\n    digit_t mask;\n    int i;\n\n    // Initializing with the points (1:0) and (x:1)\n    fpcopy751(CurveIsogeny->Montgomery_one, (digit_t*)P->X[0]);\n    fpzero751(P->X[1]);\n    fp2zero751(P->Z);\n    fp2copy751(x, Q->X);\n    fpcopy751(CurveIsogeny->Montgomery_one, (digit_t*)Q->Z[0]);\n    fpzero751(Q->Z[1]);\n\n    for (i = NWORDS_ORDER-1; i >= 0; i--) {\n        scalar[i] = m[i];\n    }\n\n    for (i = order_fullbits-order_bits; i > 0; i--) {\n        mp_shiftl1(scalar, owords);\n    }\n        \n    for (i = order_bits; i > 0; i--) {\n        bit = (unsigned int)(scalar[owords-1] >> (RADIX-1));\n        mp_shiftl1(scalar, owords);\n        mask = 0-(digit_t)bit;\n\n        swap_points(P, Q, mask);\n        xDBLADD(P, Q, x, A24);                     // If bit=0 then P <- 2*P and Q <- P+Q, \n        swap_points(P, Q, mask);                   // else if bit=1 then Q <- 2*Q and P <- P+Q\n    }\n}\n\n\nvoid mont_twodim_scalarmult(digit_t* a, const point_t R, const point_t S, const f2elm_t A, const f2elm_t A24, point_full_proj_t P, PCurveIsogenyStruct CurveIsogeny)\n{ // Computes R+aS\n    point_proj_t P0, P1;\n    point_full_proj_t P2;\n    f2elm_t one = {0};\n\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    Mont_ladder(S->x, a, P0, P1, A24, CurveIsogeny->oBbits, CurveIsogeny->owordbits, CurveIsogeny);  // Hardwired to oBbits\n    recover_os(P0->X, P0->Z, P1->X, P1->Z, S->x, S->y, A, P2->X, P2->Y, P2->Z); \n    ADD(P2, R->x, R->y, one, A, P);\n}\n\n\nvoid decompress_2_torsion(const unsigned char* SecretKey, const unsigned char* CompressedPKB, point_proj_t R, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)\n{ // 2-torsion decompression function                                                                          \n    point_t R1, R2;\n    point_full_proj_t P, Q;\n    digit_t* comp = (digit_t*)CompressedPKB;\n    f2elm_t A24, vec[2], invs[2], one = {0};\n    digit_t tmp1[2*NWORDS_ORDER], tmp2[2*NWORDS_ORDER], vone[2*NWORDS_ORDER] = {0}, mask = (digit_t)(-1);\n    unsigned int bit;\n\n    mask >>= (CurveIsogeny->owordbits - CurveIsogeny->oAbits);  \n    vone[0] = 1;\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    to_fp2mont((felm_t*)&comp[3*NWORDS_ORDER], A);    // Converting to Montgomery representation\n    generate_2_torsion_basis(A, P, Q, CurveIsogeny);\n\n    // normalize basis points\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    mont_n_way_inv(vec, 2, invs);\n    fp2mul751_mont(P->X, invs[0], R1->x);\n    fp2mul751_mont(P->Y, invs[0], R1->y);\n    fp2mul751_mont(Q->X, invs[1], R2->x);\n    fp2mul751_mont(Q->Y, invs[1], R2->y);\n\n    fp2add751(A, one, A24);\n    fp2add751(A24, one, A24);\n    fp2div2_751(A24, A24);\n    fp2div2_751(A24, A24);\n\n    bit = comp[3*NWORDS_ORDER-1] >> (sizeof(digit_t)*8 - 1);   \n    comp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 1;\n\n    if (bit == 0) {\n\t\tmultiply((digit_t*)SecretKey, &comp[NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(tmp1, vone, tmp1, NWORDS_ORDER);\n\t\ttmp1[NWORDS_ORDER-1] &= mask;\n        inv_mod_orderA(tmp1, tmp2);  \n\t\tmultiply((digit_t*)SecretKey, &comp[2*NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(&comp[0], tmp1, tmp1, NWORDS_ORDER);  \n\t\tmultiply(tmp1, tmp2, vone, NWORDS_ORDER);  \n\t\tvone[NWORDS_ORDER-1] &= mask;  \n        mont_twodim_scalarmult(vone, R1, R2, A, A24, P, CurveIsogeny);\n    } else {\n\t\tmultiply((digit_t*)SecretKey, &comp[2*NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(tmp1, vone, tmp1, NWORDS_ORDER);\n\t\ttmp1[NWORDS_ORDER-1] &= mask;\n        inv_mod_orderA(tmp1, tmp2);  \n\t\tmultiply((digit_t*)SecretKey, &comp[NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(&comp[0], tmp1, tmp1, NWORDS_ORDER);  \n\t\tmultiply(tmp1, tmp2, vone, NWORDS_ORDER);  \n\t\tvone[NWORDS_ORDER-1] &= mask;   \n        mont_twodim_scalarmult(vone, R2, R1, A, A24, P, CurveIsogeny);\n    }\n\n    fp2copy751(P->X, R->X);               \n    fp2copy751(P->Z, R->Z);\n}\n\n\nvoid decompress_3_torsion(const unsigned char* SecretKey, const unsigned char* CompressedPKA, point_proj_t R, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)\n{ // 3-torsion decompression function                                                                          \n    point_t R1, R2;\n    point_full_proj_t P, Q;\n    digit_t* comp = (digit_t*)CompressedPKA;\n    digit_t* SKin = (digit_t*)SecretKey;\n    f2elm_t A24, vec[2], invs[2], one = {0};\n    digit_t t1[NWORDS_ORDER], t2[NWORDS_ORDER], t3[NWORDS_ORDER], t4[NWORDS_ORDER], vone[NWORDS_ORDER] = {0};\n    uint64_t Montgomery_Rprime[NWORDS64_ORDER] = {0x1A55482318541298, 0x070A6370DFA12A03, 0xCB1658E0E3823A40, 0xB3B7384EB5DEF3F9, 0xCBCA952F7006EA33, 0x00569EF8EC94864C}; // Value (2^384)^2 mod 3^239\n    uint64_t Montgomery_rprime[NWORDS64_ORDER] = {0x48062A91D3AB563D, 0x6CE572751303C2F5, 0x5D1319F3F160EC9D, 0xE35554E8C2D5623A, 0xCA29300232BC79A5, 0x8AAD843D646D78C5}; // Value -(3^239)^-1 mod 2^384\n    unsigned int bit;\n    \n    vone[0] = 1;\n    to_Montgomery_mod_order(vone, vone, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);  // Converting to Montgomery representation\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    to_fp2mont((felm_t*)&comp[3*NWORDS_ORDER], A);    // Converting to Montgomery representation\n    generate_3_torsion_basis(A, P, Q, CurveIsogeny);\n\n    // normalize basis points\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    mont_n_way_inv(vec, 2, invs);\n    fp2mul751_mont(P->X, invs[0], R1->x);\n    fp2mul751_mont(P->Y, invs[0], R1->y);\n    fp2mul751_mont(Q->X, invs[1], R2->x);\n    fp2mul751_mont(Q->Y, invs[1], R2->y);\n\n    fp2add751(A, one, A24);\n    fp2add751(A24, one, A24);\n    fp2div2_751(A24, A24);\n    fp2div2_751(A24, A24);\n\n    bit = comp[3*NWORDS_ORDER-1] >> (sizeof(digit_t)*8 - 1);   \n    comp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 1;\n    to_Montgomery_mod_order(SKin, t1, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);    // Converting to Montgomery representation \n    to_Montgomery_mod_order(&comp[0], t2, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n    to_Montgomery_mod_order(&comp[NWORDS_ORDER], t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);  \n    to_Montgomery_mod_order(&comp[2*NWORDS_ORDER], t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n\n    if (bit == 0) {    \n        Montgomery_multiply_mod_order(t1, t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t3, vone, t3, NWORDS_ORDER);   \n        Montgomery_inversion_mod_order_bingcd(t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);\n        Montgomery_multiply_mod_order(t1, t4, t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t2, t4, t4, NWORDS_ORDER);   \n        Montgomery_multiply_mod_order(t3, t4, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);    // Converting back from Montgomery representation\n        mont_twodim_scalarmult(t3, R1, R2, A, A24, P, CurveIsogeny);\n    } else {   \n        Montgomery_multiply_mod_order(t1, t4, t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t4, vone, t4, NWORDS_ORDER);   \n        Montgomery_inversion_mod_order_bingcd(t4, t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);\n        Montgomery_multiply_mod_order(t1, t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t2, t3, t3, NWORDS_ORDER);   \n        Montgomery_multiply_mod_order(t3, t4, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);    // Converting back from Montgomery representation\n        mont_twodim_scalarmult(t3, R2, R1, A, A24, P, CurveIsogeny);\n    }\n\n    fp2copy751(P->X, R->X);               \n    fp2copy751(P->Z, R->Z);\n}","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for ephemeral \r\n*       Diffie-Hellman key exchange.\n*\n*    Copyright (c) Microsoft Corporation. All rights reserved.\n*\n*\n* Abstract: core functions over GF(p751^2) and field operations modulo the prime p751\n*\n*********************************************************************************************/ \n\n#include \"SIDH_internal.h\"\n#include <string.h>\n    \n\n// Global constants          \nconst uint64_t p751[NWORDS_FIELD]          = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xEEAFFFFFFFFFFFFF,\n                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };\nconst uint64_t p751p1[NWORDS_FIELD]        = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0xEEB0000000000000,\n                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };\nconst uint64_t p751x2[NWORDS_FIELD]        = { 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xDD5FFFFFFFFFFFFF, \n                                               0xC7D92D0A93F0F151, 0xB52B363427EF98ED, 0x109D30CFADD7D0ED, 0x0AC56A08B964AE90, 0x1C25213F2F75B8CD, 0x0000DFCBAA83EE38 };\nconst uint64_t Montgomery_R2[NWORDS_FIELD] = { 0x233046449DAD4058, 0xDB010161A696452A, 0x5E36941472E3FD8E, 0xF40BFE2082A2E706, 0x4932CCA8904F8751 ,0x1F735F1F1EE7FC81, \n                                               0xA24F4D80C1048E18, 0xB56C383CCDB607C5, 0x441DD47B735F9C90, 0x5673ED2C6A6AC82A, 0x06C905261132294B, 0x000041AD830F1F35 }; \n\n\n/*******************************************************/\n/************* Field arithmetic functions **************/\n\n__inline void fpcopy751(const felm_t a, felm_t c)\n{ // Copy a field element, c = a.\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_FIELD; i++)\n        c[i] = a[i];\n}\n\n\n__inline void fpzero751(felm_t a)\n{ // Zero a field element, a = 0.\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_FIELD; i++)\n        a[i] = 0;\n}\n\n\nbool fpequal751_non_constant_time(const felm_t a, const felm_t b) \n{ // Non constant-time comparison of two field elements. If a = b return TRUE, otherwise, return FALSE.\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_FIELD; i++) {\n        if (a[i] != b[i]) return false;\n    }\n\n    return true;\n}\n\n\nvoid to_mont(const felm_t a, felm_t mc)\n{ // Conversion to Montgomery representation,\n  // mc = a*R^2*R^(-1) mod p751 = a*R mod p751, where a in [0, p751-1].\n  // The Montgomery constant R^2 mod p751 is the global value \"Montgomery_R2\". \n\n    fpmul751_mont(a, (digit_t*)&Montgomery_R2, mc);\n}\n\n\nvoid from_mont(const felm_t ma, felm_t c)\n{ // Conversion from Montgomery representation to standard representation,\n  // c = ma*R^(-1) mod p751 = a mod p751, where ma in [0, p751-1].\n    digit_t one[NWORDS_FIELD] = {0};\n    \n    one[0] = 1;\n    fpmul751_mont(ma, one, c);\n    fpcorrection751(c);\n}\n\n\nstatic __inline unsigned int is_felm_zero(const felm_t x)\n{ // Is x = 0? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise.\n  // SECURITY NOTE: This function does not run in constant-time.\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_FIELD; i++) {\n        if (x[i] != 0) return false;\n    }\n    return true;\n}\n\n\nstatic __inline unsigned int is_felm_even(const felm_t x)\n{ // Is x even? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise.\n    return (unsigned int)((x[0] & 1) ^ 1);\n}\n\n\nstatic __inline unsigned int is_felm_lt(const felm_t x, const felm_t y)\n{ // Is x < y? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise.\n  // SECURITY NOTE: This function does not run in constant-time.\n    int i;\n\n    for (i = NWORDS_FIELD-1; i >= 0; i--) {\n        if (x[i] < y[i]) { \n            return true;\n        } else if (x[i] > y[i]) {\n            return false;\n        }\n    }\n    return false;\n}\n\n\nvoid copy_words(const digit_t* a, digit_t* c, const unsigned int nwords)\n{ // Copy wordsize digits, c = a, where lng(a) = nwords.\n    unsigned int i;\n        \n    for (i = 0; i < nwords; i++) {                      \n        c[i] = a[i];\n    }\n}\n\n\n__inline unsigned int mp_sub(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords)\n{ // Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit.\n    unsigned int i, borrow = 0;\n\n    for (i = 0; i < nwords; i++) {\n        SUBC(borrow, a[i], b[i], borrow, c[i]);\n    }\n\n    return borrow;\n}\n\n\n__inline unsigned int mp_add(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords)\n{ // Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit.\n    unsigned int i, carry = 0;\n        \n    for (i = 0; i < nwords; i++) {                      \n        ADDC(carry, a[i], b[i], carry, c[i]);\n    }\n\n    return carry;\n}\n\n\n__inline void mp_add751(const digit_t* a, const digit_t* b, digit_t* c)\n{ // 751-bit multiprecision addition, c = a+b.\r\n    \r\n#if (OS_TARGET == OS_WIN) || defined(GENERIC_IMPLEMENTATION)\n\n    mp_add(a, b, c, NWORDS_FIELD);\r\n    \r\n#elif (OS_TARGET == OS_LINUX)                 \r\n    \r\n    mp_add751_asm(a, b, c);    \r\n\r\n#endif\n}\n\n\n__inline void mp_add751x2(const digit_t* a, const digit_t* b, digit_t* c)\n{ // 2x751-bit multiprecision addition, c = a+b.\r\n    \r\n#if (OS_TARGET == OS_WIN) || defined(GENERIC_IMPLEMENTATION)\n\n    mp_add(a, b, c, 2*NWORDS_FIELD);\r\n    \r\n#elif (OS_TARGET == OS_LINUX)                 \r\n    \r\n    mp_add751x2_asm(a, b, c);    \r\n\r\n#endif\n}\n\n\nvoid mp_shiftr1(digit_t* x, const unsigned int nwords)\n{ // Multiprecision right shift by one.\n    unsigned int i;\n\n    for (i = 0; i < nwords-1; i++) {\n        SHIFTR(x[i+1], x[i], 1, x[i], RADIX);\n    }\n    x[nwords-1] >>= 1;\n}\n\n\nvoid mp_shiftl1(digit_t* x, const unsigned int nwords)\n{ // Multiprecision left shift by one.\n    int i;\n\n    for (i = nwords-1; i > 0; i--) {\n        SHIFTL(x[i], x[i-1], 1, x[i], RADIX);\n    }\n    x[0] <<= 1;\n}\n\n\nvoid fpmul751_mont(const felm_t ma, const felm_t mb, felm_t mc)\n{ // 751-bit Comba multi-precision multiplication, c = a*b mod p751.\n    dfelm_t temp = {0};\n\n    mp_mul(ma, mb, temp, NWORDS_FIELD);\n    rdc_mont(temp, mc);\n}\n\n\nvoid fpsqr751_mont(const felm_t ma, felm_t mc)\n{ // 751-bit Comba multi-precision squaring, c = a^2 mod p751.\n    dfelm_t temp = {0};\n\n    mp_mul(ma, ma, temp, NWORDS_FIELD);\n    rdc_mont(temp, mc);\n}\n\n\nvoid fpinv751_chain_mont(felm_t a)\n{ // Chain to compute a^(p751-3)/4 using Montgomery arithmetic.\n    felm_t t[27], tt;\n    unsigned int i, j;\n    \n    // Precomputed table\n    fpsqr751_mont(a, tt);\n    fpmul751_mont(a, tt, t[0]);\n    fpmul751_mont(t[0], tt, t[1]);\n    fpmul751_mont(t[1], tt, t[2]);\n    fpmul751_mont(t[2], tt, t[3]); \n    fpmul751_mont(t[3], tt, t[3]);\n    for (i = 3; i <= 8; i++) fpmul751_mont(t[i], tt, t[i+1]);\n    fpmul751_mont(t[9], tt, t[9]);\n    for (i = 9; i <= 20; i++) fpmul751_mont(t[i], tt, t[i+1]);\n    fpmul751_mont(t[21], tt, t[21]); \n    for (i = 21; i <= 24; i++) fpmul751_mont(t[i], tt, t[i+1]); \n    fpmul751_mont(t[25], tt, t[25]);\n    fpmul751_mont(t[25], tt, t[26]);\n\n    fpcopy751(a, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[20], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[24], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[11], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[8], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[2], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[23], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[2], tt, tt);\n    for (i = 0; i < 9; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[2], tt, tt);\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[15], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[13], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[26], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[20], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[11], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[10], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[14], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[4], tt, tt);\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[18], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[1], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[22], tt, tt);\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[6], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[24], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[9], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[18], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[17], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(a, tt, tt);\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[16], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[7], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[0], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[12], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[19], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[22], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[25], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[2], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[10], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[22], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[18], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[4], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[14], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[13], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[5], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[23], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[21], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[2], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[23], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[12], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[9], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[3], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[13], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[17], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[26], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[5], tt, tt);\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[8], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[2], tt, tt);\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[11], tt, tt);\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\n    fpmul751_mont(t[20], tt, tt);\n    for (j = 0; j < 61; j++) {\n        for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\n        fpmul751_mont(t[26], tt, tt);\n    }\n    fpcopy751(tt, a);  \n}\n\n\nvoid fpinv751_mont(felm_t a)\n{ // Field inversion using Montgomery arithmetic, a = a^(-1)*R mod p751.\n    felm_t tt;\n\n    fpcopy751(a, tt);\n    fpinv751_chain_mont(tt);\n    fpsqr751_mont(tt, tt);\n    fpsqr751_mont(tt, tt);\n    fpmul751_mont(a, tt, a);\n}\n\n\nstatic __inline void power2_setup(digit_t* x, int mark, const unsigned int nwords)\n{  // Set up the value 2^mark.\n\tunsigned int i;\n\n\tfor (i = 0; i < nwords; i++) x[i] = 0;\n\n    i = 0;\n\twhile (mark >= 0) {\n\t\tif (mark < RADIX) {\n\t\t\tx[i] = (digit_t)1 << mark;\n\t\t}\n\t\tmark -= RADIX;\n\t\ti += 1;\n\t}\n}\n\n\nstatic __inline void fpinv751_mont_bingcd_partial(const felm_t a, felm_t x1, unsigned int* k)\n{ // Partial Montgomery inversion in GF(p751) via the binary GCD algorithm.\n\tfelm_t u, v, x2;\n\tunsigned int cwords;  // number of words necessary for x1, x2\n\n\tfpcopy751(a, u);\n\tfpcopy751((digit_t*)&p751, v);\n\tfpzero751(x1); x1[0] = 1;\n\tfpzero751(x2);\n\t*k = 0;\n\n\twhile (!is_felm_zero(v)) {\n\t\tcwords = ((*k + 1) / RADIX) + 1;\n\t\tif ((cwords < NWORDS_FIELD)) {\n\t\t\tif (is_felm_even(v)) {\n\t\t\t\tmp_shiftr1(v, NWORDS_FIELD);\n\t\t\t\tmp_shiftl1(x1, cwords);\n\t\t\t} else if (is_felm_even(u)) {\n\t\t\t\tmp_shiftr1(u, NWORDS_FIELD);\n\t\t\t\tmp_shiftl1(x2, cwords);\n\t\t\t} else if (!is_felm_lt(v, u)) {\n\t\t\t\tmp_sub(v, u, v, NWORDS_FIELD);\n\t\t\t\tmp_shiftr1(v, NWORDS_FIELD);\n\t\t\t\tmp_add(x1, x2, x2, cwords);\n\t\t\t\tmp_shiftl1(x1, cwords);\n\t\t\t} else {\n\t\t\t\tmp_sub(u, v, u, NWORDS_FIELD);\n\t\t\t\tmp_shiftr1(u, NWORDS_FIELD);\n\t\t\t\tmp_add(x1, x2, x1, cwords);\n\t\t\t\tmp_shiftl1(x2, cwords);\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_felm_even(v)) {\n\t\t\t\tmp_shiftr1(v, NWORDS_FIELD);\n\t\t\t\tmp_shiftl1(x1, NWORDS_FIELD);\n\t\t\t} else if (is_felm_even(u)) {\n\t\t\t\tmp_shiftr1(u, NWORDS_FIELD);\n\t\t\t\tmp_shiftl1(x2, NWORDS_FIELD);\n\t\t\t} else if (!is_felm_lt(v, u)) {\n\t\t\t\tmp_sub(v, u, v, NWORDS_FIELD);\n\t\t\t\tmp_shiftr1(v, NWORDS_FIELD);\n\t\t\t\tmp_add751(x1, x2, x2);\n\t\t\t\tmp_shiftl1(x1, NWORDS_FIELD);\n\t\t\t} else {\n\t\t\t\tmp_sub(u, v, u, NWORDS_FIELD);\n\t\t\t\tmp_shiftr1(u, NWORDS_FIELD);\n\t\t\t\tmp_add751(x1, x2, x1);\n\t\t\t\tmp_shiftl1(x2, NWORDS_FIELD);\n\t\t\t}\n\t\t}\n\t\t*k += 1;\n\t}\n\n\tif (is_felm_lt((digit_t*)&p751, x1)) {\n\t\tmp_sub(x1, (digit_t*)&p751, x1, NWORDS_FIELD);\n\t}\n}\n\n\nvoid fpinv751_mont_bingcd(felm_t a)\n{ // Field inversion via the binary GCD using Montgomery arithmetic, a = a^-1*R mod p751.\n  // SECURITY NOTE: This function does not run in constant-time and is therefore only suitable for \n  //                operations not involving any secret data.\n\tfelm_t x, t;\n\tunsigned int k;\n\n\tfpinv751_mont_bingcd_partial(a, x, &k);\n\tif (k < 768) {\n\t\tfpmul751_mont(x, (digit_t*)&Montgomery_R2, x);\n\t\tk += 768;\n\t}\n\tfpmul751_mont(x, (digit_t*)&Montgomery_R2, x);\n\tpower2_setup(t, 2*768 - k, NWORDS_FIELD);\n\tfpmul751_mont(x, t, a);\n}\n\n\n/***********************************************/\n/************* GF(p^2) FUNCTIONS ***************/\n\nvoid fp2copy751(const f2elm_t a, f2elm_t c)\n{ // Copy a GF(p751^2) element, c = a.\n    fpcopy751(a[0], c[0]);\n    fpcopy751(a[1], c[1]);\n}\n\n\nvoid fp2zero751(f2elm_t a)\n{ // Zero a GF(p751^2) element, a = 0.\n    fpzero751(a[0]);\n    fpzero751(a[1]);\n}\n\n\nvoid fp2neg751(f2elm_t a)\n{ // GF(p751^2) negation, a = -a in GF(p751^2).\n    fpneg751(a[0]);\n    fpneg751(a[1]);\n}\n\n\n__inline void fp2add751(const f2elm_t a, const f2elm_t b, f2elm_t c)           \n{ // GF(p751^2) addition, c = a+b in GF(p751^2).\n    fpadd751(a[0], b[0], c[0]);\n    fpadd751(a[1], b[1], c[1]);\n}\n\n\n__inline void fp2sub751(const f2elm_t a, const f2elm_t b, f2elm_t c)          \n{ // GF(p751^2) subtraction, c = a-b in GF(p751^2).\n    fpsub751(a[0], b[0], c[0]);\n    fpsub751(a[1], b[1], c[1]);\n}\n\n\nvoid fp2div2_751(const f2elm_t a, f2elm_t c)          \n{ // GF(p751^2) division by two, c = a/2  in GF(p751^2).\n    fpdiv2_751(a[0], c[0]);\n    fpdiv2_751(a[1], c[1]);\n}\n\n\nvoid fp2correction751(f2elm_t a)\n{ // Modular correction, a = a in GF(p751^2).\n    fpcorrection751(a[0]);\n    fpcorrection751(a[1]);\n}\n\n\nvoid fp2sqr751_mont(const f2elm_t a, f2elm_t c)\n{ // GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2).\r\n  // Inputs: a = a0+a1*i, where a0, a1 are in [0, 2*p751-1] \r\n  // Output: c = c0+c1*i, where c0, c1 are in [0, 2*p751-1] \n    felm_t t1, t2, t3;\n    \n    mp_add751(a[0], a[1], t1);               // t1 = a0+a1 \n    fpsub751(a[0], a[1], t2);                // t2 = a0-a1\n    mp_add751(a[0], a[0], t3);               // t3 = 2a0\n    fpmul751_mont(t1, t2, c[0]);             // c0 = (a0+a1)(a0-a1)\n    fpmul751_mont(t3, a[1], c[1]);           // c1 = 2a0*a1\n}\n\n\nvoid fp2mul751_mont(const f2elm_t a, const f2elm_t b, f2elm_t c)\n{ // GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2).\r\n  // Inputs: a = a0+a1*i and b = b0+b1*i, where a0, a1, b0, b1 are in [0, 2*p751-1] \r\n  // Output: c = c0+c1*i, where c0, c1 are in [0, 2*p751-1] \n    felm_t t1, t2;\n    dfelm_t tt1, tt2, tt3; \n    digit_t mask;\n    unsigned int i, borrow;\n    \n    mp_mul(a[0], b[0], tt1, NWORDS_FIELD);           // tt1 = a0*b0\n    mp_mul(a[1], b[1], tt2, NWORDS_FIELD);           // tt2 = a1*b1\n    mp_add751(a[0], a[1], t1);                       // t1 = a0+a1\n    mp_add751(b[0], b[1], t2);                       // t2 = b0+b1\n    borrow = mp_sub(tt1, tt2, tt3, 2*NWORDS_FIELD);  // tt3 = a0*b0 - a1*b1\n    mask = 0 - (digit_t)borrow;                      // if tt3 < 0 then mask = 0xFF..F, else if tt3 >= 0 then mask = 0x00..0\n    borrow = 0;\n    for (i = 0; i < NWORDS_FIELD; i++) {\n        ADDC(borrow, tt3[NWORDS_FIELD+i], ((digit_t*)p751)[i] & mask, borrow, tt3[NWORDS_FIELD+i]);\n    }\n    rdc_mont(tt3, c[0]);                             // c[0] = a0*b0 - a1*b1\n    mp_add751x2(tt1, tt2, tt1);                      // tt1 = a0*b0 + a1*b1\n    mp_mul(t1, t2, tt2, NWORDS_FIELD);               // tt2 = (a0+a1)*(b0+b1)\n    mp_sub(tt2, tt1, tt2, 2*NWORDS_FIELD);           // tt2 = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 \n    rdc_mont(tt2, c[1]);                             // c[1] = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 \n}\n\n\nvoid to_fp2mont(const f2elm_t a, f2elm_t mc)\n{ // Conversion of a GF(p751^2) element to Montgomery representation,\n  // mc_i = a_i*R^2*R^(-1) = a_i*R in GF(p751^2). \n\n    to_mont(a[0], mc[0]);\n    to_mont(a[1], mc[1]);\n}\n\n\nvoid from_fp2mont(const f2elm_t ma, f2elm_t c)\n{ // Conversion of a GF(p751^2) element from Montgomery representation to standard representation,\n  // c_i = ma_i*R^(-1) = a_i in GF(p751^2).\n\n    from_mont(ma[0], c[0]);\n    from_mont(ma[1], c[1]);\n}\n\n\nvoid fp2inv751_mont(f2elm_t a)\n{// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2).\n    f2elm_t t1;\n\n    fpsqr751_mont(a[0], t1[0]);             // t10 = a0^2\n    fpsqr751_mont(a[1], t1[1]);             // t11 = a1^2\n    fpadd751(t1[0], t1[1], t1[0]);          // t10 = a0^2+a1^2\n    fpinv751_mont(t1[0]);                   // t10 = (a0^2+a1^2)^-1\n    fpneg751(a[1]);                         // a = a0-i*a1\n    fpmul751_mont(a[0], t1[0], a[0]);\n    fpmul751_mont(a[1], t1[0], a[1]);       // a = (a0-i*a1)*(a0^2+a1^2)^-1\n}\n\nvoid fp2inv751_mont_bingcd(f2elm_t a)\n{// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)\n // This uses the binary GCD for inversion in fp and is NOT constant time!!!\n\tf2elm_t t1;\n\n\tfpsqr751_mont(a[0], t1[0]);             // t10 = a0^2\n\tfpsqr751_mont(a[1], t1[1]);             // t11 = a1^2\n\tfpadd751(t1[0], t1[1], t1[0]);          // t10 = a0^2+a1^2\n\tfpinv751_mont_bingcd(t1[0]);            // t10 = (a0^2+a1^2)^-1\n\tfpneg751(a[1]);                         // a = a0-i*a1\n\tfpmul751_mont(a[0], t1[0], a[0]);\n\tfpmul751_mont(a[1], t1[0], a[1]);       // a = (a0-i*a1)*(a0^2+a1^2)^-1\n}\n\n\n\nvoid swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, const digit_t option)\n{ // Swap points over the base field.\n  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P\n    digit_t temp;\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_FIELD; i++) {\n        temp = option & (P->X[i] ^ Q->X[i]);\n        P->X[i] = temp ^ P->X[i]; \n        Q->X[i] = temp ^ Q->X[i]; \n        temp = option & (P->Z[i] ^ Q->Z[i]);\n        P->Z[i] = temp ^ P->Z[i]; \n        Q->Z[i] = temp ^ Q->Z[i]; \n    }\n}\n\n\nvoid swap_points(point_proj_t P, point_proj_t Q, const digit_t option)\n{ // Swap points.\n  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P\n    digit_t temp;\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_FIELD; i++) {\n        temp = option & (P->X[0][i] ^ Q->X[0][i]);\n        P->X[0][i] = temp ^ P->X[0][i]; \n        Q->X[0][i] = temp ^ Q->X[0][i]; \n        temp = option & (P->Z[0][i] ^ Q->Z[0][i]);\n        P->Z[0][i] = temp ^ P->Z[0][i]; \n        Q->Z[0][i] = temp ^ Q->Z[0][i]; \n        temp = option & (P->X[1][i] ^ Q->X[1][i]);\n        P->X[1][i] = temp ^ P->X[1][i]; \n        Q->X[1][i] = temp ^ Q->X[1][i]; \n        temp = option & (P->Z[1][i] ^ Q->Z[1][i]);\n        P->Z[1][i] = temp ^ P->Z[1][i]; \n        Q->Z[1][i] = temp ^ Q->Z[1][i]; \n    }\n}\n\n\nvoid select_f2elm(const f2elm_t x, const f2elm_t y, f2elm_t z, const digit_t option)\n{ // Select either x or y depending on the value of option.\n  // If option = 0 then z <- x, else if option = 0xFF...FF then z <- y.\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_FIELD; i++) {\n        z[0][i] = (option & (x[0][i] ^ y[0][i])) ^ x[0][i]; \n        z[1][i] = (option & (x[1][i] ^ y[1][i])) ^ x[1][i]; \n    }\n}\n\n\nvoid mont_n_way_inv(const f2elm_t* vec, const int n, f2elm_t* out)\n{ // n-way simultaneous inversion using Montgomery's trick.\n  // SECURITY NOTE: This function does not run in constant time.\n  // Also, vec and out CANNOT be the same variable!\n\tf2elm_t t1;\n\tint i;\n\n    fp2copy751(vec[0], out[0]);                      // out[0] = vec[0]\n    for (i = 1; i < n; i++) {\n        fp2mul751_mont(out[i-1], vec[i], out[i]);    // out[i] = out[i-1]*vec[i]\n    }\n\n    fp2copy751(out[n-1], t1);                        // t1 = 1/out[n-1]\n    fp2inv751_mont_bingcd(t1);\n    \n    for (i = n-1; i >= 1; i--) {\n\t\tfp2mul751_mont(out[i-1], t1, out[i]);        // out[i] = t1*out[i-1]\n        fp2mul751_mont(t1, vec[i], t1);              // t1 = t1*vec[i]\n    }\n    fp2copy751(t1, out[0]);                          // out[0] = t1\n}\n\n\nvoid sqrt_Fp2_frac(const f2elm_t u, const f2elm_t v, f2elm_t y)\n{ // Computes square roots of elements in (Fp2)^2 using Hamburg's trick. \n    felm_t t0, t1, t2, t3, t4, t;\n    digit_t *u0 = (digit_t*)u[0], *u1 = (digit_t*)u[1];\n    digit_t *v0 = (digit_t*)v[0], *v1 = (digit_t*)v[1];\n    digit_t *y0 = (digit_t*)y[0], *y1 = (digit_t*)y[1];\n    unsigned int i;\n\n    fpsqr751_mont(v0, t0);                  // t0 = v0^2\n    fpsqr751_mont(v1, t1);                  // t1 = v1^2\n    fpadd751(t0, t1, t0);                   // t0 = t0+t1   \n    fpmul751_mont(u0, v0, t1);              // t1 = u0*v0\n    fpmul751_mont(u1, v1, t2);              // t2 = u1*v1 \n    fpadd751(t1, t2, t1);                   // t1 = t1+t2  \n    fpmul751_mont(u1, v0, t2);              // t2 = u1*v0\n    fpmul751_mont(u0, v1, t3);              // t3 = u0*v1\n    fpsub751(t2, t3, t2);                   // t2 = t2-t3    \n    fpsqr751_mont(t1, t3);                  // t3 = t1^2    \n    fpsqr751_mont(t2, t4);                  // t4 = t2^2\n    fpadd751(t3, t4, t3);                   // t3 = t3+t4\n    fpcopy751(t3, t);\n    for (i = 0; i < 370; i++) {             // t = t3^((p+1)/4)\n        fpsqr751_mont(t, t);\n    }\n    for (i = 0; i < 239; i++) {\n        fpsqr751_mont(t, t3);                                         \n        fpmul751_mont(t, t3, t);                                      \n    }    \n    fpadd751(t1, t, t);                     // t = t+t1\n    fpadd751(t, t, t);                      // t = 2*t  \n    fpsqr751_mont(t0, t3);                  // t3 = t0^2      \n    fpmul751_mont(t0, t3, t3);              // t3 = t3*t0   \n    fpmul751_mont(t, t3, t3);               // t3 = t3*t\n    fpinv751_chain_mont(t3);                // t3 = t3^((p-3)/4)\n    fpmul751_mont(t0, t3, t3);              // t3 = t3*t0             \n    fpmul751_mont(t, t3, t1);               // t1 = t*t3 \n    fpdiv2_751(t1, y0);                     // y0 = t1/2         \n    fpmul751_mont(t2, t3, y1);              // y1 = t3*t2 \n    fpsqr751_mont(t1, t1);                  // t1 = t1^2\n    fpmul751_mont(t0, t1, t1);              // t1 = t1*t0\n\tfpcorrection751(t);\n\tfpcorrection751(t1);\n\n    if (fpequal751_non_constant_time(t1, t) == false) {\n        fpcopy751(y0, t);                   \n        fpcopy751(y1, y0);                  // Swap y0 and y1 \n        fpcopy751(t, y1); \n    }\n\n    fpsqr751_mont(y0, t0);                  // t0 = y0^2\n    fpsqr751_mont(y1, t1);                  // t1 = y1^2\n    fpsub751(t0, t1, t0);                   // t0 = t0-t1\n    fpmul751_mont(t0, v0, t0);              // t0 = t0*v0\n    fpmul751_mont(y0, y1, t1);              // t1 = y0*y1\n    fpmul751_mont(v1, t1, t1);              // t1 = t1*v1\n    fpadd751(t1, t1, t1);                   // t1 = t1+t1\n    fpsub751(t0, t1, t0);                   // t0 = t0-t1\n\tfpcorrection751(t0);\n\tfpcorrection751(u0);\n\t\n    if (fpequal751_non_constant_time(t0, u0) == false) {\n        fpneg751(y1);                       // y1 = -y1\n    }\n}\n\n\nvoid sqrt_Fp2(const f2elm_t u, f2elm_t y)\n{ // Computes square roots of elements in (Fp2)^2 using Hamburg's trick. \n    felm_t t0, t1, t2, t3;\n    digit_t *a  = (digit_t*)u[0], *b  = (digit_t*)u[1];\n    unsigned int i;\n\n    fpsqr751_mont(a, t0);                   // t0 = a^2\n    fpsqr751_mont(b, t1);                   // t1 = b^2\n    fpadd751(t0, t1, t0);                   // t0 = t0+t1 \n    fpcopy751(t0, t1);\n    for (i = 0; i < 370; i++) {             // t = t3^((p+1)/4)\n        fpsqr751_mont(t1, t1);\n    }\n    for (i = 0; i < 239; i++) {\n        fpsqr751_mont(t1, t0);                                         \n        fpmul751_mont(t1, t0, t1);                                      \n    }  \n    fpadd751(a, t1, t0);                    // t0 = a+t1      \n    fpdiv2_751(t0, t0);                     // t0 = t0/2 \n\tfpcopy751(t0, t2);\n    fpinv751_chain_mont(t2);                // t2 = t0^((p-3)/4)      \n    fpmul751_mont(t0, t2, t1);              // t1 = t2*t0             \n    fpmul751_mont(t2, b, t2);               // t2 = t2*b       \n    fpdiv2_751(t2, t2);                     // t2 = t2/2 \n    fpsqr751_mont(t1, t3);                  // t3 = t1^2  \n\tfpcorrection751(t0);\n\tfpcorrection751(t3);\n\n    if (fpequal751_non_constant_time(t0, t3) == true) {\n        fpcopy751(t1, y[0]);\n        fpcopy751(t2, y[1]);\n    } else {\n        fpneg751(t1);\n        fpcopy751(t2, y[0]);\n        fpcopy751(t1, y[1]);\n    }\n}\n\n\nvoid cube_Fp2_cycl(f2elm_t a, const felm_t one)\n{ // Cyclotomic cubing on elements of norm 1, using a^(p+1) = 1.\n     felm_t t0;\n   \n     fpadd751(a[0], a[0], t0);              // t0 = a0 + a0\n     fpsqr751_mont(t0, t0);                 // t0 = t0^2\n     fpsub751(t0, one, t0);                 // t0 = t0 - 1\n     fpmul751_mont(a[1], t0, a[1]);         // a1 = t0*a1\n     fpsub751(t0, one, t0);                 \n     fpsub751(t0, one, t0);                 // t0 = t0 - 2\n     fpmul751_mont(a[0], t0, a[0]);         // a0 = t0*a0\n}\n\n\nvoid sqr_Fp2_cycl(f2elm_t a, const felm_t one)\n{ // Cyclotomic squaring on elements of norm 1, using a^(p+1) = 1.\n     felm_t t0;\n \n     fpadd751(a[0], a[1], t0);              // t0 = a0 + a1\n     fpsqr751_mont(t0, t0);                 // t0 = t0^2\n     fpsub751(t0, one, a[1]);               // a1 = t0 - 1   \n     fpsqr751_mont(a[0], t0);               // t0 = a0^2\n     fpadd751(t0, t0, t0);                  // t0 = t0 + t0\n     fpsub751(t0, one, a[0]);               // a0 = t0 - 1\n}\n\n\n__inline void inv_Fp2_cycl(f2elm_t a)\n{ // Cyclotomic inversion, a^(p+1) = 1 => a^(-1) = a^p = a0 - i*a1.\n\n     fpneg751(a[1]);\n}\n\n\nvoid exp6_Fp2_cycl(const f2elm_t y, const uint64_t t, const felm_t one, f2elm_t res)\n{ // Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 6 bits at most.\n    unsigned int i, bit;\n\n    fp2zero751(res);\n\tfpcopy751(one, res[0]);             // res = 1\n\n    if (t != 0) {\n        for (i = 0; i < 6; i++) {\n            sqr_Fp2_cycl(res, one); \n            bit = 1 & (t >> (5-i));\n            if (bit == 1) {\n                fp2mul751_mont(res, y, res); \n            }\n        }\n    }\n}\n\n\nvoid exp21_Fp2_cycl(const f2elm_t y, const uint64_t t, const felm_t one, f2elm_t res)\n{ // Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 21 bits at most.\n\tunsigned int i, bit;\n\n\tfp2zero751(res);\n\tfpcopy751(one, res[0]);             // res = 1\n\n\tif (t != 0) {\n\t\tfor (i = 0; i < 21; i++) {\n\t\t\tsqr_Fp2_cycl(res, one);\n\t\t\tbit = 1 & (t >> (20 - i));\n\t\t\tif (bit == 1) {\n\t\t\t\tfp2mul751_mont(res, y, res);\n\t\t\t}\n\t\t}\n\t}\n}\n\r\n\r\nstatic bool is_zero(digit_t* a, unsigned int nwords)\r\n{ // Check if multiprecision element is zero.\r\n  // SECURITY NOTE: This function does not run in constant time.\r\n\tunsigned int i;\r\n\r\n\tfor (i = 0; i < nwords; i++) {\r\n\t\tif (a[i] != 0) {\r\n            return false;\r\n        } \r\n\t}\r\n\r\n\treturn true;\r\n}\n\n\nvoid exp_Fp2_cycl(const f2elm_t y, uint64_t* t, const felm_t one, f2elm_t res, int length)\n{ // Exponentiation y^t via square and multiply in the cyclotomic group. \n  // This function uses 64-bit digits for representing exponents.\n\tunsigned int nword, bit, nwords = (length+63)/64;\n\tint i;\n\n\tfp2zero751(res);\n\tfpcopy751(one, res[0]);               // res = 1\n\n\tif (!is_zero((digit_t*)t, nwords)) {  // Is t = 0?\n\t\tfor (i = length; i >= 0; i--) {\n\t\t\tsqr_Fp2_cycl(res, one);\n\t\t\tnword = i >> 6;\n\t\t\tbit = 1 & (t[nword] >> (i - (nword << 6)));\n\t\t\tif (bit == 1) {\n\t\t\t\tfp2mul751_mont(res, y, res);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid exp84_Fp2_cycl(const f2elm_t y, uint64_t* t, const felm_t one, f2elm_t res)\n{ // Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 84 bits at most \n  // This function uses 64-bit digits for representing exponents.\n    unsigned int nword, bit, nwords = 2;\n    int i;\n\n    fp2zero751(res);\n\tfpcopy751(one, res[0]);               // res = 1\n    \n\tif (!is_zero((digit_t*)t, nwords)) {  // Is t = 0?\n        for (i = 83; i >= 0; i--) {\n            sqr_Fp2_cycl(res, one); \n            nword = i >> 6; \n            bit = 1 & (t[nword] >> (i - (nword << 6)));\n            if (bit == 1) {\n                fp2mul751_mont(res, y, res); \n            }\n        }\n    }\n}\n\n\nbool is_cube_Fp2(f2elm_t u, PCurveIsogenyStruct CurveIsogeny)\n{ // Check if a GF(p751^2) element is a cube.\n    f2elm_t v;\n    felm_t t0, zero = {0}, one = {0};\n    unsigned int e;\n\n    fpcopy751(CurveIsogeny->Montgomery_one, one);\n\tfpsqr751_mont(u[0], v[0]);              // v0 = u0^2\n    fpsqr751_mont(u[1], v[1]);              // v1 = u1^2\n    fpadd751(v[0], v[1], t0);               // t0 = v0+v1\n    fpinv751_mont_bingcd(t0);               // Fp inversion with binary Euclid\n    fpsub751(v[0], v[1], v[0]);             // v0 = v0-v1\n    fpmul751_mont(u[0], u[1], v[1]);        // v1 = u0*u1\n    fpadd751(v[1], v[1], v[1]);             // v1 = 2*v1\n    fpneg751(v[1]);                         // v1 = -v1\n    fpmul751_mont(v[0], t0, v[0]);          // v0 = v0*t0\n    fpmul751_mont(v[1], t0, v[1]);          // v1 = v1*t0\n\n    for (e = 0; e < 372; e++) {  \n        sqr_Fp2_cycl(v, one);\n    }\n\n    for (e = 0; e < 238; e++) {\n        cube_Fp2_cycl(v, one);\n    }\n\n\tfp2correction751(v);\n\n\tif (fpequal751_non_constant_time(v[0], one) == true && fpequal751_non_constant_time(v[1], zero) == true) {  // v == 1?\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\nvoid multiply(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords)\n{ // Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.\n  // NOTE: a and c CANNOT be the same variable!\n    unsigned int i, j;\n    digit_t t = 0, u = 0, v = 0, UV[2];\n    unsigned int carry = 0;\n    \n    for (i = 0; i < nwords; i++) {\n        for (j = 0; j <= i; j++) {\n            MUL(a[j], b[i-j], UV+1, UV[0]); \n            ADDC(0, UV[0], v, carry, v); \n            ADDC(carry, UV[1], u, carry, u); \n            t += carry;\n        }\n        c[i] = v;\n        v = u; \n        u = t;\n        t = 0;\n    }\n\n    for (i = nwords; i < 2*nwords-1; i++) {\n        for (j = i-nwords+1; j < nwords; j++) {\n            MUL(a[j], b[i-j], UV+1, UV[0]); \n            ADDC(0, UV[0], v, carry, v); \n            ADDC(carry, UV[1], u, carry, u); \n            t += carry;\n        }\n        c[i] = v;\n        v = u; \n        u = t;\n        t = 0;\n    }\n    c[2*nwords-1] = v; \n}\n\n\nvoid Montgomery_multiply_mod_order(const digit_t* ma, const digit_t* mb, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime)\n{ // Montgomery multiplication modulo the group order, mc = ma*mb*r' mod order, where ma,mb,mc in [0, order-1].\n  // ma, mb and mc are assumed to be in Montgomery representation.\n  // The Montgomery constant r' = -r^(-1) mod 2^(log_2(r)) is the value \"Montgomery_rprime\", where r is the order.   \n\tunsigned int i, cout = 0, bout = 0;\n\tdigit_t mask, P[2*NWORDS_ORDER], Q[2*NWORDS_ORDER], temp[2*NWORDS_ORDER];\n\n\tmultiply(ma, mb, P, NWORDS_ORDER);                 // P = ma * mb\n\tmultiply(P, Montgomery_rprime, Q, NWORDS_ORDER);   // Q = P * r' mod 2^(log_2(r))\n\tmultiply(Q, order, temp, NWORDS_ORDER);            // temp = Q * r\n\tcout = mp_add(P, temp, temp, 2*NWORDS_ORDER);      // (cout, temp) = P + Q * r     \n\n\tfor (i = 0; i < NWORDS_ORDER; i++) {               // (cout, mc) = (P + Q * r)/2^(log_2(r))\n\t\tmc[i] = temp[NWORDS_ORDER+i];\n\t}\n\n\t// Final, constant-time subtraction     \n\tbout = mp_sub(mc, order, mc, NWORDS_ORDER);        // (cout, mc) = (cout, mc) - r\n\tmask = (digit_t)cout - (digit_t)bout;              // if (cout, mc) >= 0 then mask = 0x00..0, else if (cout, mc) < 0 then mask = 0xFF..F\n\n\tfor (i = 0; i < NWORDS_ORDER; i++) {               // temp = mask & r\n\t\ttemp[i] = (order[i] & mask);\n\t}\n\tmp_add(mc, temp, mc, NWORDS_ORDER);                //  mc = mc + (mask & r)\n}\n\n\nvoid Montgomery_inversion_mod_order(const digit_t* ma, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime)\n{ // (Non-constant time) Montgomery inversion modulo the curve order using a^(-1) = a^(order-2) mod order\n  // This function uses the sliding-window method.\n\tsdigit_t i = 384;\n\tunsigned int j, nwords = NWORDS_ORDER, nbytes = (unsigned int)i/8;\n\tdigit_t temp, bit = 0, count, mod2, k_EXPON = 5;       // Fixing parameter k to 5 for the sliding windows method\n\tdigit_t modulus2[NWORDS_ORDER] = {0}, npoints = 16;\n\tdigit_t input_a[NWORDS_ORDER];\n\tdigit_t table[16][NWORDS_ORDER];                       // Fixing the number of precomputed elements to 16 (assuming k = 5)\n\tdigit_t mask = (digit_t)1 << (sizeof(digit_t)*8 - 1);  // 0x800...000\n\tdigit_t mask2 = ~((digit_t)(-1) >> k_EXPON);           // 0xF800...000, assuming k = 5\n\n\t// SECURITY NOTE: this function does not run in constant time.\n\n\tmodulus2[0] = 2;\n\tmp_sub(order, modulus2, modulus2, nwords);             // modulus-2\n\n\t// Precomputation stage\n\tmemmove((unsigned char*)&table[0], (unsigned char*)ma, nbytes);                               // table[0] = ma \n\tMontgomery_multiply_mod_order(ma, ma, input_a, order, Montgomery_rprime);                     // ma^2\n\tfor (j = 0; j < npoints - 1; j++) {\n\t\tMontgomery_multiply_mod_order(table[j], input_a, table[j+1], order, Montgomery_rprime);   // table[j+1] = table[j] * ma^2\n\t}\n\n\twhile (bit != 1) {                                     // Shift (modulus-2) to the left until getting first bit 1\n\t\ti--;\n\t\ttemp = 0;\n\t\tfor (j = 0; j < nwords; j++) {\n\t\t\tbit = (modulus2[j] & mask) >> (sizeof(digit_t)*8 - 1);\n\t\t\tmodulus2[j] = (modulus2[j] << 1) | temp;\n\t\t\ttemp = bit;\n\t\t}\n\t}\n\n\t// Evaluation stage\n\tmemmove((unsigned char*)mc, (unsigned char*)ma, nbytes);\n\tbit = (modulus2[nwords-1] & mask) >> (sizeof(digit_t)*8 - 1);\n\twhile (i > 0) {\n\t\tif (bit == 0) {                                                            // Square accumulated value because bit = 0 and shift (modulus-2) one bit to the left\n\t\t\tMontgomery_multiply_mod_order(mc, mc, mc, order, Montgomery_rprime);   // mc = mc^2\n\t\t\ti--;\n\t\t\tfor (j = (nwords - 1); j > 0; j--) {\n\t\t\t\tSHIFTL(modulus2[j], modulus2[j-1], 1, modulus2[j], RADIX);\n\t\t\t}\n\t\t\tmodulus2[0] = modulus2[0] << 1;\n\t\t} else {                                                                   // \"temp\" will store the longest odd bitstring with \"count\" bits s.t. temp <= 2^k - 1 \n\t\t\tcount = k_EXPON;\n\t\t\ttemp = (modulus2[nwords-1] & mask2) >> (sizeof(digit_t)*8 - k_EXPON);  // Extracting next k bits to the left\n\t\t\tmod2 = temp & 1;\n\t\t\twhile (mod2 == 0) {                                                    // if even then shift to the right and adjust count\n\t\t\t\ttemp = (temp >> 1);\n\t\t\t\tmod2 = temp & 1;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tfor (j = 0; j < count; j++) {                                          // mc = mc^count\n\t\t\t\tMontgomery_multiply_mod_order(mc, mc, mc, order, Montgomery_rprime);\n\t\t\t}\n\t\t\tMontgomery_multiply_mod_order(mc, table[(temp-1) >> 1], mc, order, Montgomery_rprime);   // mc = mc * table[(temp-1)/2] \n\t\t\ti = i - count;\n\n\t\t\tfor (j = (nwords-1); j > 0; j--) {                                     // Shift (modulus-2) \"count\" bits to the left\n\t\t\t\tSHIFTL(modulus2[j], modulus2[j-1], count, modulus2[j], RADIX);\n\t\t\t}\n\t\t\tmodulus2[0] = modulus2[0] << count;\n\t\t}\n\t\tbit = (modulus2[nwords-1] & mask) >> (sizeof(digit_t)*8 - 1);\n\t}\n}\n\n\nstatic __inline unsigned int is_zero_mod_order(const digit_t* x)\n{ // Is x = 0? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\n  // SECURITY NOTE: This function does not run in constant time.\n    unsigned int i;\n\n    for (i = 0; i < NWORDS_ORDER; i++) {\n        if (x[i] != 0) return false;\n    }\n    return true;\n}\n\n\nstatic __inline unsigned int is_even_mod_order(const digit_t* x)\n{ // Is x even? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise.\n    return (unsigned int)((x[0] & 1) ^ 1);\n}\n\n\nstatic __inline unsigned int is_lt_mod_order(const digit_t* x, const digit_t* y)\n{ // Is x < y? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise.\n  // SECURITY NOTE: This function does not run in constant time.\n    int i;\n\n    for (i = NWORDS_ORDER-1; i >= 0; i--) {\n        if (x[i] < y[i]) { \n            return true;\n        } else if (x[i] > y[i]) {\n            return false;\n        }\n    }\n    return false;\n}\n\n\nstatic __inline void Montgomery_inversion_mod_order_bingcd_partial(const digit_t* a, digit_t* x1, unsigned int* k, const digit_t* order)\n{ // Partial Montgomery inversion modulo order.\n\tdigit_t u[NWORDS_ORDER], v[NWORDS_ORDER], x2[NWORDS_ORDER] = {0};\n\tunsigned int cwords;  // number of words necessary for x1, x2\n\n\tcopy_words(a, u, NWORDS_ORDER);\n\tcopy_words(order, v, NWORDS_ORDER);\n\tcopy_words(x2, x1, NWORDS_ORDER);\n\tx1[0] = 1;\n\t*k = 0;\n\n\twhile (!is_zero_mod_order(v)) {\n\t\tcwords = ((*k + 1) / RADIX) + 1;\n\t\tif ((cwords < NWORDS_ORDER)) {\n\t\t\tif (is_even_mod_order(v)) {\n\t\t\t\tmp_shiftr1(v, NWORDS_ORDER);\n\t\t\t\tmp_shiftl1(x1, cwords);\n\t\t\t} else if (is_even_mod_order(u)) {\n\t\t\t\tmp_shiftr1(u, NWORDS_ORDER);\n\t\t\t\tmp_shiftl1(x2, cwords);\n\t\t\t} else if (!is_lt_mod_order(v, u)) {\n\t\t\t\tmp_sub(v, u, v, NWORDS_ORDER);\n\t\t\t\tmp_shiftr1(v, NWORDS_ORDER);\n\t\t\t\tmp_add(x1, x2, x2, cwords);\n\t\t\t\tmp_shiftl1(x1, cwords);\n\t\t\t} else {\n\t\t\t\tmp_sub(u, v, u, NWORDS_ORDER);\n\t\t\t\tmp_shiftr1(u, NWORDS_ORDER);\n\t\t\t\tmp_add(x1, x2, x1, cwords);\n\t\t\t\tmp_shiftl1(x2, cwords);\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_even_mod_order(v)) {\n\t\t\t\tmp_shiftr1(v, NWORDS_ORDER);\n\t\t\t\tmp_shiftl1(x1, NWORDS_ORDER);\n\t\t\t} else if (is_even_mod_order(u)) {\n\t\t\t\tmp_shiftr1(u, NWORDS_ORDER);\n\t\t\t\tmp_shiftl1(x2, NWORDS_ORDER);\n\t\t\t} else if (!is_lt_mod_order(v, u)) {\n\t\t\t\tmp_sub(v, u, v, NWORDS_ORDER);\n\t\t\t\tmp_shiftr1(v, NWORDS_ORDER);\n\t\t\t\tmp_add(x1, x2, x2, NWORDS_ORDER);\n\t\t\t\tmp_shiftl1(x1, NWORDS_ORDER);\n\t\t\t} else {\n\t\t\t\tmp_sub(u, v, u, NWORDS_ORDER);\n\t\t\t\tmp_shiftr1(u, NWORDS_ORDER);\n\t\t\t\tmp_add(x1, x2, x1, NWORDS_ORDER);\n\t\t\t\tmp_shiftl1(x2, NWORDS_ORDER);\n\t\t\t}\n\t\t}\n\t\t*k += 1;\n\t}\n\n\tif (is_lt_mod_order(order, x1)) {\n\t\tmp_sub(x1, order, x1, NWORDS_ORDER);\n\t}\n}\n\n\nvoid Montgomery_inversion_mod_order_bingcd(const digit_t* a, digit_t* c, const digit_t* order, const digit_t* Montgomery_rprime, const digit_t* Montgomery_Rprime)\n{// Montgomery inversion modulo order, a = a^(-1)*R mod order.\n\tdigit_t x[NWORDS_ORDER], t[NWORDS_ORDER];\n\tunsigned int k;\n\n\tMontgomery_inversion_mod_order_bingcd_partial(a, x, &k, order);\n\tif (k < 384) {\n\t\tMontgomery_multiply_mod_order(x, Montgomery_Rprime, x, order, Montgomery_rprime);\n\t\tk += 384;\n\t}\n\tMontgomery_multiply_mod_order(x, Montgomery_Rprime, x, order, Montgomery_rprime);\n\tpower2_setup(t, 2*384 - k, NWORDS_ORDER);\n\tMontgomery_multiply_mod_order(x, t, c, order, Montgomery_rprime);\n}\n\n\nvoid to_Montgomery_mod_order(const digit_t* a, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime, const digit_t* Montgomery_Rprime)\n{ // Conversion of elements in Z_r to Montgomery representation, where the order r is up to 384 bits.\n\n\tMontgomery_multiply_mod_order(a, Montgomery_Rprime, mc, order, Montgomery_rprime);\n}\n\n\nvoid from_Montgomery_mod_order(const digit_t* ma, digit_t* c, const digit_t* order, const digit_t* Montgomery_rprime)\n{ // Conversion of elements in Z_r from Montgomery to standard representation, where the order is up to 384 bits.\n\tdigit_t one[NWORDS_ORDER] = {0};\n\tone[0] = 1;\n\n\tMontgomery_multiply_mod_order(ma, one, c, order, Montgomery_rprime);\n}\n\n\nvoid inv_mod_orderA(const digit_t* a, digit_t* c)\n{ // Inversion modulo an even integer of the form 2^m.\n  // Algorithm 3: Explicit Quadratic Modular inverse modulo 2^m from Dumas '12: http://arxiv.org/pdf/1209.6626.pdf\n  // NOTE: This function is hardwired for the current parameters using 2^372.\n\tunsigned int i, f, s = 0;\n\tdigit_t am1[NWORDS_ORDER] = {0};\n\tdigit_t tmp1[NWORDS_ORDER] = {0};\n\tdigit_t tmp2[2*NWORDS_ORDER] = {0};\n\tdigit_t one[NWORDS_ORDER] = {0};\n\tdigit_t order[NWORDS_ORDER] = {0};\n    digit_t mask = (digit_t)(-1) >> 12;\n\tbool equal = true;\n\n\torder[NWORDS_ORDER-1] = (digit_t)1 << (sizeof(digit_t)*8 - 12);  // Load most significant digit of Alice's order\n\tone[0] = 1;\n\n\tfor (i = 0; i < NWORDS_ORDER; i++) {\n\t\tif (a[i] != one[0]) equal = false;\n\t}\n\tif (equal) {\n\t\tcopy_words(a, c, NWORDS_ORDER);\n\t} else {\n\t\tmp_sub(a, one, am1, NWORDS_ORDER);               // am1 = a-1\n\t\tmp_sub(order, am1, c, NWORDS_ORDER);\n\t\tmp_add(c, one, c, NWORDS_ORDER);                 // c = 2^m - a + 2\n\n\t\tcopy_words(am1, tmp1, NWORDS_ORDER);\n\t\twhile ((tmp1[0] & (digit_t)1) == 0) {\n\t\t\ts += 1;\n\t\t\tmp_shiftr1(tmp1, NWORDS_ORDER);\n\t\t}\n\n\t\tf = 372 / s;\n\t\tfor (i = 1; i < f; i <<= 1) {\n\t\t\tmultiply(am1, am1, tmp2, NWORDS_ORDER);            // tmp2 = am1^2  \n\t\t\tcopy_words(tmp2, am1, NWORDS_ORDER);\n\t\t\tam1[NWORDS_ORDER-1] &= mask;                       // am1 = tmp2 mod 2^e\n\t\t\tmp_add(am1, one, tmp1, NWORDS_ORDER);              // tmp1 = am1 + 1\n\t\t\ttmp1[NWORDS_ORDER-1] &= mask;                      // mod 2^e\n\t\t\tmultiply(c, tmp1, tmp2, NWORDS_ORDER);             // c = c*tmp1\n\t\t\tcopy_words(tmp2, c, NWORDS_ORDER);\n\t\t\tc[NWORDS_ORDER-1] &= mask;                         // mod 2^e\n\t\t}\n\t}\n}","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for ephemeral \r\n*       Diffie-Hellman key exchange.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: internal header file\r\n*\r\n*********************************************************************************************/  \r\n\r\n#ifndef __SIDH_INTERNAL_H__\r\n#define __SIDH_INTERNAL_H__\r\n\r\n\r\n// For C++\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n\r\n#include \"SIDH_api.h\"   \r\n    \r\n\r\n// Basic constants\r\n\r\n#define ALICE                 0\r\n#define BOB                   1 \r\n#define MAX_INT_POINTS_ALICE  8      \r\n// Fixed parameters for isogeny tree computation    \r\n#define MAX_INT_POINTS_BOB    10 \r\n#define MAX_Alice             185   \r\n#define MAX_Bob               239\r\n   \r\n\r\n// SIDH's basic element definitions and point representations\r\n\r\ntypedef digit_t felm_t[NWORDS_FIELD];                                 // Datatype for representing 751-bit field elements (768-bit max.)\r\ntypedef digit_t dfelm_t[2*NWORDS_FIELD];                              // Datatype for representing double-precision 2x751-bit field elements (2x768-bit max.) \r\ntypedef felm_t  f2elm_t[2];                                           // Datatype for representing quadratic extension field elements GF(p751^2)\r\ntypedef f2elm_t publickey_t[3];                                       // Datatype for representing public keys equivalent to three GF(p751^2) elements\r\n        \r\ntypedef struct { f2elm_t x; f2elm_t y; } point_affine;                // Point representation in affine coordinates on Montgomery curve.\r\ntypedef point_affine point_t[1]; \r\n        \r\ntypedef struct { f2elm_t X; f2elm_t Z; } point_proj;                  // Point representation in projective XZ Montgomery coordinates.\r\ntypedef point_proj point_proj_t[1]; \r\n        \r\ntypedef struct { f2elm_t X; f2elm_t Y; f2elm_t Z; } point_full_proj;  // Point representation in projective XYZ Montgomery coordinates.\r\ntypedef point_full_proj point_full_proj_t[1]; \r\n    \r\ntypedef struct { f2elm_t X2; f2elm_t XZ; f2elm_t Z2; f2elm_t YZ; } point_ext_proj;\r\ntypedef point_ext_proj point_ext_proj_t[1];                           // Point representation in extended projective XYZ Montgomery coordinates.\r\n\r\ntypedef struct { felm_t x; felm_t y; } point_basefield_affine;        // Point representation in affine coordinates on Montgomery curve over the base field.\r\ntypedef point_basefield_affine point_basefield_t[1];  \r\n        \r\ntypedef struct { felm_t X; felm_t Z; } point_basefield_proj;          // Point representation in projective XZ Montgomery coordinates over the base field.\r\ntypedef point_basefield_proj point_basefield_proj_t[1]; \r\n    \r\n\r\n// Macro definitions\r\n\r\n#define NBITS_TO_NBYTES(nbits)      (((nbits)+7)/8)                                          // Conversion macro from number of bits to number of bytes\r\n#define NBITS_TO_NWORDS(nbits)      (((nbits)+(sizeof(digit_t)*8)-1)/(sizeof(digit_t)*8))    // Conversion macro from number of bits to number of computer words\r\n#define NBYTES_TO_NWORDS(nbytes)    (((nbytes)+sizeof(digit_t)-1)/sizeof(digit_t))           // Conversion macro from number of bytes to number of computer words\r\n\r\n// Macro to avoid compiler warnings when detecting unreferenced parameters\r\n#define UNREFERENCED_PARAMETER(PAR) (PAR)\r\n\r\n\r\n/********************** Constant-time unsigned comparisons ***********************/\r\n\r\n// The following functions return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\r\n\r\nstatic __inline unsigned int is_digit_nonzero_ct(digit_t x)\r\n{ // Is x != 0?\r\n    return (unsigned int)((x | (0-x)) >> (RADIX-1));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_zero_ct(digit_t x)\r\n{ // Is x = 0?\r\n    return (unsigned int)(1 ^ is_digit_nonzero_ct(x));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_lessthan_ct(digit_t x, digit_t y)\r\n{ // Is x < y?\r\n    return (unsigned int)((x ^ ((x ^ y) | ((x - y) ^ y))) >> (RADIX-1)); \r\n}\r\n\r\n\r\n/********************** Macros for platform-dependent operations **********************/\r\n\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    digit_x_digit((multiplier), (multiplicand), &(lo));\r\n    \r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { digit_t tempReg = (addend1) + (digit_t)(carryIn);                                           \\\r\n    (sumOut) = (addend2) + tempReg;                                                               \\\r\n    (carryOut) = (is_digit_lessthan_ct(tempReg, (digit_t)(carryIn)) | is_digit_lessthan_ct((sumOut), tempReg)); }\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { digit_t tempReg = (minuend) - (subtrahend);                                                 \\\r\n    unsigned int borrowReg = (is_digit_lessthan_ct((minuend), (subtrahend)) | ((borrowIn) & is_digit_zero_ct(tempReg)));  \\\r\n    (differenceOut) = tempReg - (digit_t)(borrowIn);                                              \\\r\n    (borrowOut) = borrowReg; }\r\n    \r\n// Shift right with flexible datatype\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (DigitSize - (shift)));\r\n    \r\n// Shift left with flexible datatype\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (DigitSize - (shift)));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    mp_mul((digit_t*)&(multiplier), (digit_t*)&(multiplicand), (digit_t*)&(product), NWORDS_FIELD/2);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    (lo) = _umul128((multiplier), (multiplicand), (hi));                \r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    (carryOut) = _addcarry_u64((carryIn), (addend1), (addend2), &(sumOut));\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    (borrowOut) = _subborrow_u64((borrowIn), (minuend), (subtrahend), &(differenceOut));\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftright128((lowIn), (highIn), (shift));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftleft128((lowIn), (highIn), (shift));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    (product)[0] = _umul128((multiplier), (multiplicand), &(product)[1]);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    { unsigned char carry = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);         \\\r\n    _addcarry_u64(carry, (addend1)[1], (addend2)[1], &(addition)[1]); }\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);                       \\\r\n    (carry) = _addcarry_u64((carry), (addend1)[1], (addend2)[1], &(addition)[1]); \r\n\r\n// 128-bit subtraction, subtrahend < 2^127\r\n#define SUB128(minuend, subtrahend, difference)                                                   \\\r\n    { unsigned char borrow = _subborrow_u64(0, (minuend)[0], (subtrahend)[0], &(difference)[0]);  \\\r\n    _subborrow_u64(borrow, (minuend)[1], (subtrahend)[1], &(difference)[1]); }\r\n\r\n// 128-bit right shift, max. shift value is 64\r\n#define SHIFTR128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[0]  = __shiftright128((Input)[0], (Input)[1], (shift));                            \\\r\n    (shiftOut)[1] = (Input)[1] >> (shift);    \r\n\r\n// 128-bit left shift, max. shift value is 64\r\n#define SHIFTL128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[1]  = __shiftleft128((Input)[0], (Input)[1], (shift));                             \\\r\n    (shiftOut)[0] = (Input)[0] << (shift);  \r\n\r\n#define MULADD128(multiplier, multiplicand, addend, carry, result);    \\\r\n    { uint128_t product;                                               \\\r\n      MUL128(multiplier, multiplicand, product);                       \\\r\n      ADC128(addend, product, carry, result); }   \r\n\r\n#elif ((TARGET == TARGET_AMD64 || TARGET == TARGET_ARM64) && OS_TARGET == OS_LINUX)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    { uint128_t tempReg = (uint128_t)(multiplier) * (uint128_t)(multiplicand);                    \\\r\n    *(hi) = (digit_t)(tempReg >> RADIX);                                                          \\\r\n    (lo) = (digit_t)tempReg; }\r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { uint128_t tempReg = (uint128_t)(addend1) + (uint128_t)(addend2) + (uint128_t)(carryIn);     \\\r\n    (carryOut) = (digit_t)(tempReg >> RADIX);                                                     \\\r\n    (sumOut) = (digit_t)tempReg; }  \r\n    \r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { uint128_t tempReg = (uint128_t)(minuend) - (uint128_t)(subtrahend) - (uint128_t)(borrowIn); \\\r\n    (borrowOut) = (digit_t)(tempReg >> (sizeof(uint128_t)*8 - 1));                                \\\r\n    (differenceOut) = (digit_t)tempReg; }\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (RADIX - (shift)));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (RADIX - (shift)));\r\n\r\n#endif\r\n\r\n\r\n// Multiprecision multiplication selection\r\n#if defined(GENERIC_IMPLEMENTATION) && (TARGET == TARGET_AMD64)\r\n    #define mp_mul_comba         mp_mul\r\n#else\r\n    #define mp_mul_schoolbook    mp_mul\r\n#endif\r\n\r\n\r\n\r\n/**************** Function prototypes ****************/\r\n/************* Multiprecision functions **************/ \r\n\r\n// Copy wordsize digits, c = a, where lng(a) = nwords\r\nvoid copy_words(const digit_t* a, digit_t* c, const unsigned int nwords);\r\n\r\n// Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit \r\nunsigned int mp_add(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\n// 751-bit multiprecision addition, c = a+b\r\nvoid mp_add751(const digit_t* a, const digit_t* b, digit_t* c);\r\nvoid mp_add751_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// 2x751-bit multiprecision addition, c = a+b\r\nvoid mp_add751x2(const digit_t* a, const digit_t* b, digit_t* c);\r\nvoid mp_add751x2_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit \r\nunsigned int mp_sub(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\n// Multiprecision right shift by one\r\nvoid mp_shiftr1(digit_t* x, const unsigned int nwords);\r\n\r\n// Multiprecision left right shift by one    \r\nvoid mp_shiftl1(digit_t* x, const unsigned int nwords);\r\n\r\n// Digit multiplication, digit * digit -> 2-digit result\r\nvoid digit_x_digit(const digit_t a, const digit_t b, digit_t* c);    \r\n\r\n// Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_schoolbook(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\n// Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_comba(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\nvoid multiply(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords); \r\n\r\n// Montgomery multiplication modulo the group order, mc = ma*mb*r' mod order, where ma,mb,mc in [0, order-1]\r\nvoid Montgomery_multiply_mod_order(const digit_t* ma, const digit_t* mb, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime);\r\n\r\n// (Non-constant time) Montgomery inversion modulo the curve order using a^(-1) = a^(order-2) mod order\r\nvoid Montgomery_inversion_mod_order(const digit_t* ma, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime);\r\n\r\nvoid Montgomery_inversion_mod_order_bingcd(const digit_t* a, digit_t* c, const digit_t* order, const digit_t* Montgomery_rprime, const digit_t* Montgomery_R2);\r\n\r\n// Conversion of elements in Z_r to Montgomery representation, where the order r is up to 384 bits.\r\nvoid to_Montgomery_mod_order(const digit_t* a, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime, const digit_t* Montgomery_Rprime);\r\n\r\n// Conversion of elements in Z_r from Montgomery to standard representation, where the order is up to 384 bits.\r\nvoid from_Montgomery_mod_order(const digit_t* ma, digit_t* c, const digit_t* order, const digit_t* Montgomery_rprime);\r\n\r\n// Inversion modulo Alice's order 2^372.\r\nvoid inv_mod_orderA(const digit_t* a, digit_t* c);\r\n\r\n/************ Field arithmetic functions *************/\r\n\r\n// Copy of a field element, c = a\r\nvoid fpcopy751(const felm_t a, felm_t c);\r\n\r\n// Zeroing a field element, a = 0\r\nvoid fpzero751(felm_t a);\r\n\r\n// Non constant-time comparison of two field elements. If a = b return TRUE, otherwise, return FALSE\r\nbool fpequal751_non_constant_time(const felm_t a, const felm_t b); \r\n\r\n// Modular addition, c = a+b mod p751\r\nextern void fpadd751(const digit_t* a, const digit_t* b, digit_t* c);\r\nextern void fpadd751_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// Modular subtraction, c = a-b mod p751\r\nextern void fpsub751(const digit_t* a, const digit_t* b, digit_t* c);\r\nextern void fpsub751_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// Modular negation, a = -a mod p751        \r\nextern void fpneg751(digit_t* a);  \r\n\r\n// Modular division by two, c = a/2 mod p751.\r\nvoid fpdiv2_751(const digit_t* a, digit_t* c);\r\n\r\n// Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].\r\nvoid fpcorrection751(digit_t* a);\r\n\r\n// 751-bit Montgomery reduction, c = a mod p\r\nvoid rdc_mont(const digit_t* a, digit_t* c);\r\n            \r\n// Field multiplication using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpmul751_mont(const felm_t a, const felm_t b, felm_t c);\r\nvoid mul751_asm(const felm_t a, const felm_t b, dfelm_t c);\r\nvoid rdc751_asm(const dfelm_t ma, dfelm_t mc);\r\n   \r\n// Field squaring using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpsqr751_mont(const felm_t ma, felm_t mc);\r\n\r\n// Conversion to Montgomery representation\r\nvoid to_mont(const felm_t a, felm_t mc);\r\n    \r\n// Conversion from Montgomery representation to standard representation\r\nvoid from_mont(const felm_t ma, felm_t c);\r\n\r\n// Field inversion, a = a^-1 in GF(p751)\r\nvoid fpinv751_mont(felm_t a);\r\n\r\n// Field inversion, a = a^-1 in GF(p751) using the binary GCD \r\nvoid fpinv751_mont_bingcd(felm_t a);\r\n\r\n// Chain to compute (p751-3)/4 using Montgomery arithmetic\r\nvoid fpinv751_chain_mont(felm_t a);\r\n\r\n/************ GF(p^2) arithmetic functions *************/\r\n    \r\n// Copy of a GF(p751^2) element, c = a\r\nvoid fp2copy751(const f2elm_t a, f2elm_t c);\r\n\r\n// Zeroing a GF(p751^2) element, a = 0\r\nvoid fp2zero751(f2elm_t a);\r\n\r\n// GF(p751^2) negation, a = -a in GF(p751^2)\r\nvoid fp2neg751(f2elm_t a);\r\n\r\n// GF(p751^2) addition, c = a+b in GF(p751^2)\r\nextern void fp2add751(const f2elm_t a, const f2elm_t b, f2elm_t c);           \r\n\r\n// GF(p751^2) subtraction, c = a-b in GF(p751^2)\r\nextern void fp2sub751(const f2elm_t a, const f2elm_t b, f2elm_t c); \r\n\r\n// GF(p751^2) division by two, c = a/2  in GF(p751^2) \r\nvoid fp2div2_751(const f2elm_t a, f2elm_t c);\r\n\r\n// Modular correction, a = a in GF(p751^2)\r\nvoid fp2correction751(f2elm_t a);\r\n            \r\n// GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)\r\nvoid fp2sqr751_mont(const f2elm_t a, f2elm_t c);\r\n \r\n// GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)\r\nvoid fp2mul751_mont(const f2elm_t a, const f2elm_t b, f2elm_t c);\r\n    \r\n// Conversion of a GF(p751^2) element to Montgomery representation\r\nvoid to_fp2mont(const f2elm_t a, f2elm_t mc);\r\n\r\n// Conversion of a GF(p751^2) element from Montgomery representation to standard representation\r\nvoid from_fp2mont(const f2elm_t ma, f2elm_t c);\r\n\r\n// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)\r\nvoid fp2inv751_mont(f2elm_t a);\r\n\r\n// GF(p751^2) inversion, a = (a0-i*a1)/(a0^2+a1^2), GF(p751) inversion done using the binary GCD \r\nvoid fp2inv751_mont_bingcd(f2elm_t a);\r\n\r\n// n-way Montgomery inversion\r\nvoid mont_n_way_inv(const f2elm_t* vec, const int n, f2elm_t* out);\r\n\r\n// Select either x or y depending on value of option \r\nvoid select_f2elm(const f2elm_t x, const f2elm_t y, f2elm_t z, const digit_t option);\r\n\r\n// Computes square roots of elements in (Fp2)^2 using Hamburg's trick.\r\nvoid sqrt_Fp2(const f2elm_t u, f2elm_t y);\r\n\r\n// Computes square roots of elements in (Fp2)^2 using Hamburg's trick\r\nvoid sqrt_Fp2_frac(const f2elm_t u, const f2elm_t v, f2elm_t y);\r\n\r\n// Cyclotomic cubing on elements of norm 1, using a^(p+1) = 1\r\nvoid cube_Fp2_cycl(f2elm_t a, const felm_t one);\r\n\r\n// Cyclotomic squaring on elements of norm 1, using a^(p+1) = 1\r\nvoid sqr_Fp2_cycl(f2elm_t a, const felm_t one);\r\n\r\n// Cyclotomic inversion, a^(p+1) = 1 => a^(-1) = a^p = a0 - i*a1\r\nextern void inv_Fp2_cycl(f2elm_t a);\r\n\r\n// Check if GF(p751^2) element is cube\r\nbool is_cube_Fp2(f2elm_t u, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 6 bits at most\r\nvoid exp6_Fp2_cycl(const f2elm_t y, const uint64_t t, const felm_t one, f2elm_t res);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 21 bits at most\r\nvoid exp21_Fp2_cycl(const f2elm_t y, const uint64_t t, const felm_t one, f2elm_t res);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 84 bits at most\r\nvoid exp84_Fp2_cycl(const f2elm_t y, uint64_t* t, const felm_t one, f2elm_t res);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is length bits.\r\nvoid exp_Fp2_cycl(const f2elm_t y, uint64_t* t, const felm_t one, f2elm_t res, int length);\r\n\r\n/************ Elliptic curve and isogeny functions *************/\r\n\r\n// Check if curve isogeny structure is NULL\r\nbool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny);\r\n\r\n// Swap points over the base field \r\nvoid swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, const digit_t option);\r\n\r\n// Swap points\r\nvoid swap_points(point_proj_t P, point_proj_t Q, const digit_t option);\r\n\r\n// Computes the j-invariant of a Montgomery curve with projective constant.\r\nvoid j_inv(const f2elm_t A, const f2elm_t C, f2elm_t jinv);\r\n\r\n// Simultaneous doubling and differential addition.\r\nvoid xDBLADD(point_proj_t P, point_proj_t Q, const f2elm_t xPQ, const f2elm_t A24);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xDBL(const point_proj_t P, point_proj_t Q, const f2elm_t A24, const f2elm_t C24);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.\r\nvoid xDBLe(const point_proj_t P, point_proj_t Q, const f2elm_t A, const f2elm_t C, const int e);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings and collects a few intermediate multiples.\r\nvoid xDBLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Differential addition.\r\nvoid xADD(point_proj_t P, const point_proj_t Q, const f2elm_t xPQ);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.\r\nvoid xDBL_basefield(const point_basefield_proj_t P, point_basefield_proj_t Q);\r\n\r\n// Simultaneous doubling and differential addition over the base field.\r\nvoid xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, const felm_t xPQ, const felm_t A24);\r\n\r\n// The Montgomery ladder\r\nvoid ladder(const felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, const felm_t A24, const unsigned int order_bits, const unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes key generation entirely in the base field\r\nCRYPTO_STATUS secret_pt(const point_basefield_t P, const digit_t* m, const unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes P+[m]Q via x-only arithmetic.\r\nCRYPTO_STATUS ladder_3_pt(const f2elm_t xP, const f2elm_t xQ, const f2elm_t xPQ, const digit_t* m, const unsigned int AliceOrBob, point_proj_t W, const f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.\r\nvoid get_4_isog(const point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff);\r\n\r\n// Evaluates the isogeny at the point (X:Z) in the domain of the isogeny\r\nvoid eval_4_isog(point_proj_t P, f2elm_t* coeff);\r\n\r\n// Computes first 4-isogeny computed by Alice.\r\nvoid first_4_isog(point_proj_t P, const f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Tripling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xTPL(const point_proj_t P, point_proj_t Q, const f2elm_t A24, const f2elm_t C24);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.\r\nvoid xTPLe(const point_proj_t P, point_proj_t Q, const f2elm_t A, const f2elm_t C, const int e);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings and collects a few intermediate multiples.    \r\nvoid xTPLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.\r\nvoid get_3_isog(const point_proj_t P, f2elm_t A, f2elm_t C);\r\n\r\n// Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).\r\nvoid eval_3_isog(const point_proj_t P, point_proj_t Q);\r\n\r\n// 3-way simultaneous inversion\r\nvoid inv_3_way(f2elm_t z1, f2elm_t z2, f2elm_t z3);\r\n\r\n// Computing the point D = (x(Q-P),z(Q-P))\r\nvoid distort_and_diff(const felm_t xP, point_proj_t d, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Given the x-coordinates of P, Q, and R, returns the value A corresponding to the Montgomery curve E_A: y^2=x^3+A*x^2+x such that R=Q-P on E_A.\r\nvoid get_A(const f2elm_t xP, const f2elm_t xQ, const f2elm_t xR, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n/************ Functions for compression *************/\r\n\r\n// Produces points R1 and R2 as basis for E[2^372]\r\nvoid generate_2_torsion_basis(const f2elm_t A, point_full_proj_t R1, point_full_proj_t R2, PCurveIsogenyStruct CurveIsogeny); \r\n\r\n// Produces points R1 and R2 as basis for E[3^239]\r\nvoid generate_3_torsion_basis(f2elm_t A, point_full_proj_t R1, point_full_proj_t R2, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// 2-torsion Tate pairing\r\nvoid Tate_pairings_2_torsion(const point_t R1, const point_t R2, const point_t P, const point_t Q, const f2elm_t A, f2elm_t* n, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// 3-torsion Tate pairing\r\nvoid Tate_pairings_3_torsion(const point_t R1, const point_t R2, const point_t P, const point_t Q, const f2elm_t A, f2elm_t* n, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// The Montgomery ladder, running in non constant-time\r\nvoid Mont_ladder(const f2elm_t x, const digit_t* m, point_proj_t P, point_proj_t Q, const f2elm_t A24, const unsigned int order_bits, const unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// General addition\r\nvoid ADD(const point_full_proj_t P, const f2elm_t QX, const f2elm_t QY, const f2elm_t QZ, const f2elm_t A, point_full_proj_t R);\r\n\r\n// 2-torsion Pohlig-Hellman function\r\nvoid ph2(const point_t phiP, const point_t phiQ, const point_t PS, const point_t QS, const f2elm_t A, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Lookup table generation for 2-torsion PH\r\nvoid build_LUTs(const f2elm_t u, f2elm_t* t_ori, f2elm_t* LUT, f2elm_t* LUT_0, f2elm_t* LUT_1, f2elm_t* LUT_3, const felm_t one);\r\n\r\n// Pohlig-Hellman for groups of 2-power order up to 2^6 \r\nvoid phn1(const f2elm_t q, const f2elm_t* LUT, const uint64_t a, const felm_t one, uint64_t* alpha_i);\r\n\r\n// Pohlig-Hellman for groups of 2-power order 2^21 \r\nvoid phn5(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 2-power order 2^84 \r\nvoid phn21(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 2-power order 2^372 \r\nvoid phn84(f2elm_t r, const f2elm_t* t_ori, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const f2elm_t* LUT_3, const felm_t one, uint64_t* alpha);\r\n\r\n// 3-torsion Pohlig-Hellman function       \r\nvoid ph3(point_t phiP, point_t phiQ, point_t PS, point_t QS, f2elm_t A, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Lookup table generation for 3-torsion PH\r\nvoid build_LUTs_3(f2elm_t g, f2elm_t* t_ori, f2elm_t* LUT, f2elm_t* LUT_0, f2elm_t* LUT_1, const felm_t one);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up to 3^2 or 3^3 \r\nvoid phn1_3(const f2elm_t q, const f2elm_t* LUT, const uint64_t a, const felm_t one, uint64_t* alpha_i);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^15\r\nvoid phn3(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^56\r\nvoid phn15_1(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^61\r\nvoid phn15(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^239\r\nvoid phn61(f2elm_t r, f2elm_t* t_ori, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha);\r\n\n// Recover the y-coordinates of the public key\nvoid recover_y(const publickey_t PK, point_full_proj_t phiP, point_full_proj_t phiQ, point_full_proj_t phiX, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\n// Computes the input modulo 3. The input is assumed to be NWORDS_ORDER long \nunsigned int mod3(digit_t* a); \r\n\n// Computes R+aS\nvoid mont_twodim_scalarmult(digit_t* a, const point_t R, const point_t S, const f2elm_t A, const f2elm_t A24, point_full_proj_t P, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n\r\nvoid compress_2_torsion(const unsigned char* PublicKeyA, unsigned char* CompressedPKA, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, point_t R1, point_t R2, PCurveIsogenyStruct CurveIsogeny);\r\nvoid compress_3_torsion(const unsigned char* PublicKeyA, unsigned char* CompressedPKA, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, point_t R1, point_t R2, PCurveIsogenyStruct CurveIsogeny);\r\nvoid decompress_2_torsion(const unsigned char* SecretKey, const unsigned char* CompressedPKA, point_proj_t R, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\nvoid decompress_3_torsion(const unsigned char* SecretKey, const unsigned char* CompressedPKA, point_proj_t R, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n\r\n#endif\r\n","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for ephemeral \r\n*       Diffie-Hellman key exchange.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: portable modular arithmetic\r\n*\r\n*********************************************************************************************/\r\n\r\n#include \"../SIDH_internal.h\"\r\n\r\n\r\n// Global constants\r\nextern const uint64_t p751[NWORDS_FIELD];\r\nextern const uint64_t p751p1[NWORDS_FIELD]; \r\nextern const uint64_t p751x2[NWORDS_FIELD]; \r\n\r\n\r\n__inline void fpadd751(const digit_t* a, const digit_t* b, digit_t* c)\r\n{ // Modular addition, c = a+b mod p751.\r\n  // Inputs: a, b in [0, 2*p751-1] \r\n  // Output: c in [0, 2*p751-1] \r\n    unsigned int i, carry = 0;\r\n    digit_t mask;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(carry, a[i], b[i], carry, c[i]); \r\n    }\r\n\r\n    carry = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        SUBC(carry, c[i], ((digit_t*)p751x2)[i], carry, c[i]); \r\n    }\r\n    mask = 0 - (digit_t)carry;\r\n\r\n    carry = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(carry, c[i], ((digit_t*)p751x2)[i] & mask, carry, c[i]); \r\n    }\r\n} \r\n\r\n\r\n__inline void fpsub751(const digit_t* a, const digit_t* b, digit_t* c)\r\n{ // Modular subtraction, c = a-b mod p751.\r\n  // Inputs: a, b in [0, 2*p751-1] \r\n  // Output: c in [0, 2*p751-1] \r\n    unsigned int i, borrow = 0;\r\n    digit_t mask;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        SUBC(borrow, a[i], b[i], borrow, c[i]); \r\n    }\r\n    mask = 0 - (digit_t)borrow;\r\n\r\n    borrow = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(borrow, c[i], ((digit_t*)p751x2)[i] & mask, borrow, c[i]); \r\n    }\r\n}\r\n\r\n\r\n__inline void fpneg751(digit_t* a)\r\n{ // Modular negation, a = -a mod p751.\r\n  // Input/output: a in [0, 2*p751-1] \r\n    unsigned int i, borrow = 0;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        SUBC(borrow, ((digit_t*)p751x2)[i], a[i], borrow, a[i]); \r\n    }\r\n}\r\n\r\n\r\nvoid fpdiv2_751(const digit_t* a, digit_t* c)\r\n{ // Modular division by two, c = a/2 mod p751.\r\n  // Input : a in [0, 2*p751-1] \r\n  // Output: c in [0, 2*p751-1] \r\n    unsigned int i, carry = 0;\r\n    digit_t mask;\r\n        \r\n    mask = 0 - (digit_t)(a[0] & 1);    // If a is odd compute a+p751\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(carry, a[i], ((digit_t*)p751)[i] & mask, carry, c[i]); \r\n    }\r\n\r\n    mp_shiftr1(c, NWORDS_FIELD);\r\n} \r\n\r\n\r\nvoid fpcorrection751(digit_t* a)\r\n{ // Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].\r\n    unsigned int i, borrow = 0;\r\n    digit_t mask;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        SUBC(borrow, a[i], ((digit_t*)p751)[i], borrow, a[i]); \r\n    }\r\n    mask = 0 - (digit_t)borrow;\r\n\r\n    borrow = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(borrow, a[i], ((digit_t*)p751)[i] & mask, borrow, a[i]); \r\n    }\r\n}\r\n\r\n\r\nvoid digit_x_digit(const digit_t a, const digit_t b, digit_t* c)\r\n{ // Digit multiplication, digit * digit -> 2-digit result    \r\n    register digit_t al, ah, bl, bh, temp;\r\n    digit_t albl, albh, ahbl, ahbh, res1, res2, res3, carry;\r\n    digit_t mask_low = (digit_t)(-1) >> (sizeof(digit_t)*4), mask_high = (digit_t)(-1) << (sizeof(digit_t)*4);\r\n\r\n    al = a & mask_low;                        // Low part\r\n    ah = a >> (sizeof(digit_t) * 4);          // High part\r\n    bl = b & mask_low;\r\n    bh = b >> (sizeof(digit_t) * 4);\r\n\r\n    albl = al*bl;\r\n    albh = al*bh;\r\n    ahbl = ah*bl;\r\n    ahbh = ah*bh;\r\n    c[0] = albl & mask_low;                   // C00\r\n\r\n    res1 = albl >> (sizeof(digit_t) * 4);\r\n    res2 = ahbl & mask_low;\r\n    res3 = albh & mask_low;  \r\n    temp = res1 + res2 + res3;\r\n    carry = temp >> (sizeof(digit_t) * 4);\r\n    c[0] ^= temp << (sizeof(digit_t) * 4);    // C01   \r\n\r\n    res1 = ahbl >> (sizeof(digit_t) * 4);\r\n    res2 = albh >> (sizeof(digit_t) * 4);\r\n    res3 = ahbh & mask_low;\r\n    temp = res1 + res2 + res3 + carry;\r\n    c[1] = temp & mask_low;                   // C10 \r\n    carry = temp & mask_high; \r\n    c[1] ^= (ahbh & mask_high) + carry;       // C11\r\n}\r\n\r\n \r\nvoid mp_mul_schoolbook(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords)\r\n{ // Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.   \r\n    unsigned int i, j;\r\n    digit_t u, v, UV[2];\r\n    unsigned int carry = 0;\r\n\r\n     for (i = 0; i < (2*nwords); i++) c[i] = 0;\r\n\r\n     for (i = 0; i < nwords; i++) {\r\n          u = 0;\r\n          for (j = 0; j < nwords; j++) {\r\n               MUL(a[i], b[j], UV+1, UV[0]); \r\n               ADDC(0, UV[0], u, carry, v); \r\n               u = UV[1] + carry;\r\n               ADDC(0, c[i+j], v, carry, v); \r\n               u = u + carry;\r\n               c[i+j] = v;\r\n          }\r\n          c[nwords+i] = u;\r\n     }\r\n}\r\n\r\n\r\nvoid mp_mul_comba(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords)\r\n{ // Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.   \r\n    unsigned int i, j;\r\n    digit_t t = 0, u = 0, v = 0, UV[2];\r\n    unsigned int carry = 0;\r\n    \r\n    for (i = 0; i < nwords; i++) {\r\n        for (j = 0; j <= i; j++) {\r\n            MUL(a[j], b[i-j], UV+1, UV[0]); \r\n            ADDC(0, UV[0], v, carry, v); \r\n            ADDC(carry, UV[1], u, carry, u); \r\n            t += carry;\r\n        }\r\n        c[i] = v;\r\n        v = u; \r\n        u = t;\r\n        t = 0;\r\n    }\r\n\r\n    for (i = nwords; i < 2*nwords-1; i++) {\r\n        for (j = i-nwords+1; j < nwords; j++) {\r\n            MUL(a[j], b[i-j], UV+1, UV[0]); \r\n            ADDC(0, UV[0], v, carry, v); \r\n            ADDC(carry, UV[1], u, carry, u); \r\n            t += carry;\r\n        }\r\n        c[i] = v;\r\n        v = u; \r\n        u = t;\r\n        t = 0;\r\n    }\r\n    c[2*nwords-1] = v; \r\n}\r\n\r\n\r\nvoid rdc_mont(const dfelm_t ma, felm_t mc)\r\n{ // Efficient Montgomery reduction using comba and exploiting the special form of the prime p751.\r\n  // mc = ma*R^-1 mod p751x2, where R = 2^768.\r\n  // If ma < 2^768*p751, the output mc is in the range [0, 2*p751-1].\r\n  // ma is assumed to be in Montgomery representation.\r\n    unsigned int i, j, carry, count = p751_ZERO_WORDS;\r\n    digit_t UV[2], t = 0, u = 0, v = 0;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        mc[i] = 0;\r\n    }\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        for (j = 0; j < i; j++) {\r\n            if (j < (i-p751_ZERO_WORDS+1)) { \r\n                MUL(mc[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);\r\n                ADDC(0, UV[0], v, carry, v); \r\n                ADDC(carry, UV[1], u, carry, u); \r\n                t += carry; \r\n            }\r\n        }\r\n        ADDC(0, v, ma[i], carry, v); \r\n        ADDC(carry, u, 0, carry, u); \r\n        t += carry; \r\n        mc[i] = v;\r\n        v = u;\r\n        u = t;\r\n        t = 0;\r\n    }    \r\n\r\n    for (i = NWORDS_FIELD; i < 2*NWORDS_FIELD-1; i++) {\r\n        if (count > 0) {\r\n            count -= 1;\r\n        }\r\n        for (j = i-NWORDS_FIELD+1; j < NWORDS_FIELD; j++) {\r\n            if (j < (NWORDS_FIELD-count)) { \r\n                MUL(mc[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);\r\n                ADDC(0, UV[0], v, carry, v); \r\n                ADDC(carry, UV[1], u, carry, u); \r\n                t += carry;\r\n            }\r\n        }\r\n        ADDC(0, v, ma[i], carry, v); \r\n        ADDC(carry, u, 0, carry, u); \r\n        t += carry; \r\n        mc[i-NWORDS_FIELD] = v;\r\n        v = u;\r\n        u = t;\r\n        t = 0;\r\n    }\r\n    ADDC(0, v, ma[2*NWORDS_FIELD-1], carry, v); \r\n    mc[NWORDS_FIELD-1] = v;\r\n}","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for ephemeral \r\n*       Diffie-Hellman key exchange.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: internal header file\r\n*\r\n*********************************************************************************************/  \r\n\r\n#ifndef __SIDH_INTERNAL_H__\r\n#define __SIDH_INTERNAL_H__\r\n\r\n\r\n// For C++\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n\r\n#include \"SIDH_api.h\"   \r\n    \r\n\r\n// Basic constants\r\n\r\n#define ALICE                 0\r\n#define BOB                   1 \r\n#define MAX_INT_POINTS_ALICE  8      \r\n// Fixed parameters for isogeny tree computation    \r\n#define MAX_INT_POINTS_BOB    10 \r\n#define MAX_Alice             185   \r\n#define MAX_Bob               239\r\n   \r\n\r\n// SIDH's basic element definitions and point representations\r\n\r\ntypedef digit_t felm_t[NWORDS_FIELD];                                 // Datatype for representing 751-bit field elements (768-bit max.)\r\ntypedef digit_t dfelm_t[2*NWORDS_FIELD];                              // Datatype for representing double-precision 2x751-bit field elements (2x768-bit max.) \r\ntypedef felm_t  f2elm_t[2];                                           // Datatype for representing quadratic extension field elements GF(p751^2)\r\ntypedef f2elm_t publickey_t[3];                                       // Datatype for representing public keys equivalent to three GF(p751^2) elements\r\n        \r\ntypedef struct { f2elm_t x; f2elm_t y; } point_affine;                // Point representation in affine coordinates on Montgomery curve.\r\ntypedef point_affine point_t[1]; \r\n        \r\ntypedef struct { f2elm_t X; f2elm_t Z; } point_proj;                  // Point representation in projective XZ Montgomery coordinates.\r\ntypedef point_proj point_proj_t[1]; \r\n        \r\ntypedef struct { f2elm_t X; f2elm_t Y; f2elm_t Z; } point_full_proj;  // Point representation in projective XYZ Montgomery coordinates.\r\ntypedef point_full_proj point_full_proj_t[1]; \r\n    \r\ntypedef struct { f2elm_t X2; f2elm_t XZ; f2elm_t Z2; f2elm_t YZ; } point_ext_proj;\r\ntypedef point_ext_proj point_ext_proj_t[1];                           // Point representation in extended projective XYZ Montgomery coordinates.\r\n\r\ntypedef struct { felm_t x; felm_t y; } point_basefield_affine;        // Point representation in affine coordinates on Montgomery curve over the base field.\r\ntypedef point_basefield_affine point_basefield_t[1];  \r\n        \r\ntypedef struct { felm_t X; felm_t Z; } point_basefield_proj;          // Point representation in projective XZ Montgomery coordinates over the base field.\r\ntypedef point_basefield_proj point_basefield_proj_t[1]; \r\n    \r\n\r\n// Macro definitions\r\n\r\n#define NBITS_TO_NBYTES(nbits)      (((nbits)+7)/8)                                          // Conversion macro from number of bits to number of bytes\r\n#define NBITS_TO_NWORDS(nbits)      (((nbits)+(sizeof(digit_t)*8)-1)/(sizeof(digit_t)*8))    // Conversion macro from number of bits to number of computer words\r\n#define NBYTES_TO_NWORDS(nbytes)    (((nbytes)+sizeof(digit_t)-1)/sizeof(digit_t))           // Conversion macro from number of bytes to number of computer words\r\n\r\n// Macro to avoid compiler warnings when detecting unreferenced parameters\r\n#define UNREFERENCED_PARAMETER(PAR) (PAR)\r\n\r\n\r\n/********************** Constant-time unsigned comparisons ***********************/\r\n\r\n// The following functions return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\r\n\r\nstatic __inline unsigned int is_digit_nonzero_ct(digit_t x)\r\n{ // Is x != 0?\r\n    return (unsigned int)((x | (0-x)) >> (RADIX-1));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_zero_ct(digit_t x)\r\n{ // Is x = 0?\r\n    return (unsigned int)(1 ^ is_digit_nonzero_ct(x));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_lessthan_ct(digit_t x, digit_t y)\r\n{ // Is x < y?\r\n    return (unsigned int)((x ^ ((x ^ y) | ((x - y) ^ y))) >> (RADIX-1)); \r\n}\r\n\r\n\r\n/********************** Macros for platform-dependent operations **********************/\r\n\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    digit_x_digit((multiplier), (multiplicand), &(lo));\r\n    \r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { digit_t tempReg = (addend1) + (digit_t)(carryIn);                                           \\\r\n    (sumOut) = (addend2) + tempReg;                                                               \\\r\n    (carryOut) = (is_digit_lessthan_ct(tempReg, (digit_t)(carryIn)) | is_digit_lessthan_ct((sumOut), tempReg)); }\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { digit_t tempReg = (minuend) - (subtrahend);                                                 \\\r\n    unsigned int borrowReg = (is_digit_lessthan_ct((minuend), (subtrahend)) | ((borrowIn) & is_digit_zero_ct(tempReg)));  \\\r\n    (differenceOut) = tempReg - (digit_t)(borrowIn);                                              \\\r\n    (borrowOut) = borrowReg; }\r\n    \r\n// Shift right with flexible datatype\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (DigitSize - (shift)));\r\n    \r\n// Shift left with flexible datatype\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (DigitSize - (shift)));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    mp_mul((digit_t*)&(multiplier), (digit_t*)&(multiplicand), (digit_t*)&(product), NWORDS_FIELD/2);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    (lo) = _umul128((multiplier), (multiplicand), (hi));                \r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    (carryOut) = _addcarry_u64((carryIn), (addend1), (addend2), &(sumOut));\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    (borrowOut) = _subborrow_u64((borrowIn), (minuend), (subtrahend), &(differenceOut));\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftright128((lowIn), (highIn), (shift));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftleft128((lowIn), (highIn), (shift));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    (product)[0] = _umul128((multiplier), (multiplicand), &(product)[1]);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    { unsigned char carry = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);         \\\r\n    _addcarry_u64(carry, (addend1)[1], (addend2)[1], &(addition)[1]); }\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);                       \\\r\n    (carry) = _addcarry_u64((carry), (addend1)[1], (addend2)[1], &(addition)[1]); \r\n\r\n// 128-bit subtraction, subtrahend < 2^127\r\n#define SUB128(minuend, subtrahend, difference)                                                   \\\r\n    { unsigned char borrow = _subborrow_u64(0, (minuend)[0], (subtrahend)[0], &(difference)[0]);  \\\r\n    _subborrow_u64(borrow, (minuend)[1], (subtrahend)[1], &(difference)[1]); }\r\n\r\n// 128-bit right shift, max. shift value is 64\r\n#define SHIFTR128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[0]  = __shiftright128((Input)[0], (Input)[1], (shift));                            \\\r\n    (shiftOut)[1] = (Input)[1] >> (shift);    \r\n\r\n// 128-bit left shift, max. shift value is 64\r\n#define SHIFTL128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[1]  = __shiftleft128((Input)[0], (Input)[1], (shift));                             \\\r\n    (shiftOut)[0] = (Input)[0] << (shift);  \r\n\r\n#define MULADD128(multiplier, multiplicand, addend, carry, result);    \\\r\n    { uint128_t product;                                               \\\r\n      MUL128(multiplier, multiplicand, product);                       \\\r\n      ADC128(addend, product, carry, result); }   \r\n\r\n#elif ((TARGET == TARGET_AMD64 || TARGET == TARGET_ARM64) && OS_TARGET == OS_LINUX)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    { uint128_t tempReg = (uint128_t)(multiplier) * (uint128_t)(multiplicand);                    \\\r\n    *(hi) = (digit_t)(tempReg >> RADIX);                                                          \\\r\n    (lo) = (digit_t)tempReg; }\r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { uint128_t tempReg = (uint128_t)(addend1) + (uint128_t)(addend2) + (uint128_t)(carryIn);     \\\r\n    (carryOut) = (digit_t)(tempReg >> RADIX);                                                     \\\r\n    (sumOut) = (digit_t)tempReg; }  \r\n    \r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { uint128_t tempReg = (uint128_t)(minuend) - (uint128_t)(subtrahend) - (uint128_t)(borrowIn); \\\r\n    (borrowOut) = (digit_t)(tempReg >> (sizeof(uint128_t)*8 - 1));                                \\\r\n    (differenceOut) = (digit_t)tempReg; }\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (RADIX - (shift)));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (RADIX - (shift)));\r\n\r\n#endif\r\n\r\n\r\n// Multiprecision multiplication selection\r\n#if defined(GENERIC_IMPLEMENTATION) && (TARGET == TARGET_AMD64)\r\n    #define mp_mul_comba         mp_mul\r\n#else\r\n    #define mp_mul_schoolbook    mp_mul\r\n#endif\r\n\r\n\r\n\r\n/**************** Function prototypes ****************/\r\n/************* Multiprecision functions **************/ \r\n\r\n// Copy wordsize digits, c = a, where lng(a) = nwords\r\nvoid copy_words(const digit_t* a, digit_t* c, const unsigned int nwords);\r\n\r\n// Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit \r\nunsigned int mp_add(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\n// 751-bit multiprecision addition, c = a+b\r\nvoid mp_add751(const digit_t* a, const digit_t* b, digit_t* c);\r\nvoid mp_add751_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// 2x751-bit multiprecision addition, c = a+b\r\nvoid mp_add751x2(const digit_t* a, const digit_t* b, digit_t* c);\r\nvoid mp_add751x2_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit \r\nunsigned int mp_sub(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\n// Multiprecision right shift by one\r\nvoid mp_shiftr1(digit_t* x, const unsigned int nwords);\r\n\r\n// Multiprecision left right shift by one    \r\nvoid mp_shiftl1(digit_t* x, const unsigned int nwords);\r\n\r\n// Digit multiplication, digit * digit -> 2-digit result\r\nvoid digit_x_digit(const digit_t a, const digit_t b, digit_t* c);    \r\n\r\n// Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_schoolbook(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\n// Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_comba(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords);\r\n\r\nvoid multiply(const digit_t* a, const digit_t* b, digit_t* c, const unsigned int nwords); \r\n\r\n// Montgomery multiplication modulo the group order, mc = ma*mb*r' mod order, where ma,mb,mc in [0, order-1]\r\nvoid Montgomery_multiply_mod_order(const digit_t* ma, const digit_t* mb, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime);\r\n\r\n// (Non-constant time) Montgomery inversion modulo the curve order using a^(-1) = a^(order-2) mod order\r\nvoid Montgomery_inversion_mod_order(const digit_t* ma, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime);\r\n\r\nvoid Montgomery_inversion_mod_order_bingcd(const digit_t* a, digit_t* c, const digit_t* order, const digit_t* Montgomery_rprime, const digit_t* Montgomery_R2);\r\n\r\n// Conversion of elements in Z_r to Montgomery representation, where the order r is up to 384 bits.\r\nvoid to_Montgomery_mod_order(const digit_t* a, digit_t* mc, const digit_t* order, const digit_t* Montgomery_rprime, const digit_t* Montgomery_Rprime);\r\n\r\n// Conversion of elements in Z_r from Montgomery to standard representation, where the order is up to 384 bits.\r\nvoid from_Montgomery_mod_order(const digit_t* ma, digit_t* c, const digit_t* order, const digit_t* Montgomery_rprime);\r\n\r\n// Inversion modulo Alice's order 2^372.\r\nvoid inv_mod_orderA(const digit_t* a, digit_t* c);\r\n\r\n/************ Field arithmetic functions *************/\r\n\r\n// Copy of a field element, c = a\r\nvoid fpcopy751(const felm_t a, felm_t c);\r\n\r\n// Zeroing a field element, a = 0\r\nvoid fpzero751(felm_t a);\r\n\r\n// Non constant-time comparison of two field elements. If a = b return TRUE, otherwise, return FALSE\r\nbool fpequal751_non_constant_time(const felm_t a, const felm_t b); \r\n\r\n// Modular addition, c = a+b mod p751\r\nextern void fpadd751(const digit_t* a, const digit_t* b, digit_t* c);\r\nextern void fpadd751_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// Modular subtraction, c = a-b mod p751\r\nextern void fpsub751(const digit_t* a, const digit_t* b, digit_t* c);\r\nextern void fpsub751_asm(const digit_t* a, const digit_t* b, digit_t* c);\r\n\r\n// Modular negation, a = -a mod p751        \r\nextern void fpneg751(digit_t* a);  \r\n\r\n// Modular division by two, c = a/2 mod p751.\r\nvoid fpdiv2_751(const digit_t* a, digit_t* c);\r\n\r\n// Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].\r\nvoid fpcorrection751(digit_t* a);\r\n\r\n// 751-bit Montgomery reduction, c = a mod p\r\nvoid rdc_mont(const digit_t* a, digit_t* c);\r\n            \r\n// Field multiplication using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpmul751_mont(const felm_t a, const felm_t b, felm_t c);\r\nvoid mul751_asm(const felm_t a, const felm_t b, dfelm_t c);\r\nvoid rdc751_asm(const dfelm_t ma, dfelm_t mc);\r\n   \r\n// Field squaring using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpsqr751_mont(const felm_t ma, felm_t mc);\r\n\r\n// Conversion to Montgomery representation\r\nvoid to_mont(const felm_t a, felm_t mc);\r\n    \r\n// Conversion from Montgomery representation to standard representation\r\nvoid from_mont(const felm_t ma, felm_t c);\r\n\r\n// Field inversion, a = a^-1 in GF(p751)\r\nvoid fpinv751_mont(felm_t a);\r\n\r\n// Field inversion, a = a^-1 in GF(p751) using the binary GCD \r\nvoid fpinv751_mont_bingcd(felm_t a);\r\n\r\n// Chain to compute (p751-3)/4 using Montgomery arithmetic\r\nvoid fpinv751_chain_mont(felm_t a);\r\n\r\n/************ GF(p^2) arithmetic functions *************/\r\n    \r\n// Copy of a GF(p751^2) element, c = a\r\nvoid fp2copy751(const f2elm_t a, f2elm_t c);\r\n\r\n// Zeroing a GF(p751^2) element, a = 0\r\nvoid fp2zero751(f2elm_t a);\r\n\r\n// GF(p751^2) negation, a = -a in GF(p751^2)\r\nvoid fp2neg751(f2elm_t a);\r\n\r\n// GF(p751^2) addition, c = a+b in GF(p751^2)\r\nextern void fp2add751(const f2elm_t a, const f2elm_t b, f2elm_t c);           \r\n\r\n// GF(p751^2) subtraction, c = a-b in GF(p751^2)\r\nextern void fp2sub751(const f2elm_t a, const f2elm_t b, f2elm_t c); \r\n\r\n// GF(p751^2) division by two, c = a/2  in GF(p751^2) \r\nvoid fp2div2_751(const f2elm_t a, f2elm_t c);\r\n\r\n// Modular correction, a = a in GF(p751^2)\r\nvoid fp2correction751(f2elm_t a);\r\n            \r\n// GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)\r\nvoid fp2sqr751_mont(const f2elm_t a, f2elm_t c);\r\n \r\n// GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)\r\nvoid fp2mul751_mont(const f2elm_t a, const f2elm_t b, f2elm_t c);\r\n    \r\n// Conversion of a GF(p751^2) element to Montgomery representation\r\nvoid to_fp2mont(const f2elm_t a, f2elm_t mc);\r\n\r\n// Conversion of a GF(p751^2) element from Montgomery representation to standard representation\r\nvoid from_fp2mont(const f2elm_t ma, f2elm_t c);\r\n\r\n// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)\r\nvoid fp2inv751_mont(f2elm_t a);\r\n\r\n// GF(p751^2) inversion, a = (a0-i*a1)/(a0^2+a1^2), GF(p751) inversion done using the binary GCD \r\nvoid fp2inv751_mont_bingcd(f2elm_t a);\r\n\r\n// n-way Montgomery inversion\r\nvoid mont_n_way_inv(const f2elm_t* vec, const int n, f2elm_t* out);\r\n\r\n// Select either x or y depending on value of option \r\nvoid select_f2elm(const f2elm_t x, const f2elm_t y, f2elm_t z, const digit_t option);\r\n\r\n// Computes square roots of elements in (Fp2)^2 using Hamburg's trick.\r\nvoid sqrt_Fp2(const f2elm_t u, f2elm_t y);\r\n\r\n// Computes square roots of elements in (Fp2)^2 using Hamburg's trick\r\nvoid sqrt_Fp2_frac(const f2elm_t u, const f2elm_t v, f2elm_t y);\r\n\r\n// Cyclotomic cubing on elements of norm 1, using a^(p+1) = 1\r\nvoid cube_Fp2_cycl(f2elm_t a, const felm_t one);\r\n\r\n// Cyclotomic squaring on elements of norm 1, using a^(p+1) = 1\r\nvoid sqr_Fp2_cycl(f2elm_t a, const felm_t one);\r\n\r\n// Cyclotomic inversion, a^(p+1) = 1 => a^(-1) = a^p = a0 - i*a1\r\nextern void inv_Fp2_cycl(f2elm_t a);\r\n\r\n// Check if GF(p751^2) element is cube\r\nbool is_cube_Fp2(f2elm_t u, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 6 bits at most\r\nvoid exp6_Fp2_cycl(const f2elm_t y, const uint64_t t, const felm_t one, f2elm_t res);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 21 bits at most\r\nvoid exp21_Fp2_cycl(const f2elm_t y, const uint64_t t, const felm_t one, f2elm_t res);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is 84 bits at most\r\nvoid exp84_Fp2_cycl(const f2elm_t y, uint64_t* t, const felm_t one, f2elm_t res);\r\n\r\n// Exponentiation y^t via square and multiply in the cyclotomic group. Exponent t is length bits.\r\nvoid exp_Fp2_cycl(const f2elm_t y, uint64_t* t, const felm_t one, f2elm_t res, int length);\r\n\r\n/************ Elliptic curve and isogeny functions *************/\r\n\r\n// Check if curve isogeny structure is NULL\r\nbool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny);\r\n\r\n// Swap points over the base field \r\nvoid swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, const digit_t option);\r\n\r\n// Swap points\r\nvoid swap_points(point_proj_t P, point_proj_t Q, const digit_t option);\r\n\r\n// Computes the j-invariant of a Montgomery curve with projective constant.\r\nvoid j_inv(const f2elm_t A, const f2elm_t C, f2elm_t jinv);\r\n\r\n// Simultaneous doubling and differential addition.\r\nvoid xDBLADD(point_proj_t P, point_proj_t Q, const f2elm_t xPQ, const f2elm_t A24);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xDBL(const point_proj_t P, point_proj_t Q, const f2elm_t A24, const f2elm_t C24);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.\r\nvoid xDBLe(const point_proj_t P, point_proj_t Q, const f2elm_t A, const f2elm_t C, const int e);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings and collects a few intermediate multiples.\r\nvoid xDBLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Differential addition.\r\nvoid xADD(point_proj_t P, const point_proj_t Q, const f2elm_t xPQ);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.\r\nvoid xDBL_basefield(const point_basefield_proj_t P, point_basefield_proj_t Q);\r\n\r\n// Simultaneous doubling and differential addition over the base field.\r\nvoid xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, const felm_t xPQ, const felm_t A24);\r\n\r\n// The Montgomery ladder\r\nvoid ladder(const felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, const felm_t A24, const unsigned int order_bits, const unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes key generation entirely in the base field\r\nCRYPTO_STATUS secret_pt(const point_basefield_t P, const digit_t* m, const unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes P+[m]Q via x-only arithmetic.\r\nCRYPTO_STATUS ladder_3_pt(const f2elm_t xP, const f2elm_t xQ, const f2elm_t xPQ, const digit_t* m, const unsigned int AliceOrBob, point_proj_t W, const f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.\r\nvoid get_4_isog(const point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff);\r\n\r\n// Evaluates the isogeny at the point (X:Z) in the domain of the isogeny\r\nvoid eval_4_isog(point_proj_t P, f2elm_t* coeff);\r\n\r\n// Computes first 4-isogeny computed by Alice.\r\nvoid first_4_isog(point_proj_t P, const f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Tripling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xTPL(const point_proj_t P, point_proj_t Q, const f2elm_t A24, const f2elm_t C24);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.\r\nvoid xTPLe(const point_proj_t P, point_proj_t Q, const f2elm_t A, const f2elm_t C, const int e);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings and collects a few intermediate multiples.    \r\nvoid xTPLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.\r\nvoid get_3_isog(const point_proj_t P, f2elm_t A, f2elm_t C);\r\n\r\n// Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).\r\nvoid eval_3_isog(const point_proj_t P, point_proj_t Q);\r\n\r\n// 3-way simultaneous inversion\r\nvoid inv_3_way(f2elm_t z1, f2elm_t z2, f2elm_t z3);\r\n\r\n// Computing the point D = (x(Q-P),z(Q-P))\r\nvoid distort_and_diff(const felm_t xP, point_proj_t d, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Given the x-coordinates of P, Q, and R, returns the value A corresponding to the Montgomery curve E_A: y^2=x^3+A*x^2+x such that R=Q-P on E_A.\r\nvoid get_A(const f2elm_t xP, const f2elm_t xQ, const f2elm_t xR, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n/************ Functions for compression *************/\r\n\r\n// Produces points R1 and R2 as basis for E[2^372]\r\nvoid generate_2_torsion_basis(const f2elm_t A, point_full_proj_t R1, point_full_proj_t R2, PCurveIsogenyStruct CurveIsogeny); \r\n\r\n// Produces points R1 and R2 as basis for E[3^239]\r\nvoid generate_3_torsion_basis(f2elm_t A, point_full_proj_t R1, point_full_proj_t R2, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// 2-torsion Tate pairing\r\nvoid Tate_pairings_2_torsion(const point_t R1, const point_t R2, const point_t P, const point_t Q, const f2elm_t A, f2elm_t* n, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// 3-torsion Tate pairing\r\nvoid Tate_pairings_3_torsion(const point_t R1, const point_t R2, const point_t P, const point_t Q, const f2elm_t A, f2elm_t* n, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// The Montgomery ladder, running in non constant-time\r\nvoid Mont_ladder(const f2elm_t x, const digit_t* m, point_proj_t P, point_proj_t Q, const f2elm_t A24, const unsigned int order_bits, const unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// General addition\r\nvoid ADD(const point_full_proj_t P, const f2elm_t QX, const f2elm_t QY, const f2elm_t QZ, const f2elm_t A, point_full_proj_t R);\r\n\r\n// 2-torsion Pohlig-Hellman function\r\nvoid ph2(const point_t phiP, const point_t phiQ, const point_t PS, const point_t QS, const f2elm_t A, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Lookup table generation for 2-torsion PH\r\nvoid build_LUTs(const f2elm_t u, f2elm_t* t_ori, f2elm_t* LUT, f2elm_t* LUT_0, f2elm_t* LUT_1, f2elm_t* LUT_3, const felm_t one);\r\n\r\n// Pohlig-Hellman for groups of 2-power order up to 2^6 \r\nvoid phn1(const f2elm_t q, const f2elm_t* LUT, const uint64_t a, const felm_t one, uint64_t* alpha_i);\r\n\r\n// Pohlig-Hellman for groups of 2-power order 2^21 \r\nvoid phn5(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 2-power order 2^84 \r\nvoid phn21(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 2-power order 2^372 \r\nvoid phn84(f2elm_t r, const f2elm_t* t_ori, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const f2elm_t* LUT_3, const felm_t one, uint64_t* alpha);\r\n\r\n// 3-torsion Pohlig-Hellman function       \r\nvoid ph3(point_t phiP, point_t phiQ, point_t PS, point_t QS, f2elm_t A, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Lookup table generation for 3-torsion PH\r\nvoid build_LUTs_3(f2elm_t g, f2elm_t* t_ori, f2elm_t* LUT, f2elm_t* LUT_0, f2elm_t* LUT_1, const felm_t one);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up to 3^2 or 3^3 \r\nvoid phn1_3(const f2elm_t q, const f2elm_t* LUT, const uint64_t a, const felm_t one, uint64_t* alpha_i);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^15\r\nvoid phn3(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^56\r\nvoid phn15_1(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^61\r\nvoid phn15(f2elm_t q, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha_k);\r\n\r\n// Pohlig-Hellman for groups of 3-power order up 3^239\r\nvoid phn61(f2elm_t r, f2elm_t* t_ori, const f2elm_t* LUT, const f2elm_t* LUT_0, const f2elm_t* LUT_1, const felm_t one, uint64_t* alpha);\r\n\n// Recover the y-coordinates of the public key\nvoid recover_y(const publickey_t PK, point_full_proj_t phiP, point_full_proj_t phiQ, point_full_proj_t phiX, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\n// Computes the input modulo 3. The input is assumed to be NWORDS_ORDER long \nunsigned int mod3(digit_t* a); \r\n\n// Computes R+aS\nvoid mont_twodim_scalarmult(digit_t* a, const point_t R, const point_t S, const f2elm_t A, const f2elm_t A24, point_full_proj_t P, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n\r\nvoid compress_2_torsion(const unsigned char* PublicKeyA, unsigned char* CompressedPKA, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, point_t R1, point_t R2, PCurveIsogenyStruct CurveIsogeny);\r\nvoid compress_3_torsion(const unsigned char* PublicKeyA, unsigned char* CompressedPKA, uint64_t* a0, uint64_t* b0, uint64_t* a1, uint64_t* b1, point_t R1, point_t R2, PCurveIsogenyStruct CurveIsogeny);\r\nvoid decompress_2_torsion(const unsigned char* SecretKey, const unsigned char* CompressedPKA, point_proj_t R, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\nvoid decompress_3_torsion(const unsigned char* SecretKey, const unsigned char* CompressedPKA, point_proj_t R, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n\r\n#endif\r\n","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for ephemeral \r\n*       Diffie-Hellman key exchange.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: ephemeral isogeny-based key exchange\r\n*\r\n*********************************************************************************************/ \r\n\r\n#include \"SIDH_internal.h\"\r\n\r\nextern const unsigned int splits_Alice[MAX_Alice];\r\nextern const unsigned int splits_Bob[MAX_Bob];\r\n\r\n\r\nCRYPTO_STATUS EphemeralKeyGeneration_A(unsigned char* PrivateKeyA, unsigned char* PublicKeyA, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Alice's ephemeral key-pair generation\r\n  // It produces a private key PrivateKeyA and computes the public key PublicKeyA.\r\n  // The private key is an even integer in the range [2, oA-2], where oA = 2^372. \r\n  // The public key consists of 3 elements in GF(p751^2).\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    point_basefield_t P;\r\n    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_ALICE];\r\n    publickey_t* PublicKey = (publickey_t*)PublicKeyA;\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; \r\n    f2elm_t coeff[5], A = {0}, C = {0}, Aout, Cout;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; \r\n\r\n    if (PrivateKeyA == NULL || PublicKey == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }  \r\n\r\n    // Choose a random even number in the range [2, oA-2] as secret key for Alice\r\n    Status = random_mod_order((digit_t*)PrivateKeyA, ALICE, CurveIsogeny);    \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)PrivateKeyA, owords);\r\n        return Status;\r\n    }\r\n\r\n    to_mont((digit_t*)CurveIsogeny->PA, (digit_t*)P);                               // Conversion of Alice's generators to Montgomery representation\r\n    to_mont(((digit_t*)CurveIsogeny->PA)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); \r\n\r\n    Status = secret_pt(P, (digit_t*)PrivateKeyA, ALICE, R, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)PrivateKeyA, owords);\r\n        return Status;\r\n    }\r\n\r\n    copy_words((digit_t*)CurveIsogeny->PB, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Bob's public parameters, set Z <- 1\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);  \r\n    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        \r\n    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QB = (-XPB:1)\r\n    fpneg751(phiQ->X[0]);   \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z); \r\n    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DB = (x(QB-PB),z(QB-PB))\r\n\r\n    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(A[0], A[0]);\r\n    to_mont(C[0], C[0]);\r\n\r\n    first_4_isog(phiP, A, Aout, Cout, CurveIsogeny);     \r\n    first_4_isog(phiQ, A, Aout, Cout, CurveIsogeny);\r\n    first_4_isog(phiD, A, Aout, Cout, CurveIsogeny);\r\n    first_4_isog(R, A, A, C, CurveIsogeny);\r\n    \r\n    index = 0;        \r\n    for (row = 1; row < MAX_Alice; row++) {\r\n        while (index < MAX_Alice-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Alice[MAX_Alice-index-row];\r\n            xDBLe(R, R, A, C, (int)(2*m));\r\n            index += m;\r\n        }\r\n        get_4_isog(R, A, C, coeff);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_4_isog(pts[i], coeff);\r\n        }\r\n        eval_4_isog(phiP, coeff);\r\n        eval_4_isog(phiQ, coeff);\r\n        eval_4_isog(phiD, coeff);\r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n\r\n    get_4_isog(R, A, C, coeff); \r\n    eval_4_isog(phiP, coeff);\r\n    eval_4_isog(phiQ, coeff);\r\n    eval_4_isog(phiD, coeff);\r\n\r\n    inv_3_way(phiP->Z, phiQ->Z, phiD->Z);\r\n    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);\r\n    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);\r\n    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);\r\n                                   \r\n    from_fp2mont(phiP->X, ((f2elm_t*)PublicKey)[0]);                               // Converting back to standard representation\r\n    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKey)[1]);\r\n    from_fp2mont(phiD->X, ((f2elm_t*)PublicKey)[2]);\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)phiP, 2*2*pwords);\r\n    clear_words((void*)phiQ, 2*2*pwords);\r\n    clear_words((void*)phiD, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)coeff, 5*2*pwords);\r\n      \r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS EphemeralKeyGeneration_B(unsigned char* PrivateKeyB, unsigned char* PublicKeyB, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob's ephemeral key-pair generation\r\n  // It produces a private key PrivateKeyB and computes the public key PublicKeyB.\r\n  // The private key is an integer in the range [1, oB-1], where oA = 3^239. \r\n  // The public key consists of 3 elements in GF(p751^2).\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    point_basefield_t P;\r\n    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_BOB];\r\n    publickey_t* PublicKey = (publickey_t*)PublicKeyB;\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; \r\n    f2elm_t A = {0}, C = {0};\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  \r\n\r\n    if (PrivateKeyB == NULL || PublicKey == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }  \r\n\r\n    // Choose a random number equivalent to 0 (mod 3) in the range [3, oB-3] as secret key for Bob\r\n    Status = random_mod_order((digit_t*)PrivateKeyB, BOB, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)PrivateKeyB, owords);\r\n        return Status;\r\n    }\r\n\r\n    to_mont((digit_t*)CurveIsogeny->PB, (digit_t*)P);                               // Conversion of Bob's generators to Montgomery representation\r\n    to_mont(((digit_t*)CurveIsogeny->PB)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); \r\n\r\n    Status = secret_pt(P, (digit_t*)PrivateKeyB, BOB, R, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)PrivateKeyB, owords);\r\n        return Status;\r\n    }\r\n\r\n    copy_words((digit_t*)CurveIsogeny->PA, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Alice's public parameters, set Z <- 1\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);   \r\n    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        // Conversion to Montgomery representation\r\n    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QA = (-XPA:1)\r\n    fpneg751(phiQ->X[0]); \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z);  \r\n    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DA = (x(QA-PA),z(QA-PA))\r\n\r\n    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(A[0], A[0]);\r\n    to_mont(C[0], C[0]);\r\n    \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Bob; row++) {\r\n        while (index < MAX_Bob-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Bob[MAX_Bob-index-row];\r\n            xTPLe(R, R, A, C, (int)m);\r\n            index += m;\r\n        }\r\n        get_3_isog(R, A, C);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_3_isog(R, pts[i]);\r\n        }     \r\n        eval_3_isog(R, phiP);\r\n        eval_3_isog(R, phiQ);\r\n        eval_3_isog(R, phiD);\r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_3_isog(R, A, C);    \r\n    eval_3_isog(R, phiP);\r\n    eval_3_isog(R, phiQ);\r\n    eval_3_isog(R, phiD);\r\n\r\n    inv_3_way(phiP->Z, phiQ->Z, phiD->Z);\r\n    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);\r\n    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);\r\n    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);\r\n                                   \r\n    from_fp2mont(phiP->X, ((f2elm_t*)PublicKey)[0]);                               // Converting back to standard representation\r\n    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKey)[1]);\r\n    from_fp2mont(phiD->X, ((f2elm_t*)PublicKey)[2]);\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)phiP, 2*2*pwords);\r\n    clear_words((void*)phiQ, 2*2*pwords);\r\n    clear_words((void*)phiD, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n      \r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS EphemeralSecretAgreement_A(const unsigned char* PrivateKeyA, const unsigned char* PublicKeyB, unsigned char* SharedSecretA, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Alice's ephemeral shared secret computation\r\n  // It produces a shared secret key SharedSecretA using her secret key PrivateKeyA and Bob's public key PublicKeyB\r\n  // Inputs: Alice's PrivateKeyA is an even integer in the range [2, oA-2], where oA = 2^372. \r\n  //         Bob's PublicKeyB consists of 3 elements in GF(p751^2).\r\n  // Output: a shared secret SharedSecretA that consists of one element in GF(p751^2). \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; \r\n    point_proj_t R, pts[MAX_INT_POINTS_ALICE];\r\n    publickey_t* PublicKey = (publickey_t*)PublicKeyB;\r\n    f2elm_t jinv, coeff[5], PKB[3], A, C = {0};\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; \r\n\r\n    if (PrivateKeyA == NULL || PublicKey == NULL || SharedSecretA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n      \r\n    to_fp2mont(((f2elm_t*)PublicKey)[0], PKB[0]);    // Extracting and converting Bob's public curve parameters to Montgomery representation\r\n    to_fp2mont(((f2elm_t*)PublicKey)[1], PKB[1]);        \r\n    to_fp2mont(((f2elm_t*)PublicKey)[2], PKB[2]);\r\n\r\n    get_A(PKB[0], PKB[1], PKB[2], A, CurveIsogeny);\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(C[0], C[0]);\r\n\r\n    Status = ladder_3_pt(PKB[0], PKB[1], PKB[2], (digit_t*)PrivateKeyA, ALICE, R, A, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        return Status;\r\n    }\r\n    first_4_isog(R, A, A, C, CurveIsogeny); \r\n        \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Alice; row++) {\r\n        while (index < MAX_Alice-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Alice[MAX_Alice-index-row];\r\n            xDBLe(R, R, A, C, (int)(2*m));\r\n            index += m;\r\n        }\r\n        get_4_isog(R, A, C, coeff);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_4_isog(pts[i], coeff);\r\n        }\r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_4_isog(R, A, C, coeff); \r\n    j_inv(A, C, jinv);\r\n    from_fp2mont(jinv, (felm_t*)SharedSecretA);      // Converting back to standard representation\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)jinv, 2*pwords);\r\n    clear_words((void*)coeff, 5*2*pwords);\r\n      \r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS EphemeralSecretAgreement_B(const unsigned char* PrivateKeyB, const unsigned char* PublicKeyA, unsigned char* SharedSecretB, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob's ephemeral shared secret computation\r\n  // It produces a shared secret key SharedSecretB using his secret key PrivateKeyB and Alice's public key PublicKeyA\r\n  // Inputs: Bob's PrivateKeyB is an integer in the range [1, oB-1], where oB = 3^239. \r\n  //         Alice's PublicKeyA consists of 3 elements in GF(p751^2).\r\n  // Output: a shared secret SharedSecretB that consists of one element in GF(p751^2). \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; \r\n    point_proj_t R, pts[MAX_INT_POINTS_BOB];\r\n    publickey_t* PublicKey = (publickey_t*)PublicKeyA;\r\n    f2elm_t jinv, A, PKA[3], C = {0};\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  \r\n\r\n    if (PrivateKeyB == NULL || PublicKey == NULL || SharedSecretB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n       \r\n    to_fp2mont(((f2elm_t*)PublicKey)[0], PKA[0]);    // Extracting and converting Alice's public curve parameters to Montgomery representation\r\n    to_fp2mont(((f2elm_t*)PublicKey)[1], PKA[1]);       \r\n    to_fp2mont(((f2elm_t*)PublicKey)[2], PKA[2]);\r\n    \r\n    get_A(PKA[0], PKA[1], PKA[2], A, CurveIsogeny);\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(C[0], C[0]);\r\n\r\n    Status = ladder_3_pt(PKA[0], PKA[1], PKA[2], (digit_t*)PrivateKeyB, BOB, R, A, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        return Status;\r\n    }\r\n    \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Bob; row++) {\r\n        while (index < MAX_Bob-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Bob[MAX_Bob-index-row];\r\n            xTPLe(R, R, A, C, (int)m);\r\n            index += m;\r\n        }\r\n        get_3_isog(R, A, C);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_3_isog(R, pts[i]);\r\n        } \r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_3_isog(R, A, C);    \r\n    j_inv(A, C, jinv);\r\n    from_fp2mont(jinv, (felm_t*)SharedSecretB);      // Converting back to standard representation\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)jinv, 2*pwords);\r\n      \r\n    return Status;\r\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////          KEY EXCHANGE USING DECOMPRESSION           ///////////////\n\nvoid PublicKeyCompression_A(const unsigned char* PublicKeyA, unsigned char* CompressedPKA, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Alice's public key compression\r\n  // It produces a compressed output that consists of three elements in Z_orderB and one field element\r\n  // Input : Alice's public key PublicKeyA, which consists of 3 elements in GF(p751^2).\r\n  // Output: a compressed value CompressedPKA that consists of three elements in Z_orderB and one element in GF(p751^2). \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().                                                                        \n    point_full_proj_t P, Q, phP, phQ, phX;\n    point_t R1, R2, phiP, phiQ;\n    publickey_t PK;\n    digit_t* comp = (digit_t*)CompressedPKA;\n\tdigit_t inv[NWORDS_ORDER];\n    f2elm_t A, vec[4], Zinv[4];\n    digit_t a0[NWORDS_ORDER], b0[NWORDS_ORDER], a1[NWORDS_ORDER], b1[NWORDS_ORDER];\n    uint64_t Montgomery_Rprime[NWORDS64_ORDER] = {0x1A55482318541298, 0x070A6370DFA12A03, 0xCB1658E0E3823A40, 0xB3B7384EB5DEF3F9, 0xCBCA952F7006EA33, 0x00569EF8EC94864C}; // Value (2^384)^2 mod 3^239\n    uint64_t Montgomery_rprime[NWORDS64_ORDER] = {0x48062A91D3AB563D, 0x6CE572751303C2F5, 0x5D1319F3F160EC9D, 0xE35554E8C2D5623A, 0xCA29300232BC79A5, 0x8AAD843D646D78C5}; // Value -(3^239)^-1 mod 2^384\n    unsigned int bit;\n\n    to_fp2mont(((f2elm_t*)PublicKeyA)[0], ((f2elm_t*)&PK)[0]);    // Converting to Montgomery representation\n    to_fp2mont(((f2elm_t*)PublicKeyA)[1], ((f2elm_t*)&PK)[1]); \n    to_fp2mont(((f2elm_t*)PublicKeyA)[2], ((f2elm_t*)&PK)[2]); \n\n    recover_y(PK, phP, phQ, phX, A, CurveIsogeny);\n    generate_3_torsion_basis(A, P, Q, CurveIsogeny);\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    fp2copy751(phP->Z, vec[2]);\n    fp2copy751(phQ->Z, vec[3]);\n    mont_n_way_inv(vec, 4, Zinv);\n\n    fp2mul751_mont(P->X, Zinv[0], R1->x);\n    fp2mul751_mont(P->Y, Zinv[0], R1->y);\n    fp2mul751_mont(Q->X, Zinv[1], R2->x);\n    fp2mul751_mont(Q->Y, Zinv[1], R2->y);\n    fp2mul751_mont(phP->X, Zinv[2], phiP->x);\n    fp2mul751_mont(phP->Y, Zinv[2], phiP->y);\n    fp2mul751_mont(phQ->X, Zinv[3], phiQ->x);\n    fp2mul751_mont(phQ->Y, Zinv[3], phiQ->y);\n\n    ph3(phiP, phiQ, R1, R2, A, (uint64_t*)a0, (uint64_t*)b0, (uint64_t*)a1, (uint64_t*)b1, CurveIsogeny);\n    \n    bit = mod3(a0);\n    to_Montgomery_mod_order(a0, a0, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);    // Converting to Montgomery representation\n    to_Montgomery_mod_order(a1, a1, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n    to_Montgomery_mod_order(b0, b0, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);  \n    to_Montgomery_mod_order(b1, b1, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n    \n    if (bit != 0) {  // Storing [b1*a0inv, a1*a0inv, b0*a0inv] and setting bit384 to 0               \n        Montgomery_inversion_mod_order_bingcd(a0, inv, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);\n        Montgomery_multiply_mod_order(b0, inv, &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order(a1, inv, &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order(b1, inv, &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[0], &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);                           // Converting back from Montgomery representation\n        from_Montgomery_mod_order(&comp[NWORDS_ORDER], &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[2*NWORDS_ORDER], &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);\n        comp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 1;\n    } else {  // Storing [b1*b0inv, a1*b0inv, a0*b0inv] and setting bit384 to 1\n        Montgomery_inversion_mod_order_bingcd(b0, inv, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);         \n        Montgomery_multiply_mod_order(a0, inv, &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order(a1, inv, &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        Montgomery_multiply_mod_order(b1, inv, &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[0], &comp[0], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);                           // Converting back from Montgomery representation \n        from_Montgomery_mod_order(&comp[NWORDS_ORDER], &comp[NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(&comp[2*NWORDS_ORDER], &comp[2*NWORDS_ORDER], CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);\n        comp[3*NWORDS_ORDER-1] |= (digit_t)1 << (sizeof(digit_t)*8 - 1);\n    }\n    \n    from_fp2mont(A, (felm_t*)&comp[3*NWORDS_ORDER]);\n}\n\n\nvoid PublicKeyADecompression_B(const unsigned char* SecretKeyB, const unsigned char* CompressedPKA, unsigned char* point_R, unsigned char* param_A, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Alice's public key value decompression computed by Bob\r\n  // Inputs: Bob's private key SecretKeyB, and\r\n  //         Alice's compressed public key data CompressedPKA, which consists of three elements in Z_orderB and one element in GF(p751^2),\r\n  // Output: a point point_R in coordinates (X:Z) and the curve parameter param_A in GF(p751^2). Outputs are stored in Montgomery representation.\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().                                                                                                                             \n    point_t R1, R2;\n    point_proj_t* R = (point_proj_t*)point_R;\n    point_full_proj_t P, Q;\n    digit_t* comp = (digit_t*)CompressedPKA;\n    digit_t* SKin = (digit_t*)SecretKeyB;\n    f2elm_t A24, vec[2], invs[2], one = {0};\n    felm_t* A = (felm_t*)param_A;\n    digit_t t1[NWORDS_ORDER], t2[NWORDS_ORDER], t3[NWORDS_ORDER], t4[NWORDS_ORDER], vone[NWORDS_ORDER] = {0};\n    uint64_t Montgomery_Rprime[NWORDS64_ORDER] = {0x1A55482318541298, 0x070A6370DFA12A03, 0xCB1658E0E3823A40, 0xB3B7384EB5DEF3F9, 0xCBCA952F7006EA33, 0x00569EF8EC94864C}; // Value (2^384)^2 mod 3^239\n    uint64_t Montgomery_rprime[NWORDS64_ORDER] = {0x48062A91D3AB563D, 0x6CE572751303C2F5, 0x5D1319F3F160EC9D, 0xE35554E8C2D5623A, 0xCA29300232BC79A5, 0x8AAD843D646D78C5}; // Value -(3^239)^-1 mod 2^384\n    unsigned int bit;\n    \n    vone[0] = 1;\n    to_Montgomery_mod_order(vone, vone, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);  // Converting to Montgomery representation\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    to_fp2mont((felm_t*)&comp[3*NWORDS_ORDER], A);    // Converting to Montgomery representation\n    generate_3_torsion_basis(A, P, Q, CurveIsogeny);\n\n    // Normalize basis points\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    mont_n_way_inv(vec, 2, invs);\n    fp2mul751_mont(P->X, invs[0], R1->x);\n    fp2mul751_mont(P->Y, invs[0], R1->y);\n    fp2mul751_mont(Q->X, invs[1], R2->x);\n    fp2mul751_mont(Q->Y, invs[1], R2->y);\n\n    fp2add751(A, one, A24);\n    fp2add751(A24, one, A24);\n    fp2div2_751(A24, A24);\n    fp2div2_751(A24, A24);\n\n    bit = comp[3*NWORDS_ORDER-1] >> (sizeof(digit_t)*8 - 1);   \n    comp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 1;\n    to_Montgomery_mod_order(SKin, t1, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);    // Converting to Montgomery representation \n    to_Montgomery_mod_order(&comp[0], t2, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n    to_Montgomery_mod_order(&comp[NWORDS_ORDER], t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);  \n    to_Montgomery_mod_order(&comp[2*NWORDS_ORDER], t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime); \n\n    if (bit == 0) {    \n        Montgomery_multiply_mod_order(t1, t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t3, vone, t3, NWORDS_ORDER);   \n        Montgomery_inversion_mod_order_bingcd(t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);\n        Montgomery_multiply_mod_order(t1, t4, t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t2, t4, t4, NWORDS_ORDER);   \n        Montgomery_multiply_mod_order(t3, t4, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);    // Converting back from Montgomery representation\n        mont_twodim_scalarmult(t3, R1, R2, A, A24, P, CurveIsogeny);\n    } else {   \n        Montgomery_multiply_mod_order(t1, t4, t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t4, vone, t4, NWORDS_ORDER);   \n        Montgomery_inversion_mod_order_bingcd(t4, t4, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime, (digit_t*)&Montgomery_Rprime);\n        Montgomery_multiply_mod_order(t1, t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        mp_add(t2, t3, t3, NWORDS_ORDER);   \n        Montgomery_multiply_mod_order(t3, t4, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime); \n        from_Montgomery_mod_order(t3, t3, CurveIsogeny->Border, (digit_t*)&Montgomery_rprime);    // Converting back from Montgomery representation\n        mont_twodim_scalarmult(t3, R2, R1, A, A24, P, CurveIsogeny);\n    }\n\n    fp2copy751(P->X, R[0]->X);               \n    fp2copy751(P->Z, R[0]->Z);\n}\r\n\r\n\r\nCRYPTO_STATUS EphemeralSecretAgreement_Compression_A(const unsigned char* PrivateKeyA, const unsigned char* point_R, const unsigned char* param_A, unsigned char* SharedSecretA, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Alice's ephemeral shared secret computation\r\n  // It produces a shared secret key SharedSecretA using her secret key PrivateKeyA and Bob's decompressed data point_R and param_A\r\n  // Inputs: Alice's PrivateKeyA is an even integer in the range [2, oA-2], where oA = 2^372. \r\n  //         Bob's decompressed data consists of point_R in (X:Z) coordinates and the curve paramater param_A in GF(p751^2).\r\n  // Output: a shared secret SharedSecretA that consists of one element in GF(p751^2). \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; \r\n    point_proj_t R, pts[MAX_INT_POINTS_ALICE];\r\n    f2elm_t jinv, coeff[5], A, C = {0};\r\n\r\n    if (PrivateKeyA == NULL || SharedSecretA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n    \r\n    fp2copy751((((point_proj_t*)point_R)[0])->X, R->X);\r\n    fp2copy751((((point_proj_t*)point_R)[0])->Z, R->Z);\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(C[0], C[0]);\r\n    first_4_isog(R, (felm_t*)param_A, A, C, CurveIsogeny); \r\n        \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Alice; row++) {\r\n        while (index < MAX_Alice-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Alice[MAX_Alice-index-row];\r\n            xDBLe(R, R, A, C, (int)(2*m));\r\n            index += m;\r\n        }\r\n        get_4_isog(R, A, C, coeff);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_4_isog(pts[i], coeff);\r\n        }\r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_4_isog(R, A, C, coeff); \r\n    j_inv(A, C, jinv);\r\n    from_fp2mont(jinv, (felm_t*)SharedSecretA);      // Converting back to standard representation\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)jinv, 2*pwords);\r\n    clear_words((void*)coeff, 5*2*pwords);\r\n      \r\n    return CRYPTO_SUCCESS;\r\n}\n\n\nvoid PublicKeyCompression_B(const unsigned char* PublicKeyB, unsigned char* CompressedPKB, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob's public key compression\r\n  // It produces a compressed output that consists of three elements in Z_orderA and one field element\r\n  // Input : Bob's public key PublicKeyB, which consists of 3 elements in GF(p751^2).\r\n  // Output: a compressed value CompressedPKB that consists of three elements in Z_orderA and one element in GF(p751^2). \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().                                                       \n    point_full_proj_t P, Q, phP, phQ, phX;\n    point_t R1, R2, phiP, phiQ;\n    publickey_t PK;\n    digit_t* comp = (digit_t*)CompressedPKB;\n\tdigit_t inv[NWORDS_ORDER];\n    f2elm_t A, vec[4], Zinv[4];\n    digit_t a0[NWORDS_ORDER], b0[NWORDS_ORDER], a1[NWORDS_ORDER], b1[NWORDS_ORDER], tmp[2*NWORDS_ORDER], mask = (digit_t)(-1);\n    \n    mask >>= (CurveIsogeny->owordbits - CurveIsogeny->oAbits);  \n    to_fp2mont(((f2elm_t*)PublicKeyB)[0], ((f2elm_t*)&PK)[0]);    // Converting to Montgomery representation\n    to_fp2mont(((f2elm_t*)PublicKeyB)[1], ((f2elm_t*)&PK)[1]); \n    to_fp2mont(((f2elm_t*)PublicKeyB)[2], ((f2elm_t*)&PK)[2]); \n\n    recover_y(PK, phP, phQ, phX, A, CurveIsogeny);\n    generate_2_torsion_basis(A, P, Q, CurveIsogeny);\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    fp2copy751(phP->Z, vec[2]);\n    fp2copy751(phQ->Z, vec[3]);\n    mont_n_way_inv(vec, 4, Zinv);\n\n    fp2mul751_mont(P->X, Zinv[0], R1->x);\n    fp2mul751_mont(P->Y, Zinv[0], R1->y);\n    fp2mul751_mont(Q->X, Zinv[1], R2->x);\n    fp2mul751_mont(Q->Y, Zinv[1], R2->y);\n    fp2mul751_mont(phP->X, Zinv[2], phiP->x);\n    fp2mul751_mont(phP->Y, Zinv[2], phiP->y);\n    fp2mul751_mont(phQ->X, Zinv[3], phiQ->x);\n    fp2mul751_mont(phQ->Y, Zinv[3], phiQ->y);\n\n    ph2(phiP, phiQ, R1, R2, A, (uint64_t*)a0, (uint64_t*)b0, (uint64_t*)a1, (uint64_t*)b1, CurveIsogeny);\n\n    if ((a0[0] & 1) == 1) {  // Storing [b1*a0inv, a1*a0inv, b0*a0inv] and setting bit384 to 0\n        inv_mod_orderA(a0, inv);        \n\t\tmultiply(b0, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[0], NWORDS_ORDER);\n\t\tcomp[NWORDS_ORDER-1] &= mask;\n\t\tmultiply(a1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[2*NWORDS_ORDER-1] &= mask;\n\t\tmultiply(b1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[2 * NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[3*NWORDS_ORDER-1] &= mask;\n    } else {  // Storing [b1*b0inv, a1*b0inv, a0*b0inv] and setting bit384 to 1\n\t\tinv_mod_orderA(b0, inv);\n\t\tmultiply(a0, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[0], NWORDS_ORDER);\n\t\tcomp[NWORDS_ORDER - 1] &= mask;\n\t\tmultiply(a1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[2*NWORDS_ORDER-1] &= mask;\n\t\tmultiply(b1, inv, tmp, NWORDS_ORDER);\n\t\tcopy_words(tmp, &comp[2 * NWORDS_ORDER], NWORDS_ORDER);\n\t\tcomp[3*NWORDS_ORDER-1] &= mask;\n\t\tcomp[3*NWORDS_ORDER-1] |= (digit_t)1 << (sizeof(digit_t)*8 - 1);\n    }\n    \n    from_fp2mont(A, (felm_t*)&comp[3*NWORDS_ORDER]);  // Converting back from Montgomery representation\n}\n\n\nvoid PublicKeyBDecompression_A(const unsigned char* SecretKeyA, const unsigned char* CompressedPKB, unsigned char* point_R, unsigned char* param_A, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob's public key value decompression computed by Alice\r\n  // Inputs: Alice's private key SecretKeyA, and\r\n  //         Bob's compressed public key data CompressedPKB, which consists of three elements in Z_orderA and one element in GF(p751^2).\r\n  // Output: a point point_R in coordinates (X:Z) and the curve parameter param_A in GF(p751^2). Outputs are stored in Montgomery representation.\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().                                                                                           \n    point_t R1, R2;\n    point_proj_t* R = (point_proj_t*)point_R;\n    point_full_proj_t P, Q;\n    digit_t* comp = (digit_t*)CompressedPKB;\n    f2elm_t A24, vec[2], invs[2], one = {0};\n    felm_t* A = (felm_t*)param_A;\n    digit_t tmp1[2*NWORDS_ORDER], tmp2[2*NWORDS_ORDER], vone[2*NWORDS_ORDER] = {0}, mask = (digit_t)(-1);\n    unsigned int bit;\n\n    mask >>= (CurveIsogeny->owordbits - CurveIsogeny->oAbits);  \n    vone[0] = 1;\n    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);\n    to_fp2mont((felm_t*)&comp[3*NWORDS_ORDER], A);    // Converting to Montgomery representation\n    generate_2_torsion_basis(A, P, Q, CurveIsogeny);\n\n    // normalize basis points\n    fp2copy751(P->Z, vec[0]);\n    fp2copy751(Q->Z, vec[1]);\n    mont_n_way_inv(vec, 2, invs);\n    fp2mul751_mont(P->X, invs[0], R1->x);\n    fp2mul751_mont(P->Y, invs[0], R1->y);\n    fp2mul751_mont(Q->X, invs[1], R2->x);\n    fp2mul751_mont(Q->Y, invs[1], R2->y);\n\n    fp2add751(A, one, A24);\n    fp2add751(A24, one, A24);\n    fp2div2_751(A24, A24);\n    fp2div2_751(A24, A24);\n\n    bit = comp[3*NWORDS_ORDER-1] >> (sizeof(digit_t)*8 - 1);   \n    comp[3*NWORDS_ORDER-1] &= (digit_t)(-1) >> 1;\n\n    if (bit == 0) {\n\t\tmultiply((digit_t*)SecretKeyA, &comp[NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(tmp1, vone, tmp1, NWORDS_ORDER);\n\t\ttmp1[NWORDS_ORDER-1] &= mask;\n        inv_mod_orderA(tmp1, tmp2);  \n\t\tmultiply((digit_t*)SecretKeyA, &comp[2*NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(&comp[0], tmp1, tmp1, NWORDS_ORDER);  \n\t\tmultiply(tmp1, tmp2, vone, NWORDS_ORDER);  \n\t\tvone[NWORDS_ORDER-1] &= mask;  \n        mont_twodim_scalarmult(vone, R1, R2, A, A24, P, CurveIsogeny);\n    } else {\n\t\tmultiply((digit_t*)SecretKeyA, &comp[2*NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(tmp1, vone, tmp1, NWORDS_ORDER);\n\t\ttmp1[NWORDS_ORDER-1] &= mask;\n        inv_mod_orderA(tmp1, tmp2);  \n\t\tmultiply((digit_t*)SecretKeyA, &comp[NWORDS_ORDER], tmp1, NWORDS_ORDER);\n        mp_add(&comp[0], tmp1, tmp1, NWORDS_ORDER);  \n\t\tmultiply(tmp1, tmp2, vone, NWORDS_ORDER);  \n\t\tvone[NWORDS_ORDER-1] &= mask;   \n        mont_twodim_scalarmult(vone, R2, R1, A, A24, P, CurveIsogeny);\n    }\n\n    fp2copy751(P->X, R[0]->X);               \n    fp2copy751(P->Z, R[0]->Z);\n}\r\n\r\n\r\nCRYPTO_STATUS EphemeralSecretAgreement_Compression_B(const unsigned char* PrivateKeyB, const unsigned char* point_R, const unsigned char* param_A, unsigned char* SharedSecretB, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob's ephemeral shared secret computation\r\n  // It produces a shared secret key SharedSecretB using his secret key PrivateKeyB and Alice's decompressed data point_R and param_A\r\n  // Inputs: Bob's PrivateKeyB is an integer in the range [1, oB-1], where oB = 3^239. \r\n  //         Alice's decompressed data consists of point_R in (X:Z) coordinates and the curve paramater param_A in GF(p751^2).\r\n  // Output: a shared secret SharedSecretB that consists of one element in GF(p751^2). \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; \r\n    point_proj_t R, pts[MAX_INT_POINTS_BOB];\r\n    f2elm_t jinv, A, C = {0};\r\n\r\n    if (PrivateKeyB == NULL || SharedSecretB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n    \r\n    fp2copy751((((point_proj_t*)point_R)[0])->X, R->X);\r\n    fp2copy751((((point_proj_t*)point_R)[0])->Z, R->Z);\r\n    fp2copy751((felm_t*)param_A, A);\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(C[0], C[0]);\r\n    \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Bob; row++) {\r\n        while (index < MAX_Bob-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Bob[MAX_Bob-index-row];\r\n            xTPLe(R, R, A, C, (int)m);\r\n            index += m;\r\n        }\r\n        get_3_isog(R, A, C);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_3_isog(R, pts[i]);\r\n        } \r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_3_isog(R, A, C);    \r\n    j_inv(A, C, jinv);\r\n    from_fp2mont(jinv, (felm_t*)SharedSecretB);      // Converting back to standard representation\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)jinv, 2*pwords);\r\n      \r\n    return CRYPTO_SUCCESS;\r\n}","#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"SIDH_api.h\"\n#include \"SIDH.h\"\n#include \"randombytes.h\"\n#include \"utils.h\"\n\n\nPCurveIsogenyStruct isogeny;\n\nlong public_key_bytes\t\t= 576;\nlong full_public_key_bytes\t= 1152;\nlong private_key_bytes\t\t= 48;\nlong full_private_key_bytes\t= 96;\n\n\nCRYPTO_STATUS sidhjs_randombytes (unsigned int nbytes, unsigned char* random_array) {\n\trandombytes_buf(random_array, nbytes);\n\treturn CRYPTO_SUCCESS;\n}\n\nCRYPTO_STATUS sidhjs_init () {\n\trandombytes_stir();\n\n\tisogeny\t= SIDH_curve_allocate(&CurveIsogeny_SIDHp751);\n\n\treturn SIDH_curve_initialize(\n\t\tisogeny,\n\t\tsidhjs_randombytes,\n\t\t&CurveIsogeny_SIDHp751\n\t);\n}\n\nlong sidhjs_public_key_bytes_base () {\n\treturn public_key_bytes;\n}\n\nlong sidhjs_public_key_bytes () {\n\treturn full_public_key_bytes;\n}\n\nlong sidhjs_private_key_bytes_base () {\n\treturn private_key_bytes;\n}\n\nlong sidhjs_private_key_bytes () {\n\treturn full_public_key_bytes + full_private_key_bytes;\n}\n\nlong sidhjs_secret_bytes () {\n\treturn 192;\n}\n\n\nCRYPTO_STATUS sidhjs_keypair_base (\n\tuint8_t* public_key,\n\tuint8_t* private_key,\n\tint is_alice\n) {\n\tif (is_alice) {\n\t\treturn EphemeralKeyGeneration_A(private_key, public_key, isogeny);\n\t}\n\telse {\n\t\treturn EphemeralKeyGeneration_B(private_key, public_key, isogeny);\n\t}\n}\n\nCRYPTO_STATUS sidhjs_keypair (\n\tuint8_t* public_key,\n\tuint8_t* private_key\n) {\n\tCRYPTO_STATUS status\t= sidhjs_keypair_base(public_key, private_key, 1);\n\n\tif (status != CRYPTO_SUCCESS) {\n\t\treturn status;\n\t}\n\n\tstatus\t= sidhjs_keypair_base(\n\t\tpublic_key + public_key_bytes,\n\t\tprivate_key + private_key_bytes,\n\t\t0\n\t);\n\n\tif (status != CRYPTO_SUCCESS) {\n\t\treturn status;\n\t}\n\n\tmemcpy(\n\t\tprivate_key + full_private_key_bytes,\n\t\tpublic_key,\n\t\tfull_public_key_bytes\n\t);\n\n\treturn CRYPTO_SUCCESS;\n}\n\n\nCRYPTO_STATUS sidhjs_secret_base (\n\tuint8_t* public_key,\n\tuint8_t* private_key,\n\tuint8_t* secret,\n\tint is_alice\n) {\n\tif (is_alice) {\n\t\treturn EphemeralSecretAgreement_A(private_key, public_key, secret, isogeny);\n\t}\n\telse {\n\t\treturn EphemeralSecretAgreement_B(private_key, public_key, secret, isogeny);\n\t}\n}\n\nCRYPTO_STATUS sidhjs_secret (\n\tuint8_t* public_key,\n\tuint8_t* private_key,\n\tuint8_t* secret\n) {\n\tint is_alice\t= sodium_compare(\n\t\tpublic_key,\n\t\tprivate_key + full_private_key_bytes,\n\t\tfull_public_key_bytes\n\t);\n\n\tif (is_alice == 1) {\n\t\tpublic_key += public_key_bytes;\n\t}\n\telse if (is_alice == -1) {\n\t\tis_alice = 0;\n\t\tprivate_key += private_key_bytes;\n\t}\n\telse {\n\t\treturn CRYPTO_ERROR_INVALID_PARAMETER;\n\t}\n\n\treturn sidhjs_secret_base(\n\t\tpublic_key,\n\t\tprivate_key,\n\t\tsecret,\n\t\tis_alice\n\t);\n}\n"]}